/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include <mh_pb.h>
#include <mh_playlist.h>
#include <mh_dev.h>
#include <mh_player.h>
#include "stmdefs.h"
#include "playing.h"
#include "pause.h"
#include "seeking.h"
#include "switching.h"
#include "ready.h"
#include "error.h" 
typedef struct _MHPbPrivate MHPbPrivate;

struct _MHPbPrivate
{
	MHState * current;
	MHState * old_state;
	MHState * ready_state;
	MHState * play_state;
	MHState * pause_state;
	MHState * switching_state;
	MHState * seeking_state;
	MHState * error_state;

};

G_DEFINE_TYPE_WITH_PRIVATE( MHPb, mh_pb, MH_TYPE_IO )

#define MAX_FILE_IN_DEVICE 5000
#define MIN_FILE_INDEX 0

enum {
/* Ios */

	/* Signals */
	STATUS_UPDATE,

	PB_EVENTS,

	N_SIGNALS
};

static guint signals[ N_SIGNALS ] = {0};

static GObject * pbObject	=	NULL;

typedef struct _MHPbParam 
{
	MHPb * self;
	MHPbEvent event;
	gpointer param1;
	gpointer param2;
} MHPbParam;				/* ----------  end of struct MHPbParam  ---------- */

typedef struct _MHPbEventsInfo
{
	MHPb * pb;
	MHPbEventsListener listener;
} MHPbEventsInfo;

typedef struct _MHPbStatusInfo
{
	MHPb * pb;
	MHPbStatusListener listener;
} MHPbStatusInfo;

typedef struct _MHPbDisplaySize
{
	MHPb * pb;
	uint32_t offsetx;
	uint32_t offsety;
	uint32_t width;
	uint32_t height;
} MHPbDisplaySize;

typedef struct _MHPbDisplayPixel
{
	MHPb * pb;
	uint32_t pixel_n;
	uint32_t pixel_d;
} MHPbDisplayPixel;

enum
{
	PROP_0,

	PROP_PB_SHUFFLE,
	PROP_PB_REPEAT,
	PROP_PB_INDEX,
	PROP_PB_VIDEO_SINK,

	PROP_PB_AUDIO_TRACK,
	PROP_PB_SUBTITLE,

	PROP_PB_WINDOW_LAYER,
	PROP_PB_FORCE_ASPECT_RATIO,
	PROP_PB_WINDOW_X,
	PROP_PB_WINDOW_Y,
	PROP_PB_WINDOW_WIDTH,
	PROP_PB_WINDOW_HEIGHT,

	PROP_PB_AUDIO_SINK,
	PROP_PB_DEVICE_NAME,
	PROP_PB_BUFFER_TIME,

	PROP_PB_INVALTIME,
	PROP_PB_AUDIO_SINK_STREAMID,
	PROP_PB_VIDEO_SINK_SURFACEID,

	PROP_PB_AUDIO_SINK_SIRI_STREAMID,
	PROP_PB_AUDIO_SINK_TELE_STREAMID,
	PROP_PB_AUDIO_SINK_ALT_STREAMID,
	PROP_PB_USB_RATE,
	PROP_PB_OCTAVE_PERIOD,
	PROP_PB_OCTAVE_BANDS,
	PROP_PB_OCTAVE_ENABLE,

	N_PROPERTIES
};

static GParamSpec * pbProperties[ N_PROPERTIES ]	=	{ NULL, };

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _stop
 *  Description:
 * =====================================================================================
 */
static gboolean _stop( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _stop function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	mh_dev_stop( _self->mhDev, _self );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function stop  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _close
 *  Description:
 * =====================================================================================
 */
static gboolean _close( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _close function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	mh_dev_close( _self->mhDev, _self );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _close  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play
 *  Description:
 * =====================================================================================
 */
static gboolean _play( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _play function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	mh_pb_dispatch( _self, EVENT_PLAY, NULL, NULL );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function play  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pause
 *  Description:
 * =====================================================================================
 */
static gboolean _pause( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _pause function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	mh_pb_dispatch( _self, EVENT_PAUSE, NULL, NULL );
	
	return G_SOURCE_REMOVE;
}      /* -----  end of static function pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_pause
 *  Description:
 * =====================================================================================
 */
static gboolean _play_pause( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _play_pause function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );
	
	mh_dev_play_pause( _self->mhDev );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function play_pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _resume
 *  Description:
 * =====================================================================================
 */
static gboolean _resume( gpointer user_data )
{
	return G_SOURCE_REMOVE;
}      /* -----  end of static function resume  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_position
 *  Description:
 * =====================================================================================
 */
static gboolean _set_position( gpointer user_data )
{
	return G_SOURCE_REMOVE;
}      /* -----  end of static function set_position  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward
 *  Description:
 * =====================================================================================
 */
static gboolean _forward( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _forward function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	mh_pb_dispatch( _self, EVENT_SEEKING_FORWARD, NULL, NULL );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function forward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward_done
 *  Description:
 * =====================================================================================
 */
static gboolean _forward_done( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _forward_done function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}
	
	MHPb * _self	=	MH_PB( user_data );

	mh_pb_dispatch( _self, EVENT_SEEKING_FORWARD_DONE, NULL, NULL );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function forward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward
 *  Description:
 * =====================================================================================
 */
static gboolean _backward( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _backward function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	mh_pb_dispatch( _self, EVENT_SEEKING_BACKWARD, NULL, NULL );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function backward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward_done
 *  Description:
 * =====================================================================================
 */
static gboolean _backward_done( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _backward_done function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	mh_pb_dispatch( _self, EVENT_SEEKING_BACKWARD_DONE, NULL, NULL );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function backward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_index
 *  Description:
 * =====================================================================================
 */
static gboolean _set_index( gpointer user_data )
{
	MHPb * _self	=	MH_PB( user_data );

	_self->play_direction = 2;

	mh_pb_dispatch( _self, EVENT_SWITCHING_SELECT, NULL, NULL );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function set_index  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_speed
 *  Description:
 * =====================================================================================
 */
static gboolean _set_speed( gpointer user_data )
{
	return G_SOURCE_REMOVE;
}      /* -----  end of static function set_speed  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_repeat
 *  Description:
 * =====================================================================================
 */
static gboolean _set_repeat( gpointer user_data )
{
	MHPb * _self	=	MH_PB( user_data );

	mh_dev_set_repeat( _self->mhDev, _self );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function set_repeat  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_shuffle
 *  Description:
 * =====================================================================================
 */
static gboolean _set_shuffle( gpointer user_data )
{
	MHPb * _self	=	MH_PB( user_data );

	mh_dev_set_shuffle( _self->mhDev, _self );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function set_shuffle  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_rate
 *  Description:
 * =====================================================================================
 */
static gboolean _set_rate( gpointer user_data )
{
	MHPb * _self	=	MH_PB( user_data );

	mh_dev_set_rate( _self->mhDev, _self );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _set_rate  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_buffer_time
 *  Description:
 * =====================================================================================
 */
static gboolean _set_buffer_time( gpointer user_data )
{
	return G_SOURCE_REMOVE;
}      /* -----  end of static function set_buffer_time  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _playlist_change
 *  Description:
 * =====================================================================================
 */
static gboolean _playlist_change( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _playlist_change function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPbParam * _pbParam = ( MHPbParam *)user_data;

	mh_dev_playlist_change( _pbParam->self->mhDev, _pbParam->self, ( MHPlaylist * )_pbParam->param1 );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function set_buffer_time  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_set_media_info
 *  Description:
 * =====================================================================================
 */
void mh_pb_set_media_info( MHPb * pb, guint type, void * user_data )
{
	MHPbInfoData *_info = NULL;
	MHPb * _pb	=	pb;
	if ( user_data != NULL )
	{
		_info = ( MHPbInfoData * )user_data;
	}
	bool _flag	=	TRUE;
	int i; 
	switch( type )
	{
		case MH_PB_INFO_EOS:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_INFO_EOS, _info );
			break;
		case MH_PB_INFO_PTIME_CHANGE:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_INFO_PTIME_CHANGE, _info );
			break;
		case MH_PB_INFO_TAG:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_INFO_TAG, _info );
			g_free( _info->tag_info.title );
			g_free( _info->tag_info.artist );
			g_free( _info->tag_info.album );
			g_message("_info->tag_info.genre = %s", _info->tag_info.genre);
			g_free( _info->tag_info.genre );
			break;
		case MH_PB_INFO_ERROR:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_INFO_ERROR, _info );
			break;
		case MH_PB_INFO_TRACK_TOP:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_INFO_TRACK_TOP, _info );
			g_free( _info->track_info.uri );
			g_free( _info->track_info.name );
			break;
		case MH_PB_INFO_PLAYLIST_CHANGE:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_INFO_PLAYLIST_CHANGE, _info );
			break;
		case MH_PB_INFO_ERROR_NOT_EXIST:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_INFO_ERROR_NOT_EXIST, _info );
			break;

		case MH_PB_IP_INFO_PTIME_CHANGE:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_PTIME_CHANGE, _info );
			break;
		case MH_PB_IP_INFO_QUEUE_INDEX:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_QUEUE_INDEX, _info );
			break;
		case MH_PB_IP_INFO_MEDIA:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_MEDIA, _info );
			_flag	=	FALSE;
			break;
		case MH_PB_IP_INFO_REPEAT_MODE:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_REPEAT_MODE, _info );
			break;
		case MH_PB_IP_INFO_SHUFFLE_MODE:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_SHUFFLE_MODE, _info );
			break;
		case MH_PB_IP_INFO_COVER_PATH:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_COVER_PATH, _info );
			g_free( _info->cover_path );
			break;
		case MH_PB_IP_INFO_APP_NAME:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_APP_NAME, _info );
			g_free( _info->app_name);
			break;
		case MH_PB_IP_INFO_DEVICE_NAME:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_DEVICE_NAME, _info );
			g_free( _info->device_name);
			break;
		case MH_PB_IP_INFO_FUNC_UNSUPPORT:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_FUNC_UNSUPPORT, _info );
			break;
		case MH_PB_INFO_STATE_ERROR:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_INFO_STATE_ERROR, _info );
			break;
		case MH_PB_IP_INFO_SHUFFLE_LIST:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_SHUFFLE_LIST, _info );
			g_free( _info->sf_list_info.shuffle_seq );
			break;
		case MH_PB_IP_INFO_CALL_STATE_UPDATE:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_CALL_STATE_UPDATE, _info );
			g_free( _info->call_state_info.remoteID );
			g_free( _info->call_state_info.displayName );
			g_free( _info->call_state_info.callUUID );
			g_free( _info->call_state_info.addressBookID );
			g_free( _info->call_state_info.label );
			g_free( _info->call_state_info.conferenceGroup );
			break;
		case MH_PB_IP_INFO_RECENTS_LIST_UPDATES:
			{
				g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_RECENTS_LIST_UPDATES, _info );

				for( i = 0; i < _info->recentslist_updates.recentsListCount; i++ )
				{
					g_free( _info->recentslist_updates.recentList[i].remoteID );
					g_free( _info->recentslist_updates.recentList[i].displayName );
					g_free( _info->recentslist_updates.recentList[i].label );
					g_free( _info->recentslist_updates.recentList[i].addressBookID );
				}
			}
			break;
		case MH_PB_IP_INFO_FAVORITES_LIST_UPDATES:
			{
				g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_FAVORITES_LIST_UPDATES, _info );

				for( i = 0; i < _info->favoriteslist_updates.favoritesListCount; i++ )
				{
					g_free( _info->favoriteslist_updates.favoritesList[i].remoteID );
					g_free( _info->favoriteslist_updates.favoritesList[i].displayName );
					g_free( _info->favoriteslist_updates.favoritesList[i].label );
					g_free( _info->favoriteslist_updates.favoritesList[i].addressBookID );
				}
			}
			break;
		case MH_PB_IP_INFO_PLAYBACK_SPEED:
			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_IP_INFO_PLAYBACK_SPEED, _info );
			break;
//		case MH_PB_FREQUENCY_ANALYSIS_RESULT:
//			g_signal_emit( _pb, signals[ PB_EVENTS ], 0, MH_PB_FREQUENCY_ANALYSIS_RESULT, _info );
			//del for mh-sample-server exit start
//			g_free( _info->frequency_analysis_result.bands );
//			g_free( _info->frequency_analysis_result.amplitudes );
			//del for mh-sample-server exit end
//			break;
		default:
			break;
	}
	if(( _info != NULL )&&( _flag == TRUE ))
		g_slice_free( MHPbInfoData, _info);
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_by_list
 *  Description:
 * =====================================================================================
 */
static gboolean _play_by_list( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _play_by_list function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}
	MHPbParam * _pbParam = ( MHPbParam *)user_data;
	MHPlaylist * _playlist = ( MHPlaylist *)_pbParam->param1;
	MHPb * _self	=	MH_PB( _pbParam->self );

	if(( _playlist	!=	NULL )&&( _playlist->array->len	!=	0 ))
	{ 
		if( _playlist->index >= _playlist->array->len  )
		{
			_playlist->index = 0;
			_playlist->ptime = 0;
		}
		MHPbPrivate * _priv	=	mh_pb_get_instance_private( _self );

//		if(( _playlist->index >= MIN_FILE_INDEX )&&( _playlist->index < MAX_FILE_IN_DEVICE ))
		if( _playlist->index >= MIN_FILE_INDEX )
		{
			if( _self->mh_player == NULL )
			{
//				if (_priv->current != NULL)
//				{
//					g_object_unref(_priv->current);
//					_priv->current = NULL;
//				}
				_priv->current	=	 MH_STATE( mh_state_ready_instance() );
				_priv->ready_state = _priv->current;
				mh_state_open( _priv->current, _self );
			}else{
				mh_pb_dispatch( _self, EVENT_CHANGE, GUINT_TO_POINTER( SWITCHING_STATUS ), NULL );
			}
			mh_dev_play_by_list(( MHDev * )_playlist->dev, _self, _playlist ); 
		}
	}

	return G_SOURCE_REMOVE;
}      /* -----  end of static function play_by_list  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_by_list
 *  Description:
 * =====================================================================================
 */
static gboolean _play_radio_by_index( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _play_radio_by_index function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}
	
	MHPbParam * _pbParam = ( MHPbParam *)user_data;
	MHPb * _self	=	MH_PB( _pbParam->self );
	MHDev * _dev	=	(MHDev * )_pbParam->param1;
	uint32_t index = *(( uint32_t * )_pbParam->param2);
	g_free(_pbParam->param2);
	mh_dev_play_radio_by_index(_dev, _self, index ); 
	
	return G_SOURCE_REMOVE;
}      /* -----  end of static function _play_radio_by_index  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_events_listener
 *  Description:
 * =====================================================================================
 */
static gboolean _register_events_listener( gpointer user_data )
{
	MHPbEventsInfo * _info = ( MHPbEventsInfo * )user_data;

	g_signal_connect( _info->pb, "pb_events", G_CALLBACK( _info->listener.callback ), _info->listener.user_data );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _register_events_listener  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_status_listener
 *  Description:
 * =====================================================================================
 */
static gboolean _register_status_listener( gpointer user_data )
{
	MHPbStatusInfo * _info = ( MHPbStatusInfo * )user_data;

	g_signal_connect( _info->pb, "status_update", G_CALLBACK( _info->listener.callback ), _info->listener.user_data );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _register_status_listener  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _seek
 *  Description:
 * =====================================================================================
 */
static gboolean _seek( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _seek function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}
	
	MHPbParam * _pbParam = ( MHPbParam * )user_data;

	_pbParam->self->seeking_pos = *(( uint32_t * )_pbParam->param1 );

	g_free( _pbParam->param1);

	mh_pb_dispatch( _pbParam->self, EVENT_SEEKING, NULL, NULL );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _seek  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _audiobook_playback_speed
 *  Description:
 * =====================================================================================
 */
static gboolean _audiobook_playback_speed( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _audiobook_playback_speed function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}
	
	MHPbParam * _pbParam = ( MHPbParam * )user_data;
	MHPb * _pb	=	MH_PB( _pbParam->self );
	uint32_t _speed = 	*(( uint32_t * )_pbParam->param1 );

	g_free( _pbParam->param1);

	mh_dev_audiobook_playback_speed( _pb->mhDev, _pb, _speed );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _audiobook_playback_speed  ----- */

/* 
 * ===  FUNCTION  ======================================================================
          Name:  _set_pipeline_status
 *  Description:
 * =====================================================================================
 */
static gboolean _set_pipeline_status( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _set_pipeline_status function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}
	
	MHPbParam * _pbParam = ( MHPbParam * )user_data;
	MHPb * _pb	=	MH_PB( _pbParam->self );
	uint32_t _status = 	*(( uint32_t * )_pbParam->param1 );

	g_free( _pbParam->param1);

	mh_dev_set_pipeline_status( _pb->mhDev, _pb, _status );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _set_pipeline_status  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _next
 *  Description:
 * =====================================================================================
 */
static gboolean _next( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _next function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	_self->play_direction = 2;

	mh_pb_dispatch( _self, EVENT_SWITCHING_NEXT, NULL, NULL );
	
	return G_SOURCE_REMOVE;
}      /* -----  end of static function next  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _previous
 *  Description:
 * =====================================================================================
 */
static gboolean _previous( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _previous function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPb * _self	=	MH_PB( user_data );

	_self->play_direction = 1;

	mh_pb_dispatch( _self, EVENT_SWITCHING_PREVIOUS, NULL, NULL );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function previous  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _resize
 *  Description:
 * =====================================================================================
 */
static gboolean _resize( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _resize function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPbDisplaySize * _size = ( MHPbDisplaySize * )user_data;
	MHPb * _pb	=	MH_PB( _size->pb );
	
	mh_dev_resize( _pb->mhDev, _pb, ( uint32_t )_size->offsetx, ( uint32_t )_size->offsety,
							( uint32_t )_size->width, ( uint32_t )_size->height );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _resize  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pixel_aspect_ratio
 *  Description:
 * =====================================================================================
 */
static gboolean _pixel_aspect_ratio( gpointer user_data )
{
	if( user_data == NULL )
	{
		g_warning( "pb _pixel_aspect_ratio function : user_data is NULL\n" );
		return G_SOURCE_REMOVE;
	}

	MHPbDisplayPixel * _pixel = ( MHPbDisplayPixel * )user_data;
	MHPb * _pb	=	MH_PB( _pixel->pb );
	
	mh_dev_pixel_aspect_ratio( _pb->mhDev, _pb, ( uint32_t )_pixel->pixel_n, ( uint32_t )_pixel->pixel_d );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _pixel_aspect_ratio  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_track_info
 *  Description:
 * =====================================================================================
 */
static MHPbTrackInfo *  _get_track_info( MHPb * self)
{
	MHPbTrackInfo	* _res	=	NULL;
	if( self->mh_player	!=	NULL )
	{
		return mh_player_get_track_info( self->mh_player );
	}else{
		return _res;
	}
}      /* -----  end of static function _get_track_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_subtitle_info
 *  Description:
 * =====================================================================================
 */
static MHPbSubtitleInfo *  _get_subtitle_info( MHPb * self)
{
	MHPbSubtitleInfo	* _res	=	NULL;
	if( self->mh_player	!=	NULL )
	{
		return mh_player_get_subtitle_info( self->mh_player );
	}else{
		return _res;
	}
}      /* -----  end of static function _get_subtitle_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_from
 *  Description:
 * =====================================================================================
 */
static gboolean _play_from( gpointer user_data )
{
	return G_SOURCE_REMOVE;
}      /* -----  end of static function play_from  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_property
 *  Description:
 * =====================================================================================
 */
static void _set_property( GObject * object, guint property_id, const GValue * value,
		GParamSpec * spec)
{
	MHPb * _self  =   MH_PB( object );

	switch( property_id )
	{
		case PROP_PB_SHUFFLE:
			_self->shuffle_mode	=	g_value_get_uint( value );
			_set_shuffle( _self );
			break;
		case PROP_PB_REPEAT:
			_self->repeat_mode	=	g_value_get_uint( value );
			_set_repeat( _self );
			break;
		case PROP_PB_INDEX:
			if( _self->playlist != NULL )
			{
				if(  g_value_get_uint( value ) < _self->playlist->array->len )
				{
					_self->playlist->index	=	g_value_get_uint( value );	
					_set_index( _self );
				}	
			}else{
				g_message(" playback playlist is NULL ");
			}
			break;

		case PROP_PB_VIDEO_SINK:
			_self->video_sink_name = g_strdup( g_value_get_string( value ));
			g_message( " video_sink_name = [ %s ]\n", _self->video_sink_name );
			break;
		case PROP_PB_AUDIO_TRACK:
			if( _self->mh_player != NULL )
			{
				mh_player_set_audio_track( _self->mh_player, g_value_get_uint( value ));
			}else{
				g_message(" Player is NULL!\n");
			}
			break;
		case PROP_PB_SUBTITLE:
			if( _self->mh_player != NULL )
			{
				mh_player_set_subtitle( _self->mh_player, g_value_get_uint( value ));
			}else{
				g_message(" Player is NULL!\n");
			}
			break;
		case PROP_PB_WINDOW_LAYER:
			_self->window_layer	=	g_value_get_uint( value );
			g_message( " window_layer = [ %d ]\n", _self->window_layer );
			break;
		case PROP_PB_FORCE_ASPECT_RATIO:
			_self->force_aspect_ratio	=	g_value_get_boolean( value );
			g_message( "force_aspect_ratio = [ %d ]\n", _self->force_aspect_ratio );
			break;
		case PROP_PB_AUDIO_SINK:
			_self->audio_sink_name	=	g_strdup( g_value_get_string( value ));
			g_message( " audio_sink_name = [ %s ]\n", _self->audio_sink_name );
			break;
		case PROP_PB_DEVICE_NAME:
			_self->device_name	=	g_strdup( g_value_get_string( value ));
			g_message( " device_name = [ %s ]\n", _self->device_name );
			break;
		case PROP_PB_BUFFER_TIME:
			_self->buffer_time	=	g_value_get_uint( value );
			g_message( " buffer_time = [ %d ]\n", _self->buffer_time );
			break;

		case PROP_PB_WINDOW_X:
			_self->disp_x	=	g_value_get_uint( value );
			g_message( "window_x	=	%d\n", _self->disp_x );
			break;

		case PROP_PB_WINDOW_Y:
			_self->disp_y	=	g_value_get_uint( value );
			g_message( "window_y	=	%d\n", _self->disp_y );
			break;

		case PROP_PB_WINDOW_WIDTH:
			_self->disp_width=	g_value_get_uint( value );
			g_message( "window_width	=	%d\n", _self->disp_width );
			break;

		case PROP_PB_WINDOW_HEIGHT:
			_self->disp_height=	g_value_get_uint( value );
			g_message( "window_width	=	%d\n", _self->disp_height );
			break;
	
		case PROP_PB_INVALTIME:
			if( _self->mh_player != NULL )
			{
				mh_player_set_intvaltime( _self->mh_player, g_value_get_uint( value ));
			}else{
				g_message(" Player is NULL!\n");
			}
			break;
		case PROP_PB_AUDIO_SINK_STREAMID:
			if( _self->streamid != NULL )
				g_free( _self->streamid );

			_self->streamid = g_strdup( g_value_get_string( value ));
			g_message( " streamid = [ %s ]\n", _self->streamid );
			break;

		case PROP_PB_AUDIO_SINK_SIRI_STREAMID:
			if( _self->siri_streamid != NULL )
				g_free( _self->siri_streamid );

			_self->siri_streamid = g_strdup( g_value_get_string( value ));
			g_message( " siri_streamid = [ %s ]\n", _self->siri_streamid );
			break;

		case PROP_PB_AUDIO_SINK_TELE_STREAMID:
			if( _self->tele_streamid != NULL )
				g_free( _self->tele_streamid );

			_self->tele_streamid = g_strdup( g_value_get_string( value ));
			g_message( " tele_streamid = [ %s ]\n", _self->tele_streamid );
			break;

		case PROP_PB_AUDIO_SINK_ALT_STREAMID:
			if( _self->alt_streamid != NULL )
				g_free( _self->alt_streamid );

			_self->alt_streamid = g_strdup( g_value_get_string( value ));
			g_message( " alt_streamid = [ %s ]\n", _self->alt_streamid );
			break;

		case PROP_PB_VIDEO_SINK_SURFACEID:
			_self->surfaceid = g_value_get_uint( value );
			g_message( " surfaceid = [ %d ]\n", _self->surfaceid );
			break;
		case PROP_PB_USB_RATE:
			_self->rate = g_value_get_double( value );
//			_self->rate = (gdouble)g_value_get_int( value )/10;
			_set_rate( _self );
			g_message( " rate = [ %f ]\n", _self->rate );
			break;
		case PROP_PB_OCTAVE_PERIOD:
			if( _self->octave_period != NULL )
			{
				g_free( _self->octave_period );
				_self->octave_period = NULL;
			}
			_self->octave_period	=	g_strdup( g_value_get_string( value ));
			g_message( "octave_period	=	%s\n", _self->octave_period );
			break;
		case PROP_PB_OCTAVE_BANDS:
			if( _self->octave_bands != NULL )
			{
				g_free( _self->octave_bands );
				_self->octave_bands = NULL;
			}
			_self->octave_bands	=	g_strdup( g_value_get_string( value ));
			g_message( "octave_bands	=	%s\n", _self->octave_bands );
			break;
		case PROP_PB_OCTAVE_ENABLE:
			if( _self->octave_enable != NULL )
			{
				g_free( _self->octave_enable );
				_self->octave_enable = NULL;
			}
			_self->octave_enable	=	g_strdup( g_value_get_string( value ));
			g_message( "octave_enable	=	%s\n", _self->octave_enable );
			break;
		default:
			break;
	}
}       /*   -----  end of static function _set_property  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_property
 *  Description:
 * =====================================================================================
 */
static void _get_property( GObject * object, guint property_id, GValue * value,
		GParamSpec * spec)
{
	MHPb * _self  =   MH_PB( object );

	switch( property_id )
	{
		case PROP_PB_VIDEO_SINK:
			g_value_set_string( value, _self->video_sink_name );
			break;
		case PROP_PB_AUDIO_SINK:
			g_value_set_string( value, _self->audio_sink_name );
			break;
		default:
			break;
	}

}       /*   -----  end of static function _get_property  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_playlist_by_change
 *  Description:
 * =====================================================================================
 */
void mh_pb_playlist_by_change( MHPb * self, MHPlaylist * playlist )
{
	g_return_if_fail( MH_IS_PB( self ));
	g_return_if_fail( playlist != NULL );

	MHPbInfoData *_info = g_slice_new( MHPbInfoData );

	_info->playlist	=	playlist;

	self->playlist	=	playlist;

	mh_pb_set_media_info( self, MH_PB_INFO_PLAYLIST_CHANGE, _info );
	
}		/* -----  end of function mh_pb_playlist_by_change  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_constructor
 *  Description:  
 * =====================================================================================
 */
//static GObject * mh_pb_constructor( GType type, guint n_construct_params, 
//									GObjectConstructParam * construct_params )
//{
//	if( pbObject == NULL )
//	{
//		pbObject	=	G_OBJECT_CLASS( mh_pb_parent_class )->constructor( type, 
//						n_construct_params,	construct_params );
//	}
//
//	return pbObject;
//}		/* -----  end of static function mh_pb_constructor  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_dispose
 *  Description:
 * =====================================================================================
 */
static void mh_pb_dispose( GObject * object )
{
	MHPb * _self	=	MH_PB( object );
	MHPbPrivate * _priv	=	mh_pb_get_instance_private( MH_PB( object ));
	g_message("%s",__func__);
	if( _self->video_sink_name != NULL )
		g_free( _self->video_sink_name );
	
	if( _self->audio_sink_name != NULL )
		g_free( _self->audio_sink_name );

	if( _self->device_name != NULL )
		g_free( _self->device_name );

	if( _self->streamid != NULL )
		g_free( _self->streamid );

	if( _self->siri_streamid != NULL )
		g_free( _self->siri_streamid );

	if( _self->tele_streamid != NULL )
		g_free( _self->tele_streamid );

	if( _self->alt_streamid != NULL )
		g_free( _self->alt_streamid );

	if( _self->octave_period != NULL )
	{
		g_free( _self->octave_period );
		_self->octave_period = NULL;
	}
	if( _self->octave_bands != NULL )
	{
		g_free( _self->octave_bands );
		_self->octave_bands = NULL;
	}
	if( _self->octave_enable != NULL )
	{
		g_free( _self->octave_enable );
		_self->octave_enable = NULL;
	}

	if( _self->mh_player	!=	NULL)
	{
		g_object_unref( _self->mh_player );

		_self->mh_player	=	NULL;
	}

	if( _self->playlist != NULL ) 
	{
		g_object_unref(_self->playlist);

		_self->playlist	=	NULL;
	}

	if( _self->mhDev != NULL ) 
	{
		g_object_unref(_self->mhDev);

		_self->mhDev	=	NULL;
	}

	if (_priv->ready_state != NULL)
	{
		g_message("%s unref ready_state",__func__);
		g_object_unref(_priv->ready_state);
		_priv->ready_state = NULL;
	}
	if (_priv->play_state != NULL)
	{
		g_message("%s unref play_state",__func__);
		g_object_unref(_priv->play_state);
		_priv->play_state = NULL;
	}
	if (_priv->pause_state != NULL)
	{
		g_message("%s unref pause_state",__func__);
		g_object_unref(_priv->pause_state);
		_priv->pause_state = NULL;
	}
	if (_priv->switching_state != NULL)
	{
		g_message("%s unref switching_state",__func__);
		g_object_unref(_priv->switching_state);
		_priv->switching_state = NULL;
	}
	if (_priv->seeking_state != NULL)
	{
		g_message("%s unref seeking_state",__func__);
		g_object_unref(_priv->seeking_state);
		_priv->seeking_state = NULL;
	}
	if (_priv->error_state != NULL)
	{
		g_message("%s unref error_state",__func__);
		g_object_unref(_priv->error_state);
		_priv->error_state = NULL;
	}

	g_object_unref( _priv->current );
	G_OBJECT_CLASS( mh_pb_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_finalize
 *  Description:
 * =====================================================================================
 */
static void mh_pb_finalize( GObject * object )
{
	MHPb * _self	=	MH_PB( object );

	G_OBJECT_CLASS( mh_pb_parent_class )->finalize( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_init
 *  Description:
 * =====================================================================================
 */
static void mh_pb_init( MHPb * self )
{
	g_message("%s self = %p",__func__,self);
	self->play_direction = 2; 
	self->shuffle_start_index = 0; 
	self->seeking_pos = 0;
	self->mh_player = NULL;
	self->video_sink_name	=	NULL;
	self->audio_sink_name	=	NULL;
	self->device_name	=	NULL;
	self->buffer_time	=	200000;

	self->playlist	=	NULL;
	self->shuffle_mode	=	MH_PB_SHUFFLE_OFF;
	self->repeat_mode	=	MH_PB_REPEAT_MODE_ALL;

	self->window_layer	=	0;
	self->force_aspect_ratio	=	FALSE;
	self->disp_x = 0;
	self->disp_y = 0;
	self->disp_width = 0;
	self->disp_height = 0;
	self->pixel_n = 0;
	self->pixel_d = 0;
	self->state_error_source	=	NULL;
	self->streamid	=	NULL;
	self->surfaceid	=	0;

	self->siri_streamid	=	NULL;
	self->tele_streamid	=	NULL;
	self->alt_streamid	=	NULL;

	self->octave_period = NULL;
	self->octave_bands = NULL;
	self->octave_enable = NULL;

	MHPbPrivate * _priv	=	mh_pb_get_instance_private( self );

	_priv->current	=	MH_STATE( mh_state_ready_instance() );
	_priv->ready_state = _priv->current;
}       /* -----  end of static function mh_pb_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_pb_class_init( MHPbClass * klass )
{
	MHIoClass * _parentClass	=	MH_IO_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

//	_gobjectClass->constructor	=	mh_pb_constructor;
	_gobjectClass->dispose	=	mh_pb_dispose;
	_gobjectClass->finalize	=	mh_pb_finalize;
	_gobjectClass->set_property =   _set_property;
	_gobjectClass->get_property =   _get_property;
	
	klass->get_track_info	=	_get_track_info;
	klass->get_subtitle_info	=	_get_subtitle_info;

	/* assemble ios of mh_pb class */

	/* assemble methods of mh_pb class */

	/* Ios */
	/* Signals */
	signals[ STATUS_UPDATE ]	=
		g_signal_new( "status_update",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1
				, G_TYPE_UINT );

	signals[ PB_EVENTS ]	=
		g_signal_new( "pb_events",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				2	
				, G_TYPE_UINT, G_TYPE_POINTER );

	pbProperties[ PROP_PB_SHUFFLE ]	=	
		g_param_spec_uint( "shuffle", "MHPb property", "Shuffle mode of the playback",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE  );
	pbProperties[ PROP_PB_REPEAT ]	=	
		g_param_spec_uint( "repeat", "MHPb property", "Repeat mode of the playback",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_INDEX ]	=	
		g_param_spec_uint( "index", "MHPb property", "Index of the playing item in the playlist",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_VIDEO_SINK ]	=	
		g_param_spec_string( "video_sink", "MHPb property", "video sink name",
				"", G_PARAM_READWRITE );
	pbProperties[ PROP_PB_AUDIO_SINK ]	=	
		g_param_spec_string( "audio_sink", "MHPb property", "audio sink name",
				"", G_PARAM_READWRITE );
	pbProperties[ PROP_PB_DEVICE_NAME ]	=	
		g_param_spec_string( "device", "MHPb property", "device name",
				"", G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_BUFFER_TIME ]	=	
		g_param_spec_uint( "buffer_time", "MHPb property", "buffer time",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_AUDIO_TRACK ]	=	
		g_param_spec_uint( "audio_track", "MHPb property", "audio track",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_SUBTITLE ]	=	
		g_param_spec_uint( "subtitle", "MHPb property", "video subtitle",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_WINDOW_LAYER ]	=	
		g_param_spec_uint( "window_layer", "MHPb property", "window layer",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_FORCE_ASPECT_RATIO ]	=	
		g_param_spec_boolean( "force-aspect-ratio", "MHPb property", "window force aspect ratio",
				FALSE, G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_WINDOW_X]	=	
		g_param_spec_uint( "window_x", "MHPb property", "window x",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_WINDOW_Y]	=	
		g_param_spec_uint( "window_y", "MHPb property", "window y",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_WINDOW_WIDTH]	=	
		g_param_spec_uint( "window_width", "MHPb property", "window width",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_WINDOW_HEIGHT]	=	
		g_param_spec_uint( "window_height", "MHPb property", "window height",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_INVALTIME ]	=	
		g_param_spec_uint( "intvaltime", "MHPb property", "fast time",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_AUDIO_SINK_STREAMID ]	=	
		g_param_spec_string( "streamid", "MHPb property", "audio sink property StreamID",
				"", G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_AUDIO_SINK_SIRI_STREAMID ]	=	
		g_param_spec_string( "siri_streamid", "MHPb property", "audio sink property siri StreamID",
				"", G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_AUDIO_SINK_TELE_STREAMID ]	=	
		g_param_spec_string( "tele_streamid", "MHPb property", "audio sink property tele StreamID",
				"", G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_AUDIO_SINK_ALT_STREAMID ]	=	
		g_param_spec_string( "alt_streamid", "MHPb property", "audio sink property alt StreamID",
				"", G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_VIDEO_SINK_SURFACEID ]	=	
		g_param_spec_uint( "surfaceid", "MHPb property", "video sink  property StreamID",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_USB_RATE ]	=	
		g_param_spec_double( "rate", "MHPb property", "video sink  property rate",
				0.0, G_MAXDOUBLE, 1.0, G_PARAM_WRITABLE );

	pbProperties[ PROP_PB_OCTAVE_PERIOD]	=	
		g_param_spec_string( "octave_period", "MHPb property", "octave-period",
				"", G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_OCTAVE_BANDS]	=	
		g_param_spec_string( "octave_bands", "MHPb property", "octave-bands",
				"", G_PARAM_WRITABLE );
	pbProperties[ PROP_PB_OCTAVE_ENABLE]	=	
		g_param_spec_string( "octave_enable", "MHPb property", "octave-enable",
				"", G_PARAM_WRITABLE );
	g_object_class_install_properties( _gobjectClass, N_PROPERTIES, pbProperties );

}       /* -----  end of static function mh_pb_class_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_create
 *  Description:
 * =====================================================================================
 */
MHPb * mh_pb_create()
{
	return g_object_new( MH_TYPE_PB, "io-name", "playback", NULL );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_dispatch
 *  Description:
 * =====================================================================================
 */
gpointer _get_state_instance( MHPb * pb, gpointer param )
{
	gpointer _param = NULL;
	MHPbPrivate * _priv	=	mh_pb_get_instance_private( MH_PB( pb ));

	if( param != NULL )
	{
		switch( GPOINTER_TO_UINT( param ) )
		{
			case READY_STATUS:
				_param	=	( gpointer )mh_state_ready_instance();	
				_priv->ready_state = MH_STATE( _param );
				break;
			case PLAY_STATUS:
				_param	=	( gpointer )mh_state_playing_instance();	
				_priv->play_state = MH_STATE( _param );
				break;
			case PAUSE_STATUS:
				_param	=	( gpointer )mh_state_pause_instance();	
				_priv->pause_state = MH_STATE( _param );
				break;
			case SWITCHING_STATUS:
				_param	=	( gpointer )mh_state_switching_instance();	
				_priv->switching_state = MH_STATE( _param );
				break;
			case SEEKING_STATUS:
				_param	=	( gpointer )mh_state_seeking_instance();	
				_priv->seeking_state = MH_STATE( _param );
				break;
			case ERROR_STATUS:
				_param	=	( gpointer )mh_state_error_instance();	
				_priv->error_state = MH_STATE( _param );
				break;
			default:
				break;
		}
	}
	return _param;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_dispatch
 *  Description:
 * =====================================================================================
 */
void mh_pb_dispatch( MHPb * pb, guint event, gpointer param1, gpointer param2 )
{
	MHPbPrivate * _priv	=	mh_pb_get_instance_private( MH_PB( pb ));

	if( event	==	EVENT_CHANGE )
	{
		mh_state_close( _priv->current, pb );

//		g_object_unref( MH_STATE( _priv->current ));
	}

	gpointer _param1 = _get_state_instance(pb, param1 );
	gpointer _param2 = _get_state_instance(pb, param2 );
	switch( event )
	{
		case EVENT_CHANGE:

			if( _param2 != NULL )
			{
				_priv->old_state = MH_STATE( _param2 );	
			}
			if( _param1 != NULL )
			{
//				if (_priv->current != NULL)
//				{
//					g_object_unref(_priv->current);
//					_priv->current = NULL;
//				}
				_priv->current = MH_STATE( _param1 );
			}else{
//				if (_priv->current != NULL)
//				{
//					g_object_unref(_priv->current);
//					_priv->current = NULL;
//				}
				_priv->current = _priv->old_state;
			}
			mh_state_open( _priv->current, pb );
			break;
		default:
			mh_state_action( _priv->current, pb, event, _param1, _param2 );

			break;
	}
}		/* -----  end of function mh_pb_dispatch  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_state_open
 *  Description:
 * =====================================================================================
 */
void mh_pb_state_open( MHPb * pb, guint type, gpointer param1 )
{
	g_return_if_fail( MH_IS_PB( pb ));

	g_signal_emit_by_name( pb, "status_update", type );
}		/* -----  end of function mh_pb_state_open  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_stop
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_stop( MHPb * self )
{
	g_message( " %s->%p\n",__func__, self);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _stop, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_stop  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_close
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_close( MHPb * self )
{
	g_message( " %s->%p\n",__func__, self);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _close, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_close  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_play
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_play( MHPb * self )
{
	g_message( " %s->%p\n",__func__, self);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _play, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;

}		/* -----  end of function mh_pb_play  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_pause
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_pause( MHPb * self )
{
	g_message( " %s->%p\n",__func__, self);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _pause, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;

}		/* -----  end of function mh_pb_pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_play_pause
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_play_pause(MHPb * self)
{
	MHResult  _res	=	MH_OK;

	g_message( " %s\n",__func__);
	g_return_if_fail( MH_IS_PB( self ));

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _play_pause, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_play_pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_resume
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_resume()
{
	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _resume, pbObject, NULL );

	mh_io_dispatch( MH_IO( pbObject ), _source );

	g_source_unref( _source );

	return _res;

}		/* -----  end of function mh_pb_resume  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_set_position
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_set_position( uint32_t second )
{
	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _set_position, pbObject, NULL );

	mh_io_dispatch( MH_IO( pbObject ), _source );

	g_source_unref( _source );

	return _res;

}		/* -----  end of function mh_pb_set_position  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_forward
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_forward( MHPb * self )
{
	g_message( " %s\n",__func__);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _forward, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_forward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_forward_done
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_forward_done( MHPb * self )
{
	g_message( " %s\n",__func__);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _forward_done, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_forward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_backward
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_backward( MHPb * self )
{
	g_message( " %s\n",__func__);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _backward, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_backward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_backward_done
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_backward_done( MHPb * self )
{
	g_message( " %s\n",__func__);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult  _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _backward_done, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_backward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_set_index
 *  Description:
 * =====================================================================================
 */
//void mh_pb_set_index( MHPb * self, uint32_t index)
//{
//	GSource * _source	=	g_idle_source_new();
//
//	MHPbParam *_pbParam = g_new( MHPbParam, 1 );
//	_pbParam->self = self;
//	_pbParam->param1 = ( gpointer )index;
//
//	g_source_set_callback( _source, _set_index, _pbParam, g_free );
//
//	mh_io_dispatch( MH_IO( self ), _source );
//
//	g_source_unref( _source );
//}		/* -----  end of function mh_pb_set_index  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_set_speed
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_set_speed( uint32_t speed )
{
	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _set_speed, pbObject, NULL );

	mh_io_dispatch( MH_IO( pbObject ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_set_speed  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_set_repeat
 *  Description:
 * =====================================================================================
 */
//void mh_pb_set_repeat( MHPb * self, MHPbRepeatMode repeat_mode )
//{
//	GSource * _source	=	g_idle_source_new();
//
//	MHPbParam *_pbParam = g_new( MHPbParam, 1 );
//	_pbParam->self = self;
//	_pbParam->param1 = ( gpointer )repeat_mode;
//
//	g_source_set_callback( _source, _set_repeat, _pbParam, g_free );
//
//	mh_io_dispatch( MH_IO( self ), _source );
//
//	g_source_unref( _source );
//}		/* -----  end of function mh_pb_set_repeat  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_set_shuffle
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_set_shuffle()
{
	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _set_shuffle, pbObject, NULL );

	mh_io_dispatch( MH_IO( pbObject ), _source );

	g_source_unref( _source );
	return _res;
}		/* -----  end of function mh_pb_set_shuffle  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_play_by_list
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_play_by_list( MHPb * self, MHPlaylist * playlist, uint32_t index )
{
	g_message( " %s index = %d\n",__func__, index);
	g_return_val_if_fail( MH_IS_PB( self ) && MH_IS_PLAYLIST( playlist ), MH_INVALID_PARAM );
	MHResult _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	playlist->index	=	index;	
	MHPbParam *_pbParam = g_new( MHPbParam, 1 );
	_pbParam->self = self;
	_pbParam->param1 = ( gpointer )playlist;

	g_source_set_callback( _source, _play_by_list, _pbParam , g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
	return _res;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_play_radio_by_index
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_play_radio_by_index( MHDev * self, MHPb * pb, uint32_t index )
{
	MHResult	_res	=	MH_OK;
	g_return_val_if_fail( MH_IS_PB( pb ), MH_INVALID_PARAM);
	g_return_val_if_fail( MH_IS_DEV( self ), MH_INVALID_PARAM);
	
	uint32_t * _index	=	g_new( uint32_t , 1 );
	*_index	=	index;
	
	GSource * _source	=	g_idle_source_new();

	MHPbParam *_pbParam = g_new( MHPbParam, 1 );
	_pbParam->self = pb;
	_pbParam->param1 = ( gpointer )self;
	_pbParam->param2 = ( gpointer )_index;

	g_source_set_callback( _source, _play_radio_by_index, _pbParam , g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
	
	return _res;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_next
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_next( MHPb * self )
{
	g_message("%s",__func__);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _next, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_register_events_listener
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_register_events_listener( MHPb * self, MHPbEventsListener * listener )
{
	g_return_val_if_fail( MH_IS_PB( self )  && (listener->callback != NULL), MH_INVALID_PARAM);

	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	MHPbEventsInfo * _info = g_new0( MHPbEventsInfo, 1 );
	_info->listener = * listener;
	_info->pb	=	self;

	g_source_set_callback( _source, _register_events_listener, (gpointer)_info, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_register_status_listener
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_register_status_listener( MHPb * self, MHPbStatusListener * listener )
{
	g_return_val_if_fail( MH_IS_PB( self ) && (listener->callback != NULL), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	MHPbStatusInfo * _info = g_new0( MHPbStatusInfo, 1 );
	_info->listener = * listener;
	_info->pb	=	self;

	g_source_set_callback( _source, _register_status_listener, (gpointer)_info, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
	return _res;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_previous
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_previous( MHPb * self )
{
	g_message( " %s\n",__func__);
	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _previous, self, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
	return _res;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_set_buffer_time
 *  Description:
 * =====================================================================================
 */
void mh_pb_set_buffer_time()
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _set_buffer_time, pbObject, NULL );

	mh_io_dispatch( MH_IO( pbObject ), _source );

	g_source_unref( _source );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_play_from
 *  Description:
 * =====================================================================================
 */
void mh_pb_play_from()
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _play_from, pbObject, NULL );

	mh_io_dispatch( MH_IO( pbObject ), _source );

	g_source_unref( _source );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_seek
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_seek( MHPb * self,  uint32_t second )
{
	g_message( " %s\n",__func__);
	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	MHPbParam *_pbParam = g_new( MHPbParam, 1 );
	uint32_t * _sec	=	g_new( uint32_t , 1 );
	*_sec	=	second;

	_pbParam->self = self;
	_pbParam->param1 = ( gpointer )_sec;
	
	g_source_set_callback( _source, _seek, _pbParam, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_seek  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_seek
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_audiobook_playback_speed( MHPb * self,  uint32_t speed )
{
	g_message( " %s speed = %d",__func__,speed);
	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	MHPbParam *_pbParam = g_new( MHPbParam, 1 );
	uint32_t * _speed	=	g_new( uint32_t , 1 );
	*_speed	=	speed;

	_pbParam->self = self;
	_pbParam->param1 = ( gpointer )_speed;
	
	g_source_set_callback( _source, _audiobook_playback_speed, _pbParam, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_audiobook_playback_speed  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_playlist_change
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_playlist_change( MHPb * self, MHPlaylist * playlist )
{
	g_return_val_if_fail( MH_IS_PB( self )&& (playlist != NULL), MH_INVALID_PARAM);

	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	MHPbParam *_pbParam = g_new( MHPbParam, 1 );
	_pbParam->self = self;
	_pbParam->param1 = ( gpointer )playlist;
	g_source_set_callback( _source, _playlist_change, _pbParam, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_playlist_change  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_resize
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_resize( MHPb * self, uint32_t offsetx, uint32_t offsety, uint32_t width, uint32_t height )
{
	g_message( " %s\n",__func__);
	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	MHPbDisplaySize *_size = g_new( MHPbDisplaySize, 1 );
	_size->pb	=	self;
	_size->offsetx	=	offsetx;
	_size->offsety	=	offsety;
	_size->width	=	width;
	_size->height	=	height;

	g_source_set_callback( _source, _resize, _size, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_resize  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_resize
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_pixel_aspect_ratio( MHPb * self, uint32_t pixel_n, uint32_t pixel_d )
{
	g_message("client %s pixel_n = %d,pixel_d = %d",__func__,pixel_n,pixel_d);
	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	MHPbDisplayPixel *_pixel = g_new( MHPbDisplayPixel, 1 );
	_pixel->pb	=	self;
	_pixel->pixel_n	=	pixel_n;
	_pixel->pixel_d	=	pixel_d;
	self->pixel_n = pixel_n;
	self->pixel_d = pixel_d;

	g_source_set_callback( _source, _pixel_aspect_ratio, _pixel, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_resize  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_get_track_info
 *  Description:
 * =====================================================================================
 */
MHPbTrackInfo * mh_pb_get_track_info( MHPb * self )
{
	g_return_val_if_fail( MH_IS_PB( self ), NULL );

	MHPbTrackInfo * _res	=	NULL;

	if( MH_PB_GET_CLASS( self )->get_track_info != NULL )
	{
		_res	=	 MH_PB_GET_CLASS( self )->get_track_info( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPbClass::get_track_info()'",
				G_OBJECT_TYPE_NAME( self ));
	}

	return _res;

}		/* -----  end of function mh_pb_get_track_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_get_subtitle_info
 *  Description:
 * =====================================================================================
 */
MHPbSubtitleInfo * mh_pb_get_subtitle_info( MHPb * self )
{
	g_return_val_if_fail( MH_IS_PB( self ), NULL );

	MHPbSubtitleInfo * _res	=	NULL;

	if( MH_PB_GET_CLASS( self )->get_subtitle_info != NULL )
	{
		_res	=	 MH_PB_GET_CLASS( self )->get_subtitle_info( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPbClass::get_subtitle_info()'",
				G_OBJECT_TYPE_NAME( self ));
	}

	return _res;

}		/* -----  end of function mh_pb_get_subtitle_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_pb_set_pipeline_status
 *  Description:
 * =====================================================================================
 */
MHResult mh_pb_set_pipeline_status( MHPb * self,  uint32_t status )
{
	g_message( " %s\n",__func__);

	g_return_val_if_fail( MH_IS_PB( self ), MH_INVALID_PARAM);

	MHResult	_res	=	MH_OK;

	GSource * _source	=	g_idle_source_new();

	MHPbParam *_pbParam = g_new( MHPbParam, 1 );

	uint32_t * _status	=	g_new( uint32_t , 1 );
	*_status	=	status;

	_pbParam->self = self;
	_pbParam->param1 = ( gpointer )_status;

	g_source_set_callback( _source, _set_pipeline_status, _pbParam, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_pb_set_pipeline_status  ----- */
