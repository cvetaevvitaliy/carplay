/*
 * Generated by object-codegen.
 */
#include <stdlib.h>
#include <glib.h>
#include <mh_dev.h>
#include <mh_core.h>
#include <mh_pb.h>
#include <mh_contents.h>
#include <mh_misc.h>
#include <gst/gst.h>
#include <string.h>
typedef struct _MHCorePrivate MHCorePrivate;

struct _MHCorePrivate
{
	GSList * devices;
};

G_DEFINE_TYPE_WITH_PRIVATE( MHCore, mh_core, MH_TYPE_IO )

enum {
	/* Ios */

	/* Signals */
	CORE_DEVICES,
	CORE_EVENTS,

	N_SIGNALS
};

static guint signals[ N_SIGNALS ] = {0};

static GObject * coreObject	=	NULL;

static gboolean coreStarted	=	FALSE;

static GModule * iap2_module;
static GModule * carplay_module;

typedef struct _MHCoreDevParam 
{
	MHDeviceType type;
	char * address;
	int connect;
} MHCoreDevParam;		

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_events_listener
 *  Description:
 * =====================================================================================
 */
static gboolean _register_events_listener( gpointer user_data )
{
	MHEventsListener * _listener	=	( MHEventsListener * )user_data;

	g_signal_connect( coreObject, "core_events", G_CALLBACK( _listener->callback ), _listener->user_data );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _register_events_listener  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _load_all_plugins
 *  Description:  
 * =====================================================================================
 */
static void _load_all_plugins()
{
	const gchar * _pluginsPath	=	getenv( "MH_PLUGINS_PATH" );
	gboolean _pluginFound	=	FALSE;

	_pluginsPath	=	_pluginsPath ? _pluginsPath : "/usr/lib/media-hub2";

	GDir * _dir	=	g_dir_open( _pluginsPath, 0, NULL );

	if( _dir != NULL )
	{
		do
		{
			const gchar * _name	=	g_dir_read_name( _dir );

			GModule * _module;
			plugin_instance _instance;

			if( _name == NULL ) break;

			if( g_regex_match_simple( "^libplugin-\\w*\\.so$", _name , 0, 0 ))
			{
				gchar * _plugin	=	g_strdup_printf( "%s/%s", _pluginsPath, _name );
				
				_module	=	g_module_open( _plugin, G_MODULE_BIND_LAZY );

				if( _module != NULL )
				{
					if( strstr( _plugin, "iap" ) != NULL )
					{
						iap2_module	=	_module;
					}
					if( strstr( _plugin, "carplay" ) != NULL )
					{
						carplay_module	=	_module;
					}

					if( g_module_symbol( _module, "mh_plugin_instance", 
								( void * )&_instance ))
					{
						if(_instance())
						{
							_pluginFound	=	TRUE;

//							g_signal_emit_by_name( coreObject, "core_events", MH_CORE_PLUGIN_LOAD_SUCCESS );
						}
						else
							g_signal_emit_by_name( coreObject, "core_events", MH_CORE_PLUGIN_LOAD_FAILED,"" );
					}
					else
					{
						g_signal_emit_by_name( coreObject, "core_events", MH_CORE_PLUGIN_INVALID,"" );
					}
				}
				else
				{
					g_warning( "%s", g_module_error());
					g_signal_emit_by_name( coreObject, "core_events", MH_CORE_PLUGIN_INVALID,"" );
				}

				g_free( _plugin );
			}
		} while( TRUE );

		g_dir_close( _dir );
	}

	if( !_pluginFound )
	{
		g_signal_emit_by_name( coreObject, "core_events", MH_CORE_PLUGIN_NOT_FOUND,"" );
	}
}		/* -----  end of static function _load_all_plugins  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _find_dev
 *  Description:
 * =====================================================================================
 */
static gboolean _find_dev( gpointer user_data )
{
	MHCoreDevParam * _devParam = ( MHCoreDevParam *)user_data;

	MHDevParam * _Param 	=	(MHDevParam*)g_new0( MHDevParam, 1);
	_Param->type			=	_devParam->type;
	_Param->mac_addr		=	g_strdup( _devParam->address );
	_Param->connect_status	=	_devParam->connect;		

	g_message(" [%s] type = [%d]  mac_addr = [%s] connect = [%d]\n", 
			 __func__, _Param->type, _Param->mac_addr, _Param->connect_status );	

	plugin_dev_find _dev_find;

	if(( _devParam->type ==  MH_DEV_BT_IAP ) ||
			( _devParam->type ==  MH_DEV_WIFI_IAP ))
	{
		if( g_module_symbol( iap2_module, "mh_plugin_find_dev", ( void * )&_dev_find ))
		{
			if(_dev_find( _Param))
			{
				g_message(" Find idev plugin Success!\n");
			}		
		}
	}
	else
	if(( _devParam->type ==  MH_DEV_USB_CARPLAY ) ||
			( _devParam->type ==  MH_DEV_WIFI_CARPLAY ))
	{
		if( g_module_symbol( carplay_module, "mh_plugin_find_dev", ( void * )&_dev_find ))
		{
			if(_dev_find( _Param))
			{
				g_message(" Find carplay plugin Success!\n");
			}		
		}
	}
	else
	{
		g_message(" Don't Find dev plugin! \n");
	}

	g_free( _Param->mac_addr );
	g_free( _Param );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _find_dev  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _start
 *  Description:
 * =====================================================================================
 */
static gboolean _start( gpointer user_data )
{
	gst_init(NULL, NULL);
//	mh_pb_instance();                           /* create playback instance */
	mh_contents_instance();                     /* create contents instance */

	_load_all_plugins();

	g_signal_emit_by_name( coreObject, "core_events", MH_CORE_STARTED,"" );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function start  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _start_again
 *  Description:
 * =====================================================================================
 */
static gboolean _start_again( gpointer user_data )
{

	g_signal_emit_by_name( coreObject, "core_events", MH_CORE_STARTED,"" );

	return G_SOURCE_REMOVE;
}      /* -----  end of static function _start_again  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _stop
 *  Description:  
 * =====================================================================================
 */
static gboolean _stop( gpointer user_data )
{
	g_signal_emit_by_name( coreObject, "core_events", MH_CORE_STOPED,"" );

	return G_SOURCE_REMOVE;
}		/* -----  end of static function _stop  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_constructor
 *  Description:  
 * =====================================================================================
 */
static GObject * mh_core_constructor( GType type, guint n_construct_params, 
									GObjectConstructParam * construct_params )
{
	if( coreObject == NULL )
	{
		coreObject	=	G_OBJECT_CLASS( mh_core_parent_class )->constructor( type, 
						n_construct_params,	construct_params );
	}

	return coreObject;
}		/* -----  end of static function mh_core_constructor  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_dispose
 *  Description:
 * =====================================================================================
 */
static void mh_core_dispose( GObject * object )
{
	MHCore * _self	=	MH_CORE( object );

	G_OBJECT_CLASS( mh_core_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_finalize
 *  Description:
 * =====================================================================================
 */
static void mh_core_finalize( GObject * object )
{
	MHCore * _self	=	MH_CORE( object );
	MHCorePrivate * _priv	=	mh_core_get_instance_private( _self );

	G_OBJECT_CLASS( mh_core_parent_class )->finalize( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_init
 *  Description:
 * =====================================================================================
 */
static void mh_core_init( MHCore * self )
{
	MHCorePrivate * _priv	=	mh_core_get_instance_private( self );
	g_message("%s self = %p",__func__,self);
}       /* -----  end of static function mh_core_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_core_class_init( MHCoreClass * klass )
{
	MHIoClass * _parentClass	=	MH_IO_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->constructor	=	mh_core_constructor;
	_gobjectClass->dispose	=	mh_core_dispose;
	_gobjectClass->finalize	=	mh_core_finalize;

	/* assemble ios of mh_core class */

	/* assemble methods of mh_core class */

	/* Ios */
	/* Signals */
	signals[ CORE_DEVICES ]	=
		g_signal_new( "core_devices",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				2
				, G_TYPE_POINTER, G_TYPE_UINT );

	signals[ CORE_EVENTS ]	=
		g_signal_new( "core_events",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				2	
				, G_TYPE_UINT, G_TYPE_STRING );

}       /* -----  end of static function mh_core_class_init  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_instance
 *  Description:  
 * =====================================================================================
 */
MHCore * mh_core_instance()
{
	return g_object_new( MH_TYPE_CORE, "io-name", "core", NULL );
}		/* -----  end of function mh_core_instance  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_register_events_listener
 *  Description:  
 * =====================================================================================
 */
MHResult mh_core_register_events_listener( MHEventsListener * listener )
{
	g_return_val_if_fail( listener->callback != NULL, MH_INVALID_PARAM );

	MHEventsListener * _listener	=	g_new0( MHEventsListener, 1 );
	GSource * _source	=	g_idle_source_new();

	* _listener	=	* listener;

	g_source_set_callback( _source, _register_events_listener, _listener, g_free );

	mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

	g_source_unref( _source );

	return 0;
}		/* -----  end of function mh_core_register_events_listener  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_start
 *  Description:
 * =====================================================================================
 */
MHResult mh_core_start()
{
	MHResult _res	=	MH_OK;
	if( !coreStarted )
	{
		coreStarted	=	TRUE;

		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, _start, NULL, NULL );

		mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

		g_source_unref( _source );
	}
	else
	{
		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, _start_again, NULL, NULL );

		mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

		g_source_unref( _source );


	}
	return _res;
}		/* -----  end of function mh_core_start  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_stop
 *  Description:  
 * =====================================================================================
 */
MHResult mh_core_stop()
{
	MHResult _res	=	MH_OK;

	if( coreStarted )
	{
		coreStarted	=	FALSE;

		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, _stop, NULL, NULL );

		mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

		g_source_unref( _source );
	}
	
	return _res;
}		/* -----  end of function mh_core_stop  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _exists_dev
 *  Description:  
 * =====================================================================================
 */
static void _exists_dev( gpointer data, gpointer user_data )
{
	MHDevicesListener * _listener	=	( MHDevicesListener * )user_data;

	_listener->callback( MH_CORE( coreObject ), MH_DEV( data ), MH_DEV_ATTACHED, _listener->user_data );
}		/* -----  end of static function _exists_dev  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_dev_listener
 *  Description:  
 * =====================================================================================
 */
static gboolean _register_dev_listener( gpointer user_data )
{
	MHDevicesListener * _listener	=	( MHDevicesListener * )user_data;
	MHCorePrivate * _priv	=	mh_core_get_instance_private( MH_CORE( coreObject ) );

	/* we invoke the attached callback if storage existed */
	g_slist_foreach( _priv->devices, _exists_dev, _listener );

	g_signal_connect( coreObject, "core_devices", 
			G_CALLBACK( _listener->callback ), _listener->user_data );

	return G_SOURCE_REMOVE;
}		/* -----  end of static function _register_event_listener  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_register_devices_listener
 *  Description:  
 * =====================================================================================
 */
MHResult mh_core_register_devices_listener( MHDevicesListener * listener )
{
	g_return_val_if_fail( listener->callback != NULL, MH_INVALID_PARAM );

	GSource * _source	=	g_idle_source_new();
	MHDevicesListener * _listener	=	g_new0( MHDevicesListener, 1 );

	* _listener	=	* listener;

	g_source_set_callback( _source, _register_dev_listener, ( gpointer )_listener, g_free );

	mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

	g_source_unref( _source );

	return 0;
}		/* -----  end of function mh_core_register_devices_listener  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _compare
 *  Description:  
 * =====================================================================================
 */
static gint _compare( gconstpointer a, gconstpointer b)
{
	MHDev * _dev_a	=	(MHDev *)a;
	MHDev * _dev_b	=	(MHDev *)b;
	if( g_strcmp0(_dev_a->serial,_dev_b->serial) == 0 )
	{
		return 0;
	}
	else
	{
		return 1;
	}
}		/* -----  end of static function _compare  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_attach_dev
 *  Description:  
 * =====================================================================================
 */
void mh_core_attach_dev( MHDev * dev )
{
	MHCorePrivate * _priv	=	mh_core_get_instance_private( MH_CORE( coreObject ) );
	if(mh_core_find_dev_custom( dev , _compare) ==	NULL)
	{
		_priv->devices	=	g_slist_prepend( _priv->devices, dev );
		g_message("%s send MH_DEV_ATTACHED",__func__);
		g_signal_emit_by_name( coreObject, "core_devices", dev, MH_DEV_ATTACHED );
	}
	else
	{
		g_message("%s ERROR !!!!send MH_DEV_ATTACHED exist",__func__);
//		g_object_unref(dev);
	}
}		/* -----  end of function mh_core_attach_dev  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_detach_dev
 *  Description:  
 * =====================================================================================
 */
void mh_core_detach_dev( MHDev * dev )
{
	MHCorePrivate * _priv	=	mh_core_get_instance_private( MH_CORE( coreObject ) );

	_priv->devices	=	g_slist_remove( _priv->devices, dev );
	
	g_signal_emit_by_name( dev, "dev_detach");


}		/* -----  end of function mh_core_detach_dev  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_find_dev_custom
 *  Description:  
 * =====================================================================================
 */
MHDev * mh_core_find_dev_custom( const void * data, GCompareFunc func )
{
	MHCorePrivate * _priv	=	mh_core_get_instance_private( MH_CORE( coreObject ) );
	GSList * _node	=	g_slist_find_custom( _priv->devices, data, func );

	return _node == NULL ? NULL : _node->data;
}		/* -----  end of function mh_core_find_dev_custom  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_core_find_dev
 *  Description:
 * =====================================================================================
 */
MHResult mh_core_find_dev( MHDevParam * devParam )
{
	g_message("[%s]  type = [%d]  mac_addr = [%s] connect = [%d]\n", 
			__func__, devParam->type, devParam->mac_addr, devParam->connect_status );	

	MHCoreDevParam * _devParam	=	g_new( MHCoreDevParam, 1 );
	_devParam->type				=	devParam->type;
	_devParam->address			=	g_strdup( devParam->mac_addr );
	_devParam->connect			=	devParam->connect_status;	

	MHResult _res	=	MH_OK;
	
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _find_dev, _devParam, g_free );

	mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

	g_source_unref( _source );

	return _res;
}		/* -----  end of function mh_core_find_dev  ----- */
