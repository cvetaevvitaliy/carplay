/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include <mh_playlist.h>
#include <mh_item.h>
#include <mh_music.h>
#include <order.h>
typedef struct _MHPlaylistPrivate MHPlaylistPrivate;

struct _MHPlaylistPrivate
{
	guint dummy;
};

G_DEFINE_TYPE_WITH_PRIVATE( MHPlaylist, mh_playlist, G_TYPE_OBJECT )

enum
{
	PROP_0,

	PROP_PLAYLIST_COUNT,
	PROP_PLAYLIST_SHUFFLE,
	PROP_PLAYLIST_REPEAT,
	PROP_PLAYLIST_INDEX,
	PROP_PLAYLIST_PTIME,
	PROP_PLAYLIST_ERROR_COUNT,
	PROP_PLAYLIST_SEQ,
	PROP_PLAYLIST_DEV,

	N_PROPERTIES
};

static GParamSpec * playlistProperties[ N_PROPERTIES ]	=	{ NULL, };

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _clear_func
 *  Description:  
 * =====================================================================================
 */
static void _clear_func( gpointer data )
{
	g_free( data );
}		/* -----  end of static function _clear_func  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _insert
 *  Description:
 * =====================================================================================
 */
static void _insert( MHPlaylist * self, guint index, MHItem ** items, uint32_t count )
{
	int i;
	MHItemData ** _itemsData	=	g_new0( MHItemData *, count );

	for( i = 0; i < count; i ++ )
	{
		ITEM_TO_DATA( items[i] );

		if( items[i]->type == MH_ITEM_MUSIC )
		{ 
			MHMusic * _music	=	MH_MUSIC( items[i] );
			_data->metadata.music.title	=	g_strdup( _music->title );
			_data->metadata.music.artist	=	g_strdup( _music->artist );
			_data->metadata.music.album	=	g_strdup( _music->album_title );
			_data->metadata.music.genre	=	g_strdup( _music->genre );
			_data->metadata.music.composer	=	g_strdup( _music->composer );
			_data->metadata.music.year	=	_music->year;
			_data->metadata.music.track	=	_music->track;
			_data->metadata.music.trackCount	=	_music->track_count;
			_data->metadata.music.mediaType	=	_music->mediaType;

		}

		_itemsData[i]	=	_data;
	}

	self->array	=	g_array_insert_vals( self->array, index, _itemsData, count );

	self->seq	=	g_renew( guint, self->seq, self->array->len );

	for( i = 0; i < self->array->len; i ++ )
	{
		self->seq[i]	=	i;
	}
}      /* -----  end of static function _insert  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _remove
 *  Description:
 * =====================================================================================
 */
static MHResult _remove( MHPlaylist * self, uint32_t index, uint32_t length )
{
	g_return_val_if_fail( index < self->array->len, MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;

	int i;

	self->array	=	g_array_remove_range( self->array, index, length );

	self->seq	=	g_renew( guint, self->seq, self->array->len );

	for( i = 0; i < self->array->len; i ++ )
	{
		self->seq[i]	=	i;
	}
	return _res;
}      /* -----  end of static function _remove  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _sort
 *  Description:
 * =====================================================================================
 */
static void _sort( MHPlaylist * self, MHSortType sort_type, MHItemOrderType order_type )
{
	int i;
	switch( order_type )
	{
		case MH_ITEM_ORDER_BY_PINYIN:
			g_array_sort_with_data( self->array, playlist_orderByPinyin, &sort_type );
			break;
		case MH_ITEM_ORDER_BY_ALPHABET:
			g_array_sort_with_data( self->array, playlist_orderByAlphabet, &sort_type );
			break;
		case MH_ITEM_ORDER_BY_TRACKID:
			g_array_sort_with_data( self->array, playlist_orderByTrackId, &sort_type );
			break;
		case MH_ITEM_ORDER_BY_ALPHABET_FOR_NAGIVI:
			g_array_sort_with_data( self->array, playlist_orderByAlphabetForNagivi, &sort_type );
			break;
		case MH_ITEM_ORDER_BY_ALPHABET_FOR_NAGIVI_JP:
			g_array_sort_with_data( self->array, playlist_orderByAlphabetForNagiviJp, &sort_type );
			break;
		case MH_ITEM_ORDER_BY_DEFAULT:
			break;

	}
	for( i = 0; i < self->array->len; i ++ )
	{
		self->seq[i]	=	i;
	}
}      /* -----  end of static function _sort  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _append
 *  Description:  
 * =====================================================================================
 */
static void _append( MHPlaylist * self, MHItem ** items, int count )
{
	int i, _index	=	self->array->len;
	MHItemData ** _itemsData	=	g_new0( MHItemData *, count );
	int _playlistCount	=	0;
	int j	=	0;
	for( i = 0; i < count; i ++ )
	{
		if( items[i]->type != MH_ITEM_FOLDER)
		{
			ITEM_TO_DATA( items[i] );

			if( items[i]->type == MH_ITEM_MUSIC )
			{ 
				MHMusic * _music	=	MH_MUSIC( items[i] );

				_data->metadata.music.title	=	g_strdup( _music->title );
				_data->metadata.music.artist	=	g_strdup( _music->artist );
				_data->metadata.music.album	=	g_strdup( _music->album_title );
				_data->metadata.music.genre	=	g_strdup( _music->genre );
				_data->metadata.music.composer	=	g_strdup( _music->composer );
				_data->metadata.music.year	=	_music->year;
				_data->metadata.music.track	=	_music->track;
				_data->metadata.music.trackCount	=	_music->track_count;
				_data->metadata.music.mediaType	=	_music->mediaType;
				_data->metadata.music.duration	=	_music->duration;

			}

			_itemsData[j]	=	_data;
			j++;
		}
	}
	_playlistCount	=	j;

	self->array	=	g_array_append_vals( self->array, _itemsData, _playlistCount );

	self->seq	=	g_renew( guint, self->seq, self->array->len );

	for( i = _index; i < self->array->len; i ++ )
	{
		self->seq[i]	=	i;
	}

	g_free( _itemsData );
}		/* -----  end of static function _append  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _append_playlist
 *  Description:  
 * =====================================================================================
 */
static void _append_playlist( MHPlaylist * self, MHPlaylist * _another)
{
	int i = 0;
	int _index = self->array->len;
	int count = _another->array->len;
	
	g_message("%s, _index = %d, count = %d", __func__, _index, count);
	
	if (count <= 0)
		return;
	
	MHItemData ** _itemsData	=	g_new0( MHItemData *, count );
	MHItemData  *_itemsTempData = NULL;

	for( i = 0;  i <  count; i ++ )
	{
		_itemsTempData = g_array_index( _another->array, MHItemData *, i);
		MHItemData * _data	=	g_slice_new0( MHItemData ); 

		_data->uri	=	 g_strdup( _itemsTempData->uri ); 
		_data->type	=	_itemsTempData->type; 
		_data->name	=	g_strdup( _itemsTempData->name ); 
		_data->size	=	_itemsTempData->size;
		_data->uniqueId	=	_itemsTempData->uniqueId; 
		_data->valid	=	_itemsTempData->valid;
		_data->tagId	=	_itemsTempData->tagId;
		_data->favorite	=	_itemsTempData->favorite;
		
		_data->metadata.music.title	=	g_strdup( _itemsTempData->metadata.music.title );
		_data->metadata.music.artist	=	g_strdup( _itemsTempData->metadata.music.artist );
		_data->metadata.music.album	=	g_strdup( _itemsTempData->metadata.music.album);
		_data->metadata.music.genre	=	g_strdup( _itemsTempData->metadata.music.genre );
		_data->metadata.music.composer	=	g_strdup( _itemsTempData->metadata.music.composer);
		_data->metadata.music.year	=	_itemsTempData->metadata.music.year;
		_data->metadata.music.track	=	_itemsTempData->metadata.music.track;
		_data->metadata.music.trackCount	=	_itemsTempData->metadata.music.trackCount;
		_data->metadata.music.mediaType	=	_itemsTempData->metadata.music.mediaType;
		_data->metadata.music.duration	=	_itemsTempData->metadata.music.duration;

		_itemsData[i]	=	_data;
	}

	self->array	=	g_array_append_vals( self->array, _itemsData, count );

	self->seq	=	g_renew( guint, self->seq, self->array->len );

	for( i = _index; i < self->array->len; i ++ )
	{
		self->seq[i]	=	i;
	}

	g_free( _itemsData );
}		/* -----  end of static function _append  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _foreach
 *  Description:  
 * =====================================================================================
 */
static void _foreach( MHPlaylist * self, int32_t start, int32_t count, MHFunc func, void * user_data )
{
	int i;

	if( count <= 0 )
		count	=	self->array->len - start;

	for( i = 0; ( i + start ) <  self->array->len && i < count; i ++ )
	{
		if( func( g_array_index( self->array, MHItemData *, i + start ), user_data ))
			break;
	}
}		/* -----  end of static function _foreach  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _free_item
 *  Description:  
 * =====================================================================================
 */
static void _free_item( gpointer item )
{
	MHItemData * _item	=	( MHItemData * )item;

	g_free( _item->uri );
	g_free( _item->name );

	switch( _item->type )
	{
	case MH_ITEM_MUSIC:
		g_free( _item->metadata.music.title );
		g_free( _item->metadata.music.album );
		g_free( _item->metadata.music.artist );
		g_free( _item->metadata.music.genre );
		g_free( _item->metadata.music.composer );

		break;
	default:
		break;
	}

	g_slice_free( MHItemData, _item );
}		/* -----  end of static function _free_item  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_property
 *  Description:  
 * =====================================================================================
 */
static void _get_property( GObject * object, guint property_id, GValue * value,
		GParamSpec * spec)
{
	MHPlaylist * _self	=	MH_PLAYLIST( object );

	switch( property_id )
	{
	case PROP_PLAYLIST_COUNT:
		g_value_set_uint( value, _self->array->len );
		break;
	case PROP_PLAYLIST_SHUFFLE:
		g_value_set_uint( value, _self->shuffle );
		break;
	case PROP_PLAYLIST_REPEAT:
		g_value_set_uint( value, _self->repeat );
		break;
	case PROP_PLAYLIST_INDEX:
		if( _self->seq == NULL)
		{
			g_value_set_int( value, -1);
		}
		else
		{
			g_value_set_int( value, _self->seq[ _self->index ]);
		}
		break;
	case PROP_PLAYLIST_PTIME:
		g_value_set_uint( value, _self->ptime );
		break;
	case PROP_PLAYLIST_ERROR_COUNT:
		g_value_set_uint( value, _self->error_count );
		break;
	case PROP_PLAYLIST_SEQ:
		{
			GVariant * _seq;
			GVariantBuilder * _builder	=	g_variant_builder_new( G_VARIANT_TYPE( "au" ));
			int i, _count;
			_count	=	_self->array->len;
			for( i = 0; i < _count; i++)
			{
				g_variant_builder_add( _builder, "u", _self->seq[i]);
			}
			_seq	=	g_variant_builder_end( _builder);

			g_value_set_variant( value, _seq);
			
			g_variant_builder_unref( _builder );
		}
		break;

	case PROP_PLAYLIST_DEV:
		g_value_set_pointer( value, _self->dev );
		break;

	default:
		break;
	}
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_property
 *  Description:
 * =====================================================================================
 */
static void _set_property( GObject * object, guint property_id, const GValue * value,
		GParamSpec * spec)
{
	MHPlaylist * _self	=	MH_PLAYLIST( object );

	switch( property_id )
	{
	case PROP_PLAYLIST_INDEX:
		_self->index	=	g_value_get_int( value );
		break;
	case PROP_PLAYLIST_PTIME:
		_self->ptime	=	g_value_get_uint( value );
		break;
	case PROP_PLAYLIST_SHUFFLE:
		_self->shuffle	=	g_value_get_uint( value );
		break;
	case PROP_PLAYLIST_REPEAT:
		_self->repeat	=	g_value_get_uint( value );
		break;
	case PROP_PLAYLIST_SEQ:
		{
			GVariant * _var, * _var_s;
			guint _val;
			guint _i = 0;
			_var	=	g_value_get_variant( value );

			GVariantIter * _it;

			g_variant_get( _var, "v", &_var_s);
			g_variant_get(_var_s, "au", &_it);

			while( g_variant_iter_loop( _it, "u", &_val ))
			{
				_self->seq[_i]	=	_val;
				g_message("seq:%d", _self->seq[_i]);
				_i ++;
			}
			g_variant_unref( _var_s );
			g_variant_unref( _var );
			g_variant_iter_free( _it );
		}
		break;
	default:
		break;
	}
}       /*   -----  end of static function _set_property  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispose
 *  Description:
 * =====================================================================================
 */
static void _dispose( GObject * object )
{
	MHPlaylist * _self	=	MH_PLAYLIST( object );

//	g_object_unref( _self->dev );
	g_array_free( _self->array, TRUE );
	g_free( _self->seq );

	G_OBJECT_CLASS( mh_playlist_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _finalize
 *  Description:
 * =====================================================================================
 */
static void _finalize( GObject * object )
{
	MHPlaylist * _self	=	MH_PLAYLIST( object );
	MHPlaylistPrivate * _priv	=	mh_playlist_get_instance_private( _self );

	G_OBJECT_CLASS( mh_playlist_parent_class )->finalize( object );
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  array_clear_func
 *  Description:  
 * =====================================================================================
 */
static void array_clear_func( gpointer data)
{
	MHItemData * _data	=	*(MHItemData **)data;
	if( _data != NULL)
	{
		if( _data->uri !=	NULL)
		{
		
			g_free(_data->uri );
		}
		if( _data->name !=	NULL)
		{
		
			g_free( _data->name );
		}
		if( _data->metadata.music.title !=	NULL)
		{
			g_free( _data->metadata.music.title );
		}
		if( _data->metadata.music.artist	!=	NULL)
		{
			g_free( _data->metadata.music.artist );
		}
		if( _data->metadata.music.album	!=	NULL)
		{
			g_free( _data->metadata.music.album );
		}
		if( _data->metadata.music.genre	!=	NULL)
		{
			g_free( _data->metadata.music.genre );
		}
		if( _data->metadata.music.composer !=	NULL)
		{
			g_free( _data->metadata.music.composer );
		}
		g_slice_free( MHItemData, _data );
	}
}		/* -----  end of static function array_clear_func  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_init
 *  Description:
 * =====================================================================================
 */
static void mh_playlist_init( MHPlaylist * self )
{
	MHPlaylistPrivate * _priv	=	mh_playlist_get_instance_private( self );
	g_message("%s self = %p",__func__,self);
	self->array	=	g_array_new( FALSE, FALSE, sizeof( MHItemData * ));
	g_array_set_clear_func( self->array, array_clear_func);
	self->seq	=	NULL;
	self->shuffle	=	MH_PB_SHUFFLE_OFF;
	self->repeat	=	MH_PB_REPEAT_MODE_ALL;
	self->index	=	0;
	self->ptime	=	0;
	self->error_count	=	0;
	self->tag_id	=	0;
}       /* -----  end of static function mh_playlist_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_playlist_class_init( MHPlaylistClass * klass )
{
	GObjectClass * _parentClass	=	G_OBJECT_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	_dispose;
	_gobjectClass->finalize	=	_finalize;
	_gobjectClass->get_property	=	_get_property;
	_gobjectClass->set_property	=	_set_property;

	/* assemble ios of mh_playlist class */

	/* assemble methods of mh_playlist class */
	klass->insert	=	_insert;
	klass->remove	=	_remove;
	klass->sort	=	_sort;
	klass->append	=	_append;
	klass->append_playlist	=	_append_playlist;
	klass->foreach	=	_foreach;

	playlistProperties[ PROP_PLAYLIST_COUNT ]	=	
		g_param_spec_uint( "count", "MHPlaylist property", "Count of the playlist",
				0, G_MAXUINT, 0, G_PARAM_READABLE );
	playlistProperties[ PROP_PLAYLIST_SHUFFLE ]	=	
		g_param_spec_uint( "shuffle", "MHPlaylist property", "Shuffle mode of the playlist",
				0, G_MAXUINT, 0, G_PARAM_READWRITE );
	playlistProperties[ PROP_PLAYLIST_REPEAT ]	=	
		g_param_spec_uint( "repeat", "MHPlaylist property", "Repeat mode of the playlist",
				0, G_MAXUINT, 0, G_PARAM_READWRITE );
	playlistProperties[ PROP_PLAYLIST_INDEX ]	=	
		g_param_spec_int( "index", "MHPlaylist property", "Index of the playing item in the playlist",
				G_MININT, G_MAXINT, 0, G_PARAM_READWRITE );
	playlistProperties[ PROP_PLAYLIST_PTIME ]	=	
		g_param_spec_uint( "ptime", "MHPlaylist property", "Ptime of the playing item in the playlist",
				0, G_MAXUINT, 0, G_PARAM_READWRITE );
	playlistProperties[ PROP_PLAYLIST_ERROR_COUNT ]	=	
		g_param_spec_uint( "error_count", "MHPlaylist property", "Error count of the playlist",
				0, G_MAXUINT, 0, G_PARAM_READABLE );

	playlistProperties[ PROP_PLAYLIST_SEQ ]	=	
		g_param_spec_variant("seq", "MHPlaylist property", "The seq of the playlist",
			G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);	

	playlistProperties[ PROP_PLAYLIST_DEV ]	=	
		g_param_spec_pointer("dev", "MHPlaylist property", "The dev of the playlist",
		 G_PARAM_READABLE);	
	g_object_class_install_properties( _gobjectClass, N_PROPERTIES, playlistProperties );
	/* Ios */
	/* Signals */
}       /* -----  end of static function mh_playlist_class_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_insert
 *  Description:
 * =====================================================================================
 */
MHResult mh_playlist_insert( MHPlaylist * self, uint32_t index, MHItem ** items, uint32_t count )
{
	g_message("%s index:%d, count=%d", __func__, index, count);
	g_return_val_if_fail( MH_IS_PLAYLIST( self ), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;
	
	if( MH_PLAYLIST_GET_CLASS( self )->insert != NULL )
	{
		MH_PLAYLIST_GET_CLASS( self )->insert( self, index, items, count );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlaylistClass::insert()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}
	return _res;
}		/* -----  end of function mh_playlist_insert  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_remove
 *  Description:
 * =====================================================================================
 */
MHResult mh_playlist_remove( MHPlaylist * self, uint32_t index, uint32_t length )
{
	g_message("%s index:%d, length:%d", __func__, index, length);
	g_return_val_if_fail( MH_IS_PLAYLIST( self ), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;
	
	if( MH_PLAYLIST_GET_CLASS( self )->remove != NULL )
	{
		_res	=	MH_PLAYLIST_GET_CLASS( self )->remove( self, index, length );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlaylistClass::remove()'",
				G_OBJECT_TYPE_NAME( self ));

		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}
	return _res;
}		/* -----  end of function mh_playlist_remove  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_sort
 *  Description:
 * =====================================================================================
 */
MHResult mh_playlist_sort( MHPlaylist * self, MHSortType sort_type, MHItemOrderType order_type)
{
	g_message("%s sort_type:%d, order_type:%d", __func__, sort_type, order_type);
	g_return_val_if_fail( MH_IS_PLAYLIST( self ), MH_INVALID_PARAM);
	
	MHResult _res	=	MH_OK;

	if( MH_PLAYLIST_GET_CLASS( self )->sort != NULL )
	{
		MH_PLAYLIST_GET_CLASS( self )->sort( self, sort_type, order_type );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlaylistClass::sort()'",
				G_OBJECT_TYPE_NAME( self ));
		
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}
	return _res;

}		/* -----  end of function mh_playlist_sort  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_restore
 *  Description:
 * =====================================================================================
 */
MHPlaylist * mh_playlist_restore( char * name )
{
	return NULL;
}		/* -----  end of function mh_playlist_restore  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_save
 *  Description:
 * =====================================================================================
 */
bool mh_playlist_save( MHPlaylist * self, char * name )
{
	return false;
}		/* -----  end of function mh_playlist_save  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_get_names
 *  Description:
 * =====================================================================================
 */
char ** mh_playlist_get_names( MHDev * dev )
{
	return NULL;
}		/* -----  end of function mh_playlist_get_names  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_append
 *  Description:  
 * =====================================================================================
 */
MHResult mh_playlist_append( MHPlaylist * self, MHItem ** items, uint32_t count )
{
	g_return_val_if_fail( MH_IS_PLAYLIST( self ), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;
	

	if( MH_PLAYLIST_GET_CLASS( self )->append != NULL )
	{
		MH_PLAYLIST_GET_CLASS( self )->append( self, items, count );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlaylistClass::append()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}
	return _res;
}		/* -----  end of function mh_playlist_append  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_append_playlist
 *  Description:  
 * =====================================================================================
 */
MHResult mh_playlist_append_playlist( MHPlaylist * self, MHPlaylist * _another)
{
	g_return_val_if_fail( MH_IS_PLAYLIST( self ), MH_INVALID_PARAM);
	g_return_val_if_fail( MH_IS_PLAYLIST( _another ), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;
	

	if( MH_PLAYLIST_GET_CLASS( self )->append_playlist != NULL )
	{
		MH_PLAYLIST_GET_CLASS( self )->append_playlist( self, _another );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlaylistClass::append_playlist()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}
	return _res;
}		/* -----  end of function mh_playlist_append_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_playlist_foreach
 *  Description:  
 * =====================================================================================
 */
MHResult mh_playlist_foreach( MHPlaylist * self, int32_t start, int32_t count, MHFunc func, void * user_data )
{
	g_message("%s start:%d, count:%d", __func__, start, count);
	g_return_val_if_fail( MH_IS_PLAYLIST( self ) && (start >= 0), MH_INVALID_PARAM );

	MHResult _res	=	MH_OK;

	if( MH_PLAYLIST_GET_CLASS( self )->foreach != NULL )
	{
		MH_PLAYLIST_GET_CLASS( self )->foreach( self, start, count, func, user_data );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlaylistClass::foreach()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}
	return _res;
}		/* -----  end of function mh_playlist_foreach  ----- */
