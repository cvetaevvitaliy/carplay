/*
 * Generated by plugin-codegen.
 */
#include<stdio.h>
#include <mh_col.h>
#include <mh_dev.h>
#include <db_create.h>
#include <mh_contents.h>
#include <string.h>
#include <order.h>
typedef struct _MHColPrivate MHColPrivate;

struct _MHColPrivate
{
	MHDev * device;
};

G_DEFINE_TYPE_WITH_PRIVATE( MHCol, mh_col, G_TYPE_OBJECT )

typedef enum _MHColProperty
{
	PROP_0,

	PROP_COL_DEVICE,
//	PROP_COL_COUNT,

	N_PROPERTIES
} MHColProperty;

static GParamSpec * col_properties[ N_PROPERTIES ] = { NULL };

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  foreach
 *  Description:
 * =====================================================================================
 */
//static MHResult _foreach( MHCol * self, MHFunc func, void * user_data)
//{
//	g_message("_foreach is called\n");
//	int _i	=	0;
//	gint64 _node_id;
//	MHItem * _item;
//
//	for( _i ; _i < self->array->len; _i++ )
//	{
//		_node_id = g_array_index( self->array, gint64, _i );
//		_item	=	g_hash_table_lookup( self->dev->itemsHash, &_node_id);
//	
//		if( func( _item, user_data ))
//			break;
//	}
//
//	return 0;
//}      /* -----  end of static function foreach  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  count
 *  Description:
 * =====================================================================================
 */
//static int _get_count( MHCol * self )
//{
//	return  self->array->len;
//}      /* -----  end of static function count  ----- */
static char * change_str_signal_to_double( char * string)
{
	char * _p;
	char * _tmp1;
	char * _tmp2	=	NULL;
	char * _tmp3	=	NULL;
	char * _res	;

	_p	=	g_strrstr( string, "'");
	if( _p !=	NULL)
	{
		_tmp1	=	g_strdup( string);

		while( _p != NULL)
		{
			if( _tmp3	!=	NULL)
			{
				_tmp2	=	g_strdup_printf("'%s%s",_p,_tmp3);

				g_free( _tmp3);
			}
			else

			{
				_tmp2	=	g_strdup_printf("'%s",_p);
			}
			*_p	=	'\0';
			_tmp3	=	_tmp2;
			
			_p	=	g_strrstr( string, "'");

		}
		_res	=	g_strdup_printf("%s%s",string,_tmp2);

		g_free( _tmp2);

		g_free( _tmp1 );

		g_free( string);

	}
	else
	{
		_res	=	string;
	}
	return _res;

}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  filter_type_to_str
 *  Description:  
 * =====================================================================================
 */
static char * filter_type_to_str( MHColFilterType type )
{
	char * _type_name;
	switch ( type )
	{
		case COL_FILTER_TITLE:
			_type_name	=	g_strdup( "title" );
			break;
		case COL_FILTER_ARTIST:
			_type_name	=	g_strdup( "artist" );
			break;
		case COL_FILTER_COMPOSER:
			_type_name	=	g_strdup( "composer" );
			break;
		case COL_FILTER_ALBUM:
			_type_name	=	g_strdup( "album_title,compliation " );
			break;
		case COL_FILTER_TRACK:
			_type_name	=	g_strdup( "track" );
			break;
		case COL_FILTER_GENRE:
			_type_name	=	g_strdup( "genre" );
			break;
		case COL_FILTER_YEAR:
			_type_name	=	g_strdup( "year" );
			break;
		case COL_FILTER_COMPLIATION:
			_type_name  =	g_strdup( "compliation" );
			break;
		case COL_FILTER_NONE:
			_type_name	=	g_strdup( "title" );
			break;
		case COL_FILTER_ALBUM_ARTIST:
			_type_name	=	g_strdup( " album_artist");
			break;
		case COL_FILTER_DURATION:
			_type_name	=	g_strdup("duration");
			break;
		default:
			g_message("type is error\n");
			break;
	}
	return _type_name;
}		/* -----  end of static function filter_type_to_str  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _filter_condition
 *  Description:  
 * =====================================================================================
 */
static char * _filter_condition( char * table_name, MHColFilter * filter, bool fuzzy)
{
	char * _res	=	NULL;

	switch ( filter->type )
	{
		case COL_FILTER_TITLE:
			filter->value	=	change_str_signal_to_double( (char *)filter->value);
			if( fuzzy	==	true)
			{
			_res	=	g_strdup_printf( " and %s.title like '%%%s%%' ", table_name,(char *)filter->value );

			}
			else
			{
				_res	=	g_strdup_printf( " and %s.title = '%s' ", table_name,(char *)filter->value );
			}
			break;
		case COL_FILTER_ARTIST:
			filter->value	=	change_str_signal_to_double( (char *)filter->value);
			if( fuzzy == true)
			{
			_res	=	g_strdup_printf( " and %s.artist like '%%%s%%' ",table_name, (char *)filter->value );
			}
			else
			{

				_res	=	g_strdup_printf( " and %s.artist = '%s' ",table_name, (char *)filter->value );

			}
			break;
		case COL_FILTER_ALBUM_ARTIST:
			filter->value	=	change_str_signal_to_double( (char *)filter->value);
			if( fuzzy	==	true)
			{
			_res	=	g_strdup_printf( " and %s.album_artist like '%%%s%%' ", table_name, (char *)filter->value);
			}
			else
			{

				_res	=	g_strdup_printf( " and %s.album_artist = '%s' ", table_name, (char *)filter->value);
			}
			break;
		case COL_FILTER_COMPOSER:
			filter->value	=	change_str_signal_to_double( (char *)filter->value);
			if( fuzzy	==	true)
			{
			_res	=	g_strdup_printf( " and %s.composer like '%%%s%%' ", table_name, (char *)filter->value );
			}
			else
			{

				_res	=	g_strdup_printf( " and %s.composer = '%s' ", table_name, (char *)filter->value );
			}
			break;
		case COL_FILTER_ALBUM:
			{
				MHAlbumInfo * _info	=	(MHAlbumInfo *)filter->value;
				_info->album_title	=	change_str_signal_to_double((char *)_info->album_title);
				_info->album_artist	=	change_str_signal_to_double((char *)_info->album_artist);
				if( fuzzy	==	true)
				{
					_res	=	g_strdup_printf( " and %s.album_title like '%%%s%%' and %s.album_artist like '%%%s%%' and %s.compliation = %d ",
						table_name, _info->album_title, table_name, _info->album_artist, table_name, _info->album_compliation );
				}
				else
				{
					_res	=	g_strdup_printf( " and %s.album_title = '%s' and %s.album_artist = '%s' and %s.compliation = %d ",
					table_name, _info->album_title, table_name, _info->album_artist, table_name, _info->album_compliation );

				}
			}
			break;
		case COL_FILTER_TRACK:
			_res	=	g_strdup_printf( " and %s.track = %d ", table_name, *(uint32_t *)filter->value );
			break;
		case COL_FILTER_GENRE:

			filter->value	=	change_str_signal_to_double( (char *)filter->value);
			if( fuzzy == true)
			{
			_res	=	g_strdup_printf( " and %s.genre like '%%%s%%' ", table_name, (char *)filter->value );
			}
			else
			{

				_res	=	g_strdup_printf( " and %s.genre = '%s' ", table_name, (char *)filter->value );
			}
			break;
		case COL_FILTER_YEAR:
			_res	=	g_strdup_printf( " and %s.year = %d ", table_name, *(uint32_t *)filter->value );
			break;
		case COL_FILTER_COMPLIATION:
			_res  =	g_strdup_printf( " and %s.compliation = %d ", table_name, *(uint32_t *)filter->value );
			break;
		case COL_FILTER_NONE:
			filter->value	=	change_str_signal_to_double( (char *)filter->value);
			if( fuzzy	==	true)
			{
			_res	=	g_strdup_printf( " and %s.title like '%%%s%%'",table_name, (char *)filter->value );
			}
			else
			{
				_res	=	g_strdup_printf( " and %s.title = '%s'",table_name, (char *)filter->value );
			}
			break;
		case COL_FILTER_NAME:
			filter->value	=	change_str_signal_to_double( (char *)filter->value );
			if( fuzzy	==	true)
			{
			_res	=	g_strdup_printf( " and node.name like '%%%s%%'", (char *)filter->value );
			}
			else
			{
				_res	=	g_strdup_printf( " and node.name = '%s'", (char *)filter->value );
			}
			break;
		case COL_FILTER_DURATION:
			_res	=	g_strdup_printf(" and %s.duration = %d ", table_name, *(uint32_t*)filter->value);
			break;
		default:
			g_message("type is error\n");
			break;
	}
	return _res;

}		/* -----  end of static function _filter_condition  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  item_type_to_str
 *  Description:  
 * =====================================================================================
 */
static char * item_type_to_str( MHItemType type)
{
	char * _type_str;
	switch ( type )
	{
		case MH_ITEM_MUSIC:
			_type_str	=	g_strdup( "music" );
			break;
		case MH_ITEM_MOVIE:
			_type_str	=	g_strdup( "movie" );
			break;
		case MH_ITEM_PICTURE:
			_type_str	=	g_strdup( "picture" );
			break;
		case MH_ITEM_PLAYLIST:
			_type_str	=	g_strdup( "playlist" );
			break;
		default:
			g_message("type is error\n");
			break;
	}
	return _type_str;
}		/* -----  end of static function item_type_to_str  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  filter
 *  Description:
 * =====================================================================================
 */
//static MHResult _set_filter( MHCol * self, MHItemType item_type,MHMediaType media_type, MHColFilterType filter_type, const char * value, va_list ap )
//{
//	void * _param;
//	char * _filter_str;
//	char * _item_str;
//
//	char * _sql;
//	char * _sql_tmp1;
//	char * _sql_tmp2;
//	char * _value;
//	char * _serial;
//	MHContents * _content;
//	MHStmt * _statement;
//
//	MHColFilterType _filter_type;
//	char * _filter_value;
//	gint64 node_id;	
//
//	_filter_str	=	filter_type_to_str( filter_type );
//	_item_str	=	item_type_to_str( item_type );
//	_value	=	g_strdup(value);
//	_serial	=	g_strdup(self->dev->serial);
//
//	_serial	=	change_str_signal_to_double( _serial);
//
//	_sql_tmp1	=	g_strdup_printf("select %s.node_id from %s left join node on node.node_id = %s.node_id \
//left join devices on devices.device_id = node.device_id where devices.serial_number = '%s'",
//	_item_str, _item_str, _item_str, _serial);
//
//	g_free( _serial );
//
//	if( item_type	==	MH_ITEM_MUSIC)
//	{
//		_sql_tmp2	=	g_strdup_printf("%s and %s.media_type=%d", _sql_tmp1, _item_str, media_type);
//		
//		g_free( _sql_tmp1);
//
//		_sql_tmp1	=	_sql_tmp2;
//	}
//
//	if( filter_type != COL_FILTER_NONE )
//	{
//		_value 	=	change_str_signal_to_double(_value);
//		if(g_strcmp0( _value,"")	==	0)
//		{
//			_sql_tmp2	=	g_strdup_printf("%s and %s like '' ",_sql_tmp1, _filter_str);
//
//		}
//		else
//		{
//			_sql_tmp2	=	g_strdup_printf("%s and %s like '%%%s%%' ",_sql_tmp1, _filter_str, _value);
//		}
//
//		g_free( _sql_tmp1);
//
//		g_free( _value );
//
//		_sql_tmp1	=	_sql_tmp2;
//	}
//
//	g_free( _item_str );
//
//	g_free( _filter_str );
//
//	while((_param	=	va_arg(ap, char *)) != NULL)
//	{
//		_filter_type	=	*(MHColFilterType *)_param;
//
//		_filter_str		=	filter_type_to_str( _filter_type );
//
//		if(( _param	=	va_arg(ap, char *)) != NULL)
//		{
//			_filter_value	=	g_strdup( _param );
//			if( g_strcmp0( _filter_value,"")	==	0)
//			{
//				_sql_tmp2	=	g_strdup_printf("%s and %s like '' ",_sql_tmp1, _filter_str );
//
//			}
//			else
//			{
//				_filter_value 	=	change_str_signal_to_double(_filter_value);
//
//				_sql_tmp2	=	g_strdup_printf("%s and %s like '%%%s%%' ",_sql_tmp1, _filter_str, _filter_value );
//			}
//
//			g_free(_sql_tmp1);
//
//			g_free( _filter_value);
//
//			_sql_tmp1	=	_sql_tmp2;
//		}
//
//	}
//	_sql	=	g_strdup_printf("%s;",_sql_tmp1);
//
//	g_free( _sql_tmp1 );
//
//	_content	=	mh_contents_instance();
//
//	_statement	=	mh_contents_prepare( _content, _sql);
//
//	while(mh_contents_step( _content, _statement,&node_id, NULL) == MH_CONTENTS_STEP_CONTINUE)
//	{
//		g_array_append_val( self->array, node_id);
//	}
//
//	mh_contents_release( _content, _statement);	
//
//	
//	return 0;
//}      /* -----  end of static function filter  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_filter
 *  Description:  
 * =====================================================================================
 */
static MHResult _add_filter(MHCol * col, MHColFilterType type,  va_list ap )
{
	MHColFilter *_filter;
	
	while( type != 0)
	{
		_filter	=	(MHColFilter *)g_malloc0( sizeof( MHColFilter ));

		_filter->type	=	type;
		if( type	==	COL_FILTER_ALBUM)
		{
			MHAlbumInfo * _param;

			_param	=	va_arg( ap, MHAlbumInfo *);

			MHAlbumInfo * _albumInfo 	=	(MHAlbumInfo *)g_malloc0(sizeof(MHAlbumInfo));
			_albumInfo->album_title	=	g_strdup( _param->album_title );
			_albumInfo->album_artist	=	g_strdup( _param->album_artist );
			_albumInfo->album_compliation	=	_param->album_compliation;

			_filter->value	=	_albumInfo;

		}
		else if( type	==	COL_FILTER_COMPLIATION)
		{
			uint32_t _param;

			_param	=	va_arg( ap, uint32_t );

			uint32_t * _album_compliation = (uint32_t *)g_malloc0( sizeof (uint32_t ));

			*_album_compliation	=	_param ;

			_filter->value	=	_album_compliation;


		}
		else if( type	==	COL_FILTER_DURATION)
		{
			uint32_t _param;

			_param	=	va_arg( ap, uint32_t );

			uint32_t * _duration	=	(uint32_t *) g_malloc0( sizeof( uint32_t ));

			* _duration	=	_param;

			_filter->value	=	_duration;
		}
		else
		{
			char * _param;

			_param	=	va_arg(ap, char *);

			_filter->value	=	g_strdup( _param );

		}

		col->list	=	g_list_append( col->list, _filter);

		type	=	va_arg( ap, uint32_t);


	}
	return MH_OK;
}		/* -----  end of static function _add_filter  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  list_free
 *  Description:  
 * =====================================================================================
 */
static void list_free( gpointer data)
{
	MHColFilter * _filter	=	(MHColFilter *)data;
	if( _filter->type == COL_FILTER_ALBUM)
	{
		MHAlbumInfo * _info	=	(MHAlbumInfo *)( _filter->value );
		g_free( _info->album_title);
		g_free( _info->album_artist );
	}
	g_free( _filter->value );

	g_free( _filter );
}		/* -----  end of static function list_free  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _filter_clear
 *  Description:  
 * =====================================================================================
 */
static MHResult _filter_clear( MHCol * col)
{
	g_list_free_full(col->list, list_free);
	col->list	=	NULL;
	return MH_OK;
}		/* -----  end of static function _filter_clear  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_retrieve_key
 *  Description:  
 * =====================================================================================
 */
static MHResult _set_retrieve_key( MHCol * col, MHColFilterType type )
{
	col->retrieve_key	=	type;

	return MH_OK; 
}		/* -----  end of static function _set_retrieve_key  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_order_type
 *  Description:  
 * =====================================================================================
 */
static MHResult _set_order_type( MHCol * col, MHItemOrderType type)
{
	col->order	=	type;

	return MH_OK; 
}		/* -----  end of static function _set_order_type  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _retrieve_data
 *  Description:  
 * =====================================================================================
 */
static char ** _retrieve_data(MHCol * col, MHItemType item_type,MHMediaType media_type,int * count, bool fuzzy)
{
	MHContents * _content;
	int _err;
	MHStmt * _statement;
	char ** _res;
	int _count = 0, _alloc = 1;

	char * _sql;
	char * _sql_tmp1;
	char * _sql_tmp2;
	char * _serial;
	char * _item_str;
	char * _retrieve_str;
	char * _filter_str;
	char * _condition	=	NULL;
	MHColFilter * _filter;
	GList * _list;
	_item_str	=	item_type_to_str( item_type);
	_retrieve_str	=	filter_type_to_str( col->retrieve_key );
	
	_serial	=	g_strdup(col->dev->serial);

	_serial	=	change_str_signal_to_double( _serial);

	if( (_list	= g_list_first(col->list ))!=	NULL)
	{
		_filter	=	(MHColFilter *)_list->data;

		_condition	=	_filter_condition( _item_str, _filter, fuzzy);

		while( (_list 	=	g_list_next( _list )) != NULL)
		{
			_filter	=	(MHColFilter *)_list->data;

			_sql_tmp1	=	_filter_condition( _item_str, _filter, fuzzy);
			
			_sql_tmp2	=	g_strdup_printf("%s %s", _condition, _sql_tmp1);

			g_free( _condition );
			g_free( _sql_tmp1 );

			_condition	=	_sql_tmp2;
		}
	}
	_sql_tmp1	=	g_strdup_printf("select %s from %s left join node on node.node_id = %s.node_id \
left join devices on devices.device_id = node.device_id where devices.serial_number = '%s' %s",
	_retrieve_str, _item_str, _item_str, _serial, _condition ? _condition:"");

	g_free( _serial );
	
	if( _condition != 	NULL)
	{
		g_free( _condition );
	}
	if( item_type	==	MH_ITEM_MUSIC)
	{
		_sql_tmp2	=	g_strdup_printf("%s and %s.media_type=%d", _sql_tmp1, _item_str, media_type);

		g_free( _sql_tmp1);

		_sql_tmp1	=	_sql_tmp2;
	}

	if( col->retrieve_key != COL_FILTER_NONE )
	{
		_sql_tmp2	=	g_strdup_printf("%s group by %s",_sql_tmp1, _retrieve_str);

		g_free( _sql_tmp1);

		_sql_tmp1	=	_sql_tmp2;
	}
	_sql	=	g_strdup_printf("%s;",_sql_tmp1);

	g_message("_retrieve_data:%s", _sql);
	g_free( _item_str );
	g_free( _sql_tmp1);
	g_free( _retrieve_str );

	_content	= mh_contents_instance();

	_statement	=	mh_contents_prepare(_content, _sql);

	_res	= ( char ** )g_malloc0( _alloc * sizeof( char * ) );

	while(mh_contents_step( _content, _statement,&_res[_count], NULL) == MH_CONTENTS_STEP_CONTINUE)
	{
		_count++;

		if( _alloc <= _count )
		{
			_alloc	=	_alloc << 1;

			_res	=	g_realloc( _res, _alloc * sizeof( char *));

			memset( _res + _count, 0, (_alloc - _count ) * sizeof( char *));
		}

	}

	mh_contents_release( _content, _statement);	

	g_free( _sql );

	*count = _count;

	if( col->order	!=	MH_ITEM_ORDER_BY_DEFAULT )
	{
		int _i	=	0;
		GArray * _array	=	g_array_new( FALSE, FALSE, sizeof( char *));

		_array	=	g_array_append_vals(_array, _res, _count);

		switch( col->order )
		{
			case MH_ITEM_ORDER_BY_ALPHABET:
				g_array_sort( _array, string_orderByAlphabet);
				break;
			case MH_ITEM_ORDER_BY_PINYIN:
				g_array_sort( _array, string_orderByPinyin);
				break;
			case MH_ITEM_ORDER_BY_ALPHABET_FOR_NAGIVI:
				g_array_sort( _array, string_orderByAlphabetForNagivi);
				break;
			case MH_ITEM_ORDER_BY_ALPHABET_FOR_NAGIVI_JP:
				g_array_sort( _array, string_orderByAlphabetForNagiviJp);
				break;
		}
		
		for(_i = 0; _i < _count; _i++)
		{
			_res[ _i ]=	g_array_index( _array, char *, _i);
		}
		g_array_free( _array, FALSE);
	}

	return _res;
}		/* -----  end of static function _retrieve_data  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _create_playlist
 *  Description:  
 * =====================================================================================
 */
static MHPlaylist * _create_playlist( MHCol * self, MHItemType item_type,MHMediaType media_type, bool fuzzy )
{
	void * _param;
	char * _filter_str;
	char * _item_str;

	char * _sql;
	char * _sql_tmp1;
	char * _sql_tmp2;
	char * _value;
	char * _serial;
	MHContents * _content;
	MHStmt * _statement;

	MHColFilterType _filter_type;
	gint64 _node_id;	
	MHItem * _item;
	GList * _list;
	MHColFilter * _filter;
	char * _condition = NULL;
	MHPlaylist * _playlist;
	_playlist	=	g_object_new( MH_TYPE_PLAYLIST, NULL);

	_playlist->dev	=	self->dev;


	_item_str	=	item_type_to_str( item_type );

	_serial	=	g_strdup(self->dev->serial);

	_serial	=	change_str_signal_to_double( _serial);
	if( (_list	= g_list_first(self->list ))!=	NULL)
	{
		_filter	=	(MHColFilter *)_list->data;

		_condition	=	_filter_condition( _item_str, _filter, fuzzy);

		while( (_list 	=	g_list_next( _list )) != NULL)
		{
			char * _tmp1;
			char * _tmp2;
			_filter	=	(MHColFilter *)_list->data;

			_tmp1	=	_filter_condition( _item_str, _filter, fuzzy);
			
			_tmp2	=	g_strdup_printf("%s %s", _condition, _tmp1);

			g_free( _condition );
			g_free( _tmp1 );

			_condition	=	_tmp2;
		

		}
	}

	_sql_tmp1	=	g_strdup_printf("select node.node_id from node left join %s on %s.node_id = node.node_id \
left join devices on devices.device_id = node.device_id where devices.serial_number = '%s' and node.type = %d %s",
	 _item_str, _item_str, _serial, item_type, _condition ? _condition:"");

	g_free( _serial );
	if( _condition != NULL)
	{
		g_free( _condition );
	}
	if( item_type	==	MH_ITEM_MUSIC && media_type != MH_MEDIA_NONE )
	{
		_sql_tmp2	=	g_strdup_printf("%s and %s.media_type=%d", _sql_tmp1, _item_str, media_type);
		
		g_free( _sql_tmp1);

		_sql_tmp1	=	_sql_tmp2;
	}

	_sql	=	g_strdup_printf("%s;",_sql_tmp1);

	g_message("_create_playlist:%s\n",_sql);

	g_free( _sql_tmp1 );

	_content	=	mh_contents_instance();

	_statement	=	mh_contents_prepare( _content, _sql);

	while(mh_contents_step( _content, _statement,&_node_id, NULL) == MH_CONTENTS_STEP_CONTINUE)
	{
		_item	=	g_hash_table_lookup(self->dev->itemsHash, &_node_id);
		
		if( _item	==	NULL)
		{
			g_message("%lld is not on tree\n", ( long long int)_node_id);
		}
		else
		{
			mh_playlist_append( _playlist, &_item, 1 ); 
		}

	}

	mh_contents_release( _content, _statement);	
	g_free( _item_str );
	return _playlist;
}		/* -----  end of static function _create_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _retrieve_album
 *  Description:  
 * =====================================================================================
 */
static MHAlbumInfo * _retrieve_album( MHCol * self, MHItemType item_type, MHMediaType media_type, int * count, bool fuzzy)
{
	if( item_type	!=	MH_ITEM_MUSIC)
	{
		g_message("not support");
		return NULL;
	}
	MHAlbumInfo * _res;
	int _alloc	=	1;
	int _count	=	0;
	char * _sql;
	char * _item_str;
	char * _serial;
	char * _condition	=	NULL;	
	char * _sql_tmp1	=	NULL;
	char * _sql_tmp2;
	GList * _list;
	MHColFilter * _filter;
	MHContents * _content;
	MHStmt * _statement;
	guint64 _compliation;

	_serial	=	g_strdup(self->dev->serial);

	_serial	=	change_str_signal_to_double( _serial);


	_item_str	=	item_type_to_str( item_type );

	if( (_list	= g_list_first(self->list ))!=	NULL)
	{
		_filter	=	(MHColFilter *)_list->data;

		_condition	=	_filter_condition( _item_str,_filter ,fuzzy);
		
		while( (_list 	=	g_list_next( _list )) != NULL)
		{
			_filter	=	(MHColFilter *)_list->data;

			_sql_tmp1	=	_filter_condition( _item_str,_filter,fuzzy );
			
			_sql_tmp2	=	g_strdup_printf("%s %s", _condition, _sql_tmp1 ? _sql_tmp1 : "");	

			g_free( _sql_tmp1);
			g_free( _condition);

			_condition	=	_sql_tmp2;
		}
	}

	_sql	=	g_strdup_printf("select album_title, album_artist, compliation from %s \
left join node on node.node_id = %s.node_id left join devices on devices.device_id	=	node.device_id \
where devices.serial_number	= '%s' and %s.media_type = %d %s group by album_title,album_artist, compliation",
	_item_str, _item_str, _serial, _item_str, media_type, _condition? _condition:"" );
	g_message("_retrieve_album:%s\n",_sql);	
	g_free( _item_str );
	g_free( _serial );

	_content =	mh_contents_instance();

	_statement	=	mh_contents_prepare( _content, _sql);
	
	_res	=	(MHAlbumInfo *)g_malloc0( _alloc * sizeof( MHAlbumInfo ));


	while( mh_contents_step( _content, _statement, &(_res[_count].album_title),
			&(_res[_count].album_artist), &(_compliation), NULL)
			== MH_CONTENTS_STEP_CONTINUE)
	{
		_res[_count].album_compliation = (bool)_compliation;

		_count ++;

		if( _alloc <= _count)
		{
			_alloc = _alloc << 1;
			_res	=	g_realloc( _res, _alloc * sizeof( MHAlbumInfo ));
			memset( _res + _count, 0, (_alloc - _count) * sizeof( MHAlbumInfo ));
		}
		
	}
	*count = _count;
	mh_contents_release( _content, _statement );

	g_free( _sql );
	if( self->order	!=	MH_ITEM_ORDER_BY_DEFAULT )
	{
		int _i	=	0;
		GArray * _array	=	g_array_new( FALSE, FALSE, sizeof( MHAlbumInfo ));

		_array	=	g_array_append_vals(_array, _res, _count);

		switch( self->order )
		{
			case MH_ITEM_ORDER_BY_ALPHABET:
				g_array_sort( _array, album_orderByAlphabet);
				break;
			case MH_ITEM_ORDER_BY_PINYIN:
				g_array_sort( _array, album_orderByPinyin);
				break;
			case MH_ITEM_ORDER_BY_ALPHABET_FOR_NAGIVI:
				g_array_sort( _array, album_orderByAlphabetForNagivi);				
				break;
			case MH_ITEM_ORDER_BY_ALPHABET_FOR_NAGIVI_JP:
				g_array_sort( _array, album_orderByAlphabetForNagiviJp);				
				break;
		}
		
		for(_i = 0; _i < _count; _i++)
		{
			_res[ _i ]=	g_array_index( _array, MHAlbumInfo, _i);
		}
		g_array_free( _array, FALSE);
	}

	return _res;
}		/* -----  end of static function _retrieve_album  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_dispose
 *  Description:
 * =====================================================================================
 */
static void mh_col_dispose( GObject * object )
{
	MHCol * _self	=	MH_COL( object );
//	g_array_free( _self->array, FALSE);
	G_OBJECT_CLASS( mh_col_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_finalize
 *  Description:
 * =====================================================================================
 */
static void mh_col_finalize( GObject * object )
{
	MHCol * _self	=	MH_COL( object );
	MHColPrivate * _priv	=	mh_col_get_instance_private( _self );

	G_OBJECT_CLASS( mh_col_parent_class )->finalize( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_init
 *  Description:
 * =====================================================================================
 */
static void mh_col_init( MHCol * self )
{
	MHColPrivate * _priv	=	mh_col_get_instance_private( self );
	self->list	=	NULL;
//	self->array	=	g_array_new( FALSE, TRUE, sizeof( gint64 ));
}       /* -----  end of static function mh_col_init  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_get_property
 *  Description:  
 * =====================================================================================
 */
static void _get_property( GObject * object, guint property_id, GValue * value,
		GParamSpec * spec)
{
	MHCol * _self	=	MH_COL( object );
	MHColPrivate * _priv	=	mh_col_get_instance_private( _self );

	switch( property_id )
	{
	case PROP_COL_DEVICE:
		g_value_set_pointer( value, _priv->device );
		break;
//	case PROP_COL_COUNT:
//		g_value_set_uint( value, _self->array->len );
//		break;
//
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID( object, property_id, spec );
		break;
	}
}		/* -----  end of static function mh_col_get_property  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_set_property
 *  Description:  
 * =====================================================================================
 */
static void _set_property( GObject * object, guint property_id, const GValue * value,
		GParamSpec * spec)
{
	MHCol * _self	=	MH_COL( object );
	MHColPrivate * _priv	=	mh_col_get_instance_private( _self );

	switch( property_id )
	{
	case PROP_COL_DEVICE:
		_priv->device	=	g_value_get_pointer( value );

		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID( object, property_id, spec );
		break;
	}
}		/* -----  end of static function mh_col_set_property  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_favorite
 *  Description:  
 * =====================================================================================
 */
static MHResult _set_favorite( MHCol * col, MHItemType item_type, bool favorite)
{
	void * _param;
	char * _filter_str;
	char * _item_str;

	char * _sql;
	char * _sql_tmp1;
	char * _sql_tmp2;
	char * _value;
	char * _serial;
	MHContents * _content;
	MHStmt * _statement;

	MHColFilterType _filter_type;
	gint64 _node_id;	
	MHItem * _item;
	GList * _list;
	MHColFilter * _filter;
	char * _condition = NULL;


	_item_str	=	item_type_to_str( item_type );

	_serial	=	g_strdup(col->dev->serial);

	_serial	=	change_str_signal_to_double( _serial);
	if( (_list	= g_list_first(col->list ))!=	NULL)
	{
		_filter	=	(MHColFilter *)_list->data;

		_condition	=	_filter_condition( _item_str, _filter, false);

		while( (_list 	=	g_list_next( _list )) != NULL)
		{
			char * _tmp1;
			char * _tmp2;
			_filter	=	(MHColFilter *)_list->data;

			_tmp1	=	_filter_condition( _item_str, _filter, false);
			
			_tmp2	=	g_strdup_printf("%s %s", _condition, _tmp1);

			g_free( _condition );
			g_free( _tmp1 );

			_condition	=	_tmp2;
		

		}
	}

	_sql_tmp1	=	g_strdup_printf("select node.node_id from node left join %s on %s.node_id = node.node_id \
left join devices on devices.device_id = node.device_id where devices.serial_number = '%s' and node.type = %d %s",
	 _item_str, _item_str, _serial, item_type, _condition ? _condition:"");

	g_free( _serial );
	if( _condition != NULL)
	{
		g_free( _condition );
	}

	_sql	=	g_strdup_printf("%s;",_sql_tmp1);

	g_message("_create_playlist:%s\n",_sql);

	g_free( _sql_tmp1 );

	_content	=	mh_contents_instance();

	_statement	=	mh_contents_prepare( _content, _sql);

	while(mh_contents_step( _content, _statement,&_node_id, NULL) == MH_CONTENTS_STEP_CONTINUE)
	{
		_item	=	g_hash_table_lookup(col->dev->itemsHash, &_node_id);
		
		if( _item	==	NULL)
		{
			g_message("%lld is not on tree\n", ( long long int)_node_id);
		}
		else
		{
			g_message("_item-->path:%s, name:%s is favorite", _item->uri, _item->name);
			_item->favorite	=	favorite;
		g_message("_item-->path:%s, name:%s is favorite _item->favorite:%d", _item->uri, _item->name, _item->favorite);
		}

	}

	mh_contents_release( _content, _statement);	
	g_free( _item_str );

	return 0;
}		/* -----  end of static function _set_favorite  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_col_class_init( MHColClass * klass )
{
	GObjectClass * _parentClass	=	G_OBJECT_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	mh_col_dispose;
	_gobjectClass->finalize	=	mh_col_finalize;
	_gobjectClass->set_property	=	_set_property;
	_gobjectClass->get_property	=	_get_property;
	col_properties[ PROP_COL_DEVICE ]	=	
		g_param_spec_pointer( "device", "MHCol property", "Set col's device",
				G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE );

//	col_properties[ PROP_COL_COUNT ]	=	
//		g_param_spec_uint ("count", "MHCol property", "get col's count",
//				0, G_MAXUINT, 0, G_PARAM_READABLE );
	
	g_object_class_install_properties( _gobjectClass, N_PROPERTIES, col_properties );

	/* assemble methods of mh_col class */
//	klass->foreach	=	_foreach;
//	klass->get_count	=	_get_count;
//	klass->set_filter	=	_set_filter;
	klass->retrieve_data	=	_retrieve_data;
	klass->create_playlist	=	_create_playlist;
	klass->add_filter	=	_add_filter;
	klass->filter_clear	=	_filter_clear;
	klass->set_retrieve_key	=	_set_retrieve_key;
	klass->set_order_type	=	_set_order_type;
	klass->retrieve_album	=	_retrieve_album;
	klass->set_favorite		=	_set_favorite;
	/* Signals */
}       /* -----  end of static function mh_col_class_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_foreach
 *  Description:
 * =====================================================================================
 */
//MHResult mh_col_foreach( MHCol * self , MHFunc func, void * user_data )
//{
//	MHResult _result	=	MH_INVALID_PARAM;
//
//	g_return_val_if_fail(MH_IS_COL(self), MH_INVALID_PARAM);
//
//	if(MH_COL_GET_CLASS(self)->foreach != NULL)
//	{
//		_result	=	MH_COL_GET_CLASS(self)->foreach( self, func, user_data );
//	}
//	else
//	{
//		g_warning ("Class '%s' does not implement the pure virtual function 'MHColClass::foreach()'",
//				G_OBJECT_TYPE_NAME(self));
//	}
//
//	return _result;
//}		/* -----  end of function mh_col_foreach  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_count
 *  Description:
 * =====================================================================================
 */
//int mh_col_get_count( MHCol * self )
//{
//	int _result	=	0;
//	g_return_val_if_fail(MH_IS_COL(self), 0);
//
//	if(MH_COL_GET_CLASS(self)->get_count!= NULL)
//	{
//		_result	=	MH_COL_GET_CLASS(self)->get_count( self );
//	}
//	else
//	{
//		g_warning ("Class '%s' does not implement the pure virtual function 'MHColClass::get_count()'",
//				G_OBJECT_TYPE_NAME(self));
//	}
//
//	return _result;
//
//}		/* -----  end of function mh_col_count  ----- */
//
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_filter
 *  Description:
 * =====================================================================================
 */
//MHResult mh_col_set_filter(  MHCol * self, MHItemType type, MHMediaType media_type, MHColFilterType filter_type, const char * value , ... )
//{
//	MHResult _result	=	MH_OK;
//	g_return_val_if_fail(MH_IS_COL(self), MH_INVALID_PARAM);
//	va_list _ap;
//	
//	va_start( _ap, value);
//
//	if( MH_COL_GET_CLASS( self )->set_filter !=	NULL)
//	{
//		MH_COL_GET_CLASS( self )->set_filter( MH_COL( self ), type, media_type, filter_type, value, _ap);
//
//	}
//	va_end( _ap );  
//	return _result;
//
//}		/* -----  end of function mh_col_filter  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_unref
 *  Description:
 * =====================================================================================
 */
void mh_col_unref(MHCol * self) 
{
	g_object_unref( self );
}		/* -----  end of function mh_col_unref  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_create
 *  Description:  
 * =====================================================================================
 */
MHCol * mh_col_create( MHDev * dev )
{
	MHCol * _col	=	g_object_new( MH_TYPE_COL, NULL);
	_col->dev	=	dev;
	return _col;
}		/* -----  end of function mh_col_create  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_retrieve_data
 *  Description:  
 * =====================================================================================
 */
char **  mh_col_retrieve_data( MHCol * self, MHItemType type, MHMediaType media_type, int * count, bool fuzzy)
{
	g_return_val_if_fail( MH_IS_COL( self ), NULL);
	char **  _res	=	NULL;
	if( MH_COL_GET_CLASS( self )->retrieve_data != NULL )
	{
		_res	=	MH_COL_GET_CLASS( self )->retrieve_data( MH_COL( self ),type, media_type, count, fuzzy);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHColClass::retrieve_data()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _res;

		
}	/* -----  end of function mh_col_retrieve_data  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_create_playlist
 *  Description:  
 * =====================================================================================
 */
MHPlaylist * mh_col_create_playlist( MHCol * self, MHItemType item_type, MHMediaType media_type, bool fuzzy)
{
	g_return_val_if_fail(MH_IS_COL(self), NULL);

	MHPlaylist * _res	=	NULL;



	if( MH_COL_GET_CLASS( self )->create_playlist !=	NULL)
	{
		_res	=	MH_COL_GET_CLASS( self )->create_playlist( MH_COL( self ), item_type, media_type, fuzzy);

	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHColClass::create_playlist()'",
				G_OBJECT_TYPE_NAME( self ));
	}

	return _res;

}		/* -----  end of function mh_col_create_playlist  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_add_filter
 *  Description:  
 * =====================================================================================
 */
MHResult mh_col_add_filter( MHCol * self, MHColFilterType type, ...)
{
	g_return_val_if_fail(MH_IS_COL(self), MH_INVALID_PARAM);
	MHResult _res	=	MH_OK;

	va_list _ap;
	
	va_start( _ap, type);

	if( MH_COL_GET_CLASS( self )->add_filter !=	NULL)
	{
		MH_COL_GET_CLASS( self )->add_filter( MH_COL( self ), type, _ap);

	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHColClass::add_filter()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}
	va_end( _ap );  
	return _res;
}		/* -----  end of function mh_col_add_filter  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_filter_clear
 *  Description:  
 * =====================================================================================
 */
MHResult mh_col_filter_clear( MHCol * self)
{
	g_return_val_if_fail(MH_IS_COL(self), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;

	if( MH_COL_GET_CLASS( self )->filter_clear !=	NULL)
	{
		MH_COL_GET_CLASS( self )->filter_clear( MH_COL( self ));

	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHColClass::filter_clear()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}

	return _res;
}		/* -----  end of function mh_col_filter_clear  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_set_retrieve_key
 *  Description:  
 * =====================================================================================
 */
MHResult mh_col_set_retrieve_key( MHCol * self, MHColFilterType type)
{
	g_return_val_if_fail(MH_IS_COL(self), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;

	if( MH_COL_GET_CLASS( self )->set_retrieve_key !=	NULL)
	{
		MH_COL_GET_CLASS( self )->set_retrieve_key( MH_COL( self ), type);

	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHColClass::set_retrieve_key()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}

	return _res;
}		/* -----  end of function mh_col_set_retrieve_key  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_set_order_type
 *  Description:  
 * =====================================================================================
 */
MHResult mh_col_set_order_type( MHCol * self, MHItemOrderType order)
{
	g_return_val_if_fail(MH_IS_COL(self), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;

	if( MH_COL_GET_CLASS( self )->set_order_type !=	NULL)
	{
		MH_COL_GET_CLASS( self )->set_order_type( MH_COL( self ), order);

	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHColClass::set_order_type()'",
				G_OBJECT_TYPE_NAME( self ));

		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}

	return _res;
}		/* -----  end of function mh_col_set_order_type  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_retrieve_album
 *  Description:  
 * =====================================================================================
 */
MHAlbumInfo * mh_col_retrieve_album( MHCol * col, MHItemType item_type, MHMediaType media_type, int * count, bool fuzzy)
{
	g_return_val_if_fail(MH_IS_COL(col), NULL);
	
	MHAlbumInfo * _res	=	NULL;
	if( MH_COL_GET_CLASS( col )->retrieve_album !=	NULL)
	{
		_res	=	MH_COL_GET_CLASS( col )->retrieve_album( col, item_type, media_type, count, fuzzy);

	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHColClass::retrieve_album()'",
				G_OBJECT_TYPE_NAME( col ));

	}

	return _res;
}		/* -----  end of static function mh_col_retrieve_album  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_col_set_favorite
 *  Description:  
 * =====================================================================================
 */
MHResult mh_col_set_favorite( MHCol * self, MHItemType item_type, bool favorite)
{
	g_return_val_if_fail(MH_IS_COL(self), MH_INVALID_PARAM);

	MHResult _res	=	MH_OK;

	if( MH_COL_GET_CLASS( self )->set_favorite !=	NULL)
	{
		MH_COL_GET_CLASS( self )->set_favorite( MH_COL( self ), item_type, favorite);

	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHColClass::set_favorite()'",
				G_OBJECT_TYPE_NAME( self ));

		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}

	return _res;

}		/* -----  end of function mh_col_set_favorite  ----- */

