/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include <mh_filter.h>
#include <string.h>
#include <mh_misc.h>
static char * music[]={ 
			"mp3",
			"wma",	
			"aac",
			"wav",
			"ogg",
			"mp2"
};
static char * movie[]={
			"mp4",
			"3gp",
			"avi",
			"mkv",
			"mpg",
			"mpeg",
			"wmv",
			"vob",
			"flv",
			"swf",
			"mov",
			"dat"
};
static char * picture[]={
			"jpg",
			"png",
			"bmp",
			"jpeg",
			"jfif",
			"jpe",
			"ioc",
			"gif",
			"tiff",
			"tif"
};

typedef struct _MHFilterPrivate MHFilterPrivate;

struct _MHFilterPrivate
{
	gint dummy;
};

G_DEFINE_TYPE_WITH_PRIVATE( MHFilter, mh_filter, G_TYPE_OBJECT )

enum {
	/* Ios */
	PROP_0,
	/* Signals */

	N_SIGNALS
};

static guint signals[ N_SIGNALS ] = {0};



/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _creat
 *  Description:
 * =====================================================================================
 */
static  MHFilter * _creat( gpointer filter_str )
{
	gpointer _filter	=	NULL;

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _creat  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _match
 *  Description:  
 * =====================================================================================
 */
static bool _match(MHFilter * filter, char * file)
{
	char * _p;
	char * _ext;
	bool _res	=	false;
	if((_p	=	g_strrstr( file,"."))!=NULL)
	{
		_ext	=	g_ascii_strdown(_p + 1, strlen(_p + 1));
		if(g_hash_table_lookup(filter->hash, _ext)!=NULL)
		{
			_res	=	true;
		}
		
	}
	return _res;
}		/* -----  end of static function _match  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_filter_dispose
 *  Description:
 * =====================================================================================
 */
static void mh_filter_dispose( GObject * object )
{
	MHFilter * _self	=	MH_FILTER( object );

	G_OBJECT_CLASS( mh_filter_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_filter_finalize
 *  Description:
 * =====================================================================================
 */
static void mh_filter_finalize( GObject * object )
{
	MHFilter * _self	=	MH_FILTER( object );
	MHFilterPrivate * _priv	=	mh_filter_get_instance_private( _self );

	G_OBJECT_CLASS( mh_filter_parent_class )->finalize( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_filter_init
 *  Description:
 * =====================================================================================
 */
static void mh_filter_init( MHFilter * self )
{
	MHFilterPrivate * _priv	=	mh_filter_get_instance_private( self );
	self->hash	=	NULL;
	self->type	=	0;
}       /* -----  end of static function mh_filter_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_filter_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_filter_class_init( MHFilterClass * klass )
{
	GObjectClass * _parentClass	=	G_OBJECT_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	mh_filter_dispose;
	_gobjectClass->finalize	=	mh_filter_finalize;

	/* assemble ios of mh_filter class */

	/* assemble methods of mh_filter class */
	klass->creat	=	_creat;
	klass->match	=	_match;
	/* Ios */
	/* Signals */
}       /* -----  end of static function mh_filter_class_init  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  filter_to_hash
 *  Description:  
 * =====================================================================================
 */
static GHashTable * filter_to_hash(char * filter)
{
	GHashTable * _res	=	NULL;
	char * _filter = g_strdup(filter);
	char * _p;
	char * _key;
	_res	=	g_hash_table_new( g_str_hash, g_str_equal );
	while(( _p	=	g_strrstr( _filter, ";")) != NULL )
	{
		
		_key	=	g_ascii_strdown( _p + 1, strlen( _p + 1));
		g_hash_table_insert( _res, _key, "");
		* _p	=	'\0';
			
	}
	_key	=	g_ascii_strdown( _filter, strlen(_filter)	);
	g_hash_table_insert( _res, _key, "");

	g_free( _filter );
	return _res;
}		/* -----  end of static function filter_to_hash  ----- */
void Func (gpointer key,gpointer value,gpointer user_data)
{
	g_message("func:%s\n",(char *) key);
}
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_filter_creat
 *  Description:
 * =====================================================================================
 */
MHFilter * mh_filter_create( const char * filter_str)
{
	MHFilter * _filter;
	GHashTable * _hash;
	char * _p;
	char * _key;
	MHItemType _type;
	char * _filter_str = g_strdup(filter_str);

	_filter	=	g_object_new(MH_TYPE_FILTER, NULL);
	_filter->hash	=	g_hash_table_new( g_str_hash, g_str_equal );
	if(strlen(filter_str)	==	0)
	{
		_filter->type	=	FILTER_FOLDER;
		return _filter;
	}
	while(( _p	=	g_strrstr( _filter_str, ";")) != NULL )
	{
	
		_type	=	mh_misc_get_ext_type( _p+1 );
		switch( _type )
		{
			case MH_ITEM_MUSIC :
				_filter->type	=	_filter->type | FILTER_MUSIC;
				break;
			case MH_ITEM_MOVIE :
				_filter->type	=	_filter->type | FILTER_MOVIE;
				break;
			case MH_ITEM_PICTURE :
				_filter->type	=	_filter->type | FILTER_PICTURE;
				break;
			case MH_ITEM_PLAYLIST :
				_filter->type 	=	_filter->type | FILTER_PLAYLIST;
				break;
		}
		_key	=	g_ascii_strdown( _p + 1, strlen( _p + 1));
		g_hash_table_insert( _filter->hash, _key, "");
		* _p	=	'\0';
			
	}
	_type	=	mh_misc_get_ext_type( _filter_str);
	switch( _type )
	{
		case MH_ITEM_MUSIC :
			_filter->type	=	_filter->type | FILTER_MUSIC;
			break;
		case MH_ITEM_MOVIE :
			_filter->type	=	_filter->type | FILTER_MOVIE;
			break;
		case MH_ITEM_PICTURE :
			_filter->type	=	_filter->type | FILTER_PICTURE;
			break;
		case MH_ITEM_PLAYLIST:
			_filter->type	=	_filter->type | FILTER_PLAYLIST;
			break;
	}

	_key	=	g_ascii_strdown( _filter_str, strlen(_filter_str)	);
	g_hash_table_insert( _filter->hash, _key, "");

	g_free( _filter_str );


	//g_hash_table_foreach( _filter->hash,Func,NULL);
	return _filter;
	
}		/* -----  end of function mh_filter_creat  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_misc_hash_del_data
 *  Description:  
 * =====================================================================================
 */
void mh_filter_del_data( MHFilter * filter,MHItemType type)
{
	if(filter==NULL)
	{
		g_warning("%s:filter==NULL\n",__FUNCTION__);
		return;
	}
	int i;
	if( type	==	MH_ITEM_MUSIC)
	{
		for(i=0; i < sizeof( music )/sizeof( char * ); i++)
		{
			if(NULL==g_hash_table_lookup(filter->hash,music[i]))
			{
				g_message("%s not found in hash\n",music[i]);
			}
			if(!g_hash_table_remove( filter->hash, music[i]))
			{
				g_message("g_hash_table_remove fail:%s\n",music[i]);
			}
		}

	}
	else if( type	==	MH_ITEM_MOVIE)
	{
		for(i=0; i < sizeof( movie )/sizeof( char * ); i++)
		{
			g_hash_table_remove( filter->hash, movie[i]);
		}

	}
	else if( type	==	MH_ITEM_PICTURE)
	{
		for(i=0; i < sizeof( picture )/sizeof( char * ); i++)
		{
			g_hash_table_remove( filter->hash, picture[i]);
		}

	}

	return;
}		/* -----  end of function mh_misc_hash_del_data  ----- */
bool mh_filter_match( MHFilter * self, char * file)
{
	g_return_val_if_fail( MH_IS_FILTER( self ), false);
	bool _res	=	false;
	if( MH_FILTER_GET_CLASS( self )->match != NULL )
	{
		_res	=	MH_FILTER_GET_CLASS( self )->match( self, file );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHFilterClass::match()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _res;
}
