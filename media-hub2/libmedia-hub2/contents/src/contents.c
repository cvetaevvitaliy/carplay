/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include <mh_contents.h>
#include "db_create.h"
#include <sqlite3.h>
#include <stdio.h>
#include <mh_folder.h>
#include <mh_item.h>
#include <mh_movie.h>
#include <mh_picture.h>
#include <mh_playlist.h>
#include <mh_api.h>
#include <mh_dev.h>
#include <string.h>
#include <pthread.h>
typedef struct _MHContentsPrivate MHContentsPrivate;

struct _MHContentsPrivate
{
	sqlite3 * db;
};

G_DEFINE_TYPE_WITH_PRIVATE( MHContents, mh_contents, G_TYPE_OBJECT )

static MHContents * contentsObject=NULL;

//test for fast boot start
sem_t db_open_sem;
gboolean usr1_sig_once_flag = TRUE;
sem_t adb_wait_sem;
//test for fast boot end

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _instance
 *  Description:
 * =====================================================================================
 */
//static MHContents * _instance(  )
//{
//	if( contentsObject	==	NULL )
//	{
//		contentsObject	=	g_object_new( MH_TYPE_CONTENTS, NULL );
//	}
//	else
//	{
//		g_message("already new\n");
//	}
//	return contentsObject;
//	//Method default implement.
//}      /* -----  end of static function _instance  ----- */
//

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_device
 *  Description:  
 * =====================================================================================
 */
static gint64 _get_device(MHContents * self, char *  serial_number)
{
	gchar * _sql	=	"select device_id from devices where serial_number = ?";

	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3_stmt * _stmt;
	gint64 _res = -1;
	sqlite3 * _db = _priv->db;


	if( sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL)!= SQLITE_OK)
	{
		g_message("sqlite3_prepare_v2 is error\n");
	}
	sqlite3_bind_text( _stmt, 1, serial_number, -1, NULL );
	if( sqlite3_step( _stmt ) == SQLITE_ROW )
	{
		_res	=	sqlite3_column_int64( _stmt, 0);
	}

	sqlite3_finalize( _stmt );


	return _res;
}		/* -----  end of static function _get_device  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_device
 *  Description:
 * =====================================================================================
 */
static gint64 _add_device( MHContents * self, char *  serial_number )
{
	gchar * _sql	=	"insert into devices values( NULL,?,NULL)";
	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	gint64 _res;
	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

	sqlite3_bind_text( _stmt, 1, serial_number, -1, NULL );

	if( sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));

	}
	_res	=	sqlite3_last_insert_rowid( _db );

	return _res;

}      /* -----  end of static function _add_device  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _update_device_private
 *  Description:  
 * =====================================================================================
 */
static gint64 _update_device_private(MHContents * self, gint64 device_id, gpointer private_data, guint size)
{
	gchar * _sql	=	"update devices set private = ? where device_id =?";
	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

	sqlite3_bind_blob(_stmt, 1, private_data, size, NULL);
	sqlite3_bind_int64( _stmt, 2, device_id);
	if( sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));

	}


	return device_id;
}		/* -----  end of static function _update_device_private  ----- */



/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_id_by_tagId
 *  Description:  
 * =====================================================================================
 */
static gint64 _get_id_by_tagId(MHContents * self, gint64 device_id, gint64 tagId)
{
	gchar * _sql	=	"select node_id from node where device_id = ? and tagId = ?";
	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	int _err;
	gint64 _res = -1;
	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, device_id);
	sqlite3_bind_int64(_stmt, 2, tagId);
	if( sqlite3_step( _stmt ) == SQLITE_ROW )
	{
		_res	=	sqlite3_column_int64( _stmt, 0);
	}


	return _res;

}		/* -----  end of static function _get_id_by_tagId  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _delete_node_by_id
 *  Description:  
 * =====================================================================================
 */
static void _delete_node_by_id( MHContents * self, gint64 * list, uint32_t count)
{
	static sqlite3_stmt * _stmt_music	= NULL;
	static sqlite3_stmt * _stmt_movie	= NULL;
	static sqlite3_stmt * _stmt_picture = NULL;
	static sqlite3_stmt * _stmt_closure = NULL;
	static sqlite3_stmt * _stmt_node	=	NULL;
	int i;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	if( _stmt_music == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db,"delete from music where node_id = ? ; ", -1, &_stmt_music, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}

	}
	if( _stmt_movie == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db, "delete from movie where node_id = ? ; ", -1, &_stmt_movie, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}

	if( _stmt_picture == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db, "delete from picture where node_id = ? ; ", -1, &_stmt_picture, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}

	if( _stmt_closure == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db, "delete from closure where descendant = ? ; ", -1, &_stmt_closure, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}


	if( _stmt_node == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db, "delete from node where node_id = ? ; ", -1, &_stmt_node, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}

	for(i = 0; i < count; i++)
	{
	//	g_message("list[%d]:%lld",i,list[i]);
		sqlite3_reset( _stmt_music );
		sqlite3_reset( _stmt_movie );
		sqlite3_reset( _stmt_picture );
		sqlite3_reset( _stmt_closure );


		sqlite3_bind_int64(_stmt_music, 1, list[i]);
		sqlite3_bind_int64(_stmt_movie, 1, list[i]);
		sqlite3_bind_int64(_stmt_picture, 1, list[i]);
		sqlite3_bind_int64(_stmt_closure, 1, list[i]);

		if( SQLITE_DONE != sqlite3_step( _stmt_music ) )
		{
			g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
		if( SQLITE_DONE != sqlite3_step( _stmt_movie ) )
		{
			g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
		if( SQLITE_DONE != sqlite3_step( _stmt_picture ) )
		{
			g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
		if( SQLITE_DONE != sqlite3_step( _stmt_closure ) )
		{
			g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}
	for(i = 0; i < count; i++)
	{
		sqlite3_reset( _stmt_node );
		sqlite3_bind_int64(_stmt_node, 1, list[i]);
		if( SQLITE_DONE	!= sqlite3_step( _stmt_node )  )
		{
			g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}

	}

}		/* -----  end of static function _delete_node_by_id  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _delete_node_by_device_id
 *  Description:  
 * =====================================================================================
 */
static void _delete_node_by_device_id( MHContents * self, gint64 device_id)
{
	gchar * _sql	=	"select node_id from node where device_id = ?";

	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	int _err;
	gint64 * _list;
	uint32_t _alloc = 1;
	uint32_t _count	= 0;

	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	_list	=	(gint64 *)g_malloc0( _alloc * sizeof( gint64 ));

	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, device_id);
	while( sqlite3_step( _stmt ) == SQLITE_ROW )
	{
		_list[ _count ] = sqlite3_column_int64( _stmt,0);	

		_count++;

		if( _alloc <= _count)
		{
			_alloc	=	_alloc << 1;
			_list	=	g_realloc( _list, _alloc * sizeof( gint64));
			memset( _list + _count, 0, (_alloc - _count ) * sizeof(gint64));
		}
	}
	_delete_node_by_id( self, _list, _count);
	g_free( _list );
}		/* -----  end of static function _delete_node_by_device_id  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _delete_playlist_by_device_id
 *  Description:  
 * =====================================================================================
 */
static void _delete_playlist_by_device_id( MHContents * self, gint64 device_id)
{
	gchar * _sql	=	"delete from playlist where device_id = ?";

	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	int _err;


	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, device_id);
	if( sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_message("%s is failed\n",__func__);
	}

}		/* -----  end of static function _delete_playlist_by_device_id  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_node
 *  Description:
 * =====================================================================================
 */
static gint64 _add_node( MHContents * self,gint64 device_id, MHItem * item )
{
	gchar * _sql	=	"insert into node values( NULL,?,?,?,?,?,?)";
	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	gint64 _res;
	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

	sqlite3_bind_int64( _stmt, 1, device_id );
	sqlite3_bind_text( _stmt, 2, item->name, -1, NULL );
	sqlite3_bind_int( _stmt, 3, item->size );
	sqlite3_bind_int( _stmt, 4, item->type );
	sqlite3_bind_int( _stmt, 5, item->valid);
	sqlite3_bind_int64( _stmt, 6, item->tagId);
	if( sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));

	}
	_res	=	sqlite3_last_insert_rowid( _db );	

	return _res;



	//Method default implement.
}      /* -----  end of static function _add_node  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_closure
 *  Description:
 * =====================================================================================
 */
static void _add_closure( MHContents * self, gint64 descendant, gint64 ancestor, gint64 parent, gint64 device_id)//del db by deviceId
{
	gchar * _sql	=	"insert into closure values(?,?,?,?)";//del db by deviceId

	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;



	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);
		
		if( _err	!=	SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
			
		}
	}

	sqlite3_reset( _stmt );

	//del db by deviceId
	sqlite3_bind_int64( _stmt, 1, device_id );
	sqlite3_bind_int64( _stmt, 2, descendant );
	sqlite3_bind_int64( _stmt, 3, ancestor );
	sqlite3_bind_int64( _stmt, 4, parent );
	
	if( sqlite3_step( _stmt )	!=	SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));

	}

	
}      /* -----  end of static function _add_closure  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_music
 *  Description:
 * =====================================================================================
 */
static void _add_music( MHContents * self, MHMusic * music,  gint64 device_id)
{
	gchar * _sql	=	"insert into music values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";//del db by deviceId //compare by lastchangtime 
	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	int _err;

	if( _stmt == NULL )
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL );

		if( _err != SQLITE_OK )
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, MH_ITEM( music )->uniqueId );
	sqlite3_bind_text( _stmt, 2, (music->title)? music->title : "" , -1, NULL );
	sqlite3_bind_int(_stmt, 3, music->rating);
	sqlite3_bind_int(_stmt, 4, music->duration);
	sqlite3_bind_text( _stmt, 5, (music->album_title )? music->album_title : "", -1, NULL );
	sqlite3_bind_int(_stmt, 6, music->track);
	sqlite3_bind_int(_stmt, 7, music->track_count);
	sqlite3_bind_int(_stmt, 8, music->disc);
	sqlite3_bind_int(_stmt, 9, music->disc_count);
	sqlite3_bind_text( _stmt, 10, (music->artist ) ? music->artist : "", -1, NULL );
	sqlite3_bind_text( _stmt, 11, (music->album_artist ) ? music->album_artist : "", -1, NULL );
	sqlite3_bind_text( _stmt, 12, (music->genre ) ? music->genre : "", -1, NULL );
	sqlite3_bind_text( _stmt, 13, (music->composer ) ? music->composer : "", -1, NULL );
	sqlite3_bind_int(_stmt, 14, music->year);
	sqlite3_bind_int( _stmt, 15, music->mediaType);
	sqlite3_bind_int( _stmt, 16, music->album_compliation);
	sqlite3_bind_int( _stmt, 17, device_id);//del db by deviceId
	sqlite3_bind_int( _stmt, 18, music->last_chgtime);//compare by lastchangtime 

	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));
	}

}      /* -----  end of static function _add_music  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_movie
 *  Description:
 * =====================================================================================
 */
static void _add_movie( MHContents * self, MHMovie * movie, gint64 device_id )
{
	gchar * _sql	=	"insert into movie values(?,?,?,?,?,?,?,?,?,?,?)";//del db by deviceId
	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	int _err;

	if( _stmt == NULL )
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL );

		if( _err != SQLITE_OK )
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, MH_ITEM( movie )->uniqueId );
	sqlite3_bind_text( _stmt, 2, movie->title, -1, NULL );
	sqlite3_bind_int(_stmt, 3, movie->year);
	sqlite3_bind_text( _stmt, 4, movie->director, -1, NULL );
	sqlite3_bind_int(_stmt, 5, movie->duration);
	sqlite3_bind_text( _stmt, 6, movie->genre, -1, NULL );
	sqlite3_bind_int(_stmt, 7, movie->fps);
	sqlite3_bind_int(_stmt, 8,  movie->xres);
	sqlite3_bind_int(_stmt, 9,  movie->yres);
	sqlite3_bind_text( _stmt, 10,  movie->language, -1, NULL );
	sqlite3_bind_int(_stmt, 11, device_id);//del db by deviceId

	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));
	}


}      /* -----  end of static function _add_movie  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_image
 *  Description:
 * =====================================================================================
 */
static void _add_picture( MHContents * self, MHPicture * picture, gint64 device_id )
{
	gchar * _sql	=	"insert into picture values(?,?,?,?,?,?)";//del db by deviceId
	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	int _err;

	if( _stmt == NULL )
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL );

		if( _err != SQLITE_OK )
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, MH_ITEM( picture )->uniqueId );
	sqlite3_bind_text( _stmt, 2, picture->format, -1, NULL );
	sqlite3_bind_int(_stmt, 3, picture->width);
	sqlite3_bind_int(_stmt, 4, picture->height);
	sqlite3_bind_int(_stmt, 5, picture->bpp);
	sqlite3_bind_int(_stmt, 6, device_id);//del db by deviceId

	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));
	}


}      /* -----  end of static function _add_image  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _begin_transaction
 *  Description:
 * =====================================================================================
 */
static void _begin_transaction( MHContents * self )
{
	char _sql[SQL_CMD_MAX]	=	"begin transaction";
	sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	if( sqlite3_prepare_v2( _db, _sql, -1, & _stmt, NULL) != SQLITE_OK)
	{
		g_message("sqlite3_prepare_v2 is error\n");
	}
	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_message("sqlite_step is error\n");
	}
	sqlite3_finalize( _stmt );

}      /* -----  end of static function _begin_transaction  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _commit_transaction
 *  Description:
 * =====================================================================================
 */
static void _commit_transaction( MHContents * self )
{
	char _sql[SQL_CMD_MAX]	=	"commit transaction";
	sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	if( sqlite3_prepare_v2( _db, _sql, -1, & _stmt, NULL) != SQLITE_OK)
	{
		g_message("sqlite3_prepare_v2 is error\n");
	}
	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_message("_commit_transaction\n");
		g_message("sqlite_step is error\n");
	}
	sqlite3_finalize( _stmt );

}      /* -----  end of static function _commit_transaction  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _rollback_transaction
 *  Description:
 * =====================================================================================
 */
static void _rollback_transaction( MHContents * self )
{

	char _sql[SQL_CMD_MAX]	=	"rollback transaction";
	sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	if( sqlite3_prepare_v2( _db, _sql, -1, & _stmt, NULL) != SQLITE_OK)
	{
		g_message("sqlite3_prepare_v2 is error\n");
	}
	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_message("sqlite_step is error\n");
	}
	sqlite3_finalize( _stmt );

}      /* -----  end of static function _rollback_transaction  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_device_private
 *  Description:  
 * =====================================================================================
 */
static gpointer _get_device_private(MHContents * self,  gint64 device_id, int * size)
{
	g_message("%s\n",__FUNCTION__);
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	sqlite3_stmt * _stmt;
    gpointer _res;
	gpointer _data;
	if(_db	==	NULL)
	{
		g_message("db is null\n");
	}
	if( sqlite3_prepare_v2( _db, "select private from devices where device_id = ? ",-1, 
				&_stmt, NULL )!=SQLITE_OK)
	{
		g_message("[%s] [%d]:sqlite3_prepare_v2 is error\n",__FUNCTION__,__LINE__);
	}
	sqlite3_bind_int64( _stmt, 1, device_id);
	if(sqlite3_step( _stmt ) == SQLITE_ROW )
	{
		_data	=(gpointer)	sqlite3_column_blob(_stmt, 0);
		*size	=	sqlite3_column_bytes(_stmt,0);
		_res	=	g_memdup( _data, *size);
		
	}
	else
	{
		_res	=	NULL;
		*size	=	0;
	}
	sqlite3_finalize( _stmt);
	return _res;
}		/* -----  end of static function _get_device_mixer  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _prepare
 *  Description:
 * =====================================================================================
 */
static MHStmt * _prepare( MHContents * self, char * sql )
{
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	MHStmt * _res = NULL;
	sqlite3_stmt * _stmt;


	if(sqlite3_prepare_v2(_db, sql, -1, &(_stmt), NULL) != SQLITE_OK)
	{
		g_message("_sql:%s\n",sql);
		g_message("sqlite3_prepare_v2 is error:%s\n",sqlite3_errmsg( _priv->db));
	}

	_res	=	(MHStmt *) _stmt;
	return _res;
	//Method default implement.
}      /* -----  end of static function _prepare  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _step
 *  Description:
 * =====================================================================================
 */
static gboolean  _step( MHContents * self, MHStmt * statement, va_list ap )
{
	sqlite3_stmt * _stmt	=(sqlite3_stmt *)	statement;
	void * _param;
	int _index = 0;
	gboolean _result	=	TRUE;
//	sqlite3_reset( _stmt);
	if(	sqlite3_step( _stmt ) ==	SQLITE_ROW )
	{
		while(( _param	= va_arg( ap, void *)) !=	NULL)
		{
			switch( sqlite3_column_type( _stmt, _index ))
			{
				case SQLITE_INTEGER:
					*(( int64_t *)_param ) = sqlite3_column_int64( _stmt, _index);
					break;
				case SQLITE_FLOAT:
					*(( double *)_param ) = sqlite3_column_double( _stmt, _index);
					break;
				case SQLITE_TEXT:
					*((gchar **)_param) = g_strdup(sqlite3_column_text(_stmt, _index));
					break;
				case SQLITE_BLOB:
					break;
				case SQLITE_NULL:
					*((gchar **)_param)		=	NULL;
					break;
				default:
					break;
			}
			_index ++;
		}
	}
	else
	{
		_result	=	FALSE;
	}
	return _result;
	//Method default implement.
}      /* -----  end of static function _step  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _release
 *  Description:
 * =====================================================================================
 */
static void _release( MHContents * self,MHStmt * statement )
{

	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3_stmt * _stmt	=(sqlite3_stmt *)	statement;

	sqlite3_finalize( _stmt );


		//Method default implement.
}      /* -----  end of static function _release  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _del_node
 *  Description:  
 * =====================================================================================
 */
static void _del_node(MHContents * self, MHItem * item)
{
	gint64 * _list;
	gint64 node_id	=	item->uniqueId;
	if( item->type == MH_ITEM_FOLDER)
	{
		gchar * _sql	=	"select descendant from closure where ancestor = ? ; ";

		MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

		sqlite3 * _db	=	_priv->db;
		uint32_t _alloc = 2;
		uint32_t _count = 0;
		static sqlite3_stmt * _stmt = NULL;
		int _err;
		if( _stmt == NULL)
		{
			_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

			if( _err != SQLITE_OK)
			{
				g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			}

		}
		_list	=	(gint64 *)g_malloc0( _alloc * sizeof( gint64 ));
		_list[_count]	=	node_id;
		_count ++;
		sqlite3_reset( _stmt );

		sqlite3_bind_int64(_stmt, 1, node_id);
		while( sqlite3_step( _stmt ) == SQLITE_ROW )
		{
			_list[ _count ] = sqlite3_column_int64( _stmt,0);	

			_count++;

			if( _alloc <= _count)
			{
				_alloc	=	_alloc << 1;
				_list	=	g_realloc( _list, _alloc * sizeof( gint64));
				memset( _list + _count, 0, (_alloc - _count ) * sizeof(gint64));
			}
		}
		_delete_node_by_id( self, _list, _count);
		g_free( _list );
	}
	else
	{
		_list	=	(gint64 *)g_malloc0( sizeof( gint64 ));

		_list[0]	=	node_id;

		_delete_node_by_id(self, _list, 1);
	}

}		/* -----  end of static function _del_node  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _filter_indexer
 *  Description:  
 * =====================================================================================
 */
MHFolder * _filter_indexer(MHContents * self, MHDev * dev, MHFolder * folder, uint32_t type)
{
	return NULL;
//	MHFolder *_res	=	NULL;
//	char * _sql ;
//	//for table node
//	int n_node_id,n_device_id,n_size,n_type;
//	char * n_name;
//	//fro table closure
//	int c_descendant,c_ancestor,c_parent;
//	//for table music
//	int mu_node_id,mu_rating,mu_duration,mu_track,mu_track_count,mu_disc,mu_disc_count,mu_year;
//	char * mu_title;
//	char * mu_album_title;
//	char * mu_artist;
//	char * mu_album_artist;
//	char * mu_genre;
//	char * mu_composer;
//	//fot table movie
//	int mo_node_id,mo_year,mo_duration,mo_fps,mo_xres,mo_yres;
//	char * mo_title;
//	char * mo_director;
//	char * mo_genre;
//	char * mo_language;
//	//for table picture
//	int pi_node_id,pi_width,pi_height,pi_bpp;
//	char * pi_format;
//	
//	MHItem * _item;
//	MHFolder * _folder;
//	MHMusic * _music;
//	MHMovie * _movie;
//	MHPicture * _picture;
//	int _parentid;
//	GNode * _node;
//	GNode * _parentnode;
//	MHItem * _parentitem;
////	MHDevStorage * _dev_storage;
//	guint _device_id;
//	guint _node_id;
////	_dev_storage	=	MH_DEV_STORAGE( dev );
//	
//	GHashTable * hash;
//	hash	=	g_hash_table_new( g_int_hash, g_int_equal);
//    gpointer _condition	=	NULL;
//	
//	MHFolder * _root;
//	_root	=	mh_folder_dup( folder );
//	_root->scanned=true;
//
//	_node	=	g_node_new( _root );
//	MH_ITEM(_root)->node	=	_node;
//
//	g_hash_table_insert( hash,&( MH_ITEM(folder)->uniqueId), _root);
//
//	switch(type)
//	{
//		case 1:
//			_condition	=	g_strdup("where type in (1)");
//			break;
//		case 2:
//			_condition	=	g_strdup("where type in (2)");
//			break;
//		case 3:
//			_condition	=	g_strdup("where type in (1,2)");
//			break;
//		case 4:
//			_condition	=	g_strdup("where type in (3)");
//			break;
//		case 5:
//			_condition	=	g_strdup("where type in (1,3)");
//			break;
//		case 6:
//			_condition	=	g_strdup("where type in (2,3)");
//			break;
//		case 7:
//			_condition	=	g_strdup("where type in (1,2,3)");
//			break;
//		default:
//			break;
//
//	}
//	
// 	_sql	=	g_strdup_printf(	"select * from node "
//							"left outer join closure on node.node_id=closure.descendant "
//							"left outer join music on node.node_id=music.node_id "
//							"left outer join movie on node.node_id=movie.node_id "
//							"left outer join picture on node.node_id=picture.node_id "
//							" %s "
//							" and ancestor 	= %d "
//							"group by node.node_id "
//							"order by node.node_id ",
//							(char *)_condition,
//							MH_ITEM(folder)->uniqueId);
//	g_message("sql:%s\n",_sql);
//	int i=0;
//	mh_contents_prepare( self, _sql);
//	while( mh_contents_step(self, &n_node_id, &n_device_id, &n_name, &n_size, &n_type,
//				&c_descendant, &c_ancestor, &c_parent, &mu_node_id, &mu_title, &mu_rating,
//				&mu_duration, &mu_album_title, &mu_track, &mu_track_count, &mu_disc, &mu_disc_count,
//				&mu_artist, &mu_album_artist, &mu_genre, &mu_composer, &mu_year, &mo_node_id,
//				&mo_title, &mo_year, &mo_director, &mo_duration, &mo_genre, &mo_fps, &mo_xres,
//				&mo_yres, &mo_language,&pi_node_id, &pi_format, &pi_width, &pi_height, &pi_bpp, NULL)==MH_CONTENTS_STEP_CONTINUE)
//	{
//		switch( n_type )
//		{
//			case MH_ITEM_MUSIC:
//				_music	=	g_object_new(MH_TYPE_MUSIC, NULL);
//				_item	=	MH_ITEM( _music );
//		
////				_music->title	=	g_strdup( mu_title );
////				_music->rating	=	mu_rating;
////				_music->duration	=	mu_duration;
////				_music->album_title	=	g_strdup( mu_album_title );
////				_music->track	=	mu_track;
////				_music->track_count	=	mu_track_count;
////				_music->disc	=	mu_disc;
////				_music->disc_count	=	mu_disc_count;
////				_music->artist	=	g_strdup( mu_artist);
////				_music->album_artist	=	g_strdup(mu_album_artist);
////				_music->genre	=	g_strdup(mu_genre);
////				_music->composer	=	g_strdup(mu_composer);
////				_music->year	=	mu_year;
//				break;
//
//			case MH_ITEM_MOVIE:
//				_movie	=	g_object_new( MH_TYPE_MOVIE, NULL);
//				_item	=	MH_ITEM( _movie );
////			
////				_movie->title	=	g_strdup( mo_title );
////				_movie->year	=	mo_year;
////				_movie->director	=	g_strdup( mo_director );
////				_movie->duration	=	mo_duration;
////				_movie->genre	=	mo_genre;
////				_movie->fps	=	mo_fps;
////				_movie->xres	=	mo_xres;
////				_movie->yres	=	mo_yres;
////				_movie->language	=	g_strdup( mo_language );
////
//
//				break;
//			case MH_ITEM_PICTURE:
//				_picture	=	g_object_new( MH_TYPE_PICTURE, NULL);
//				_item	=	MH_ITEM( _picture );
////							
////				_picture->format	=	pi_format;
////				_picture->width	=	pi_width;
////				_picture->height	=	pi_height;
////				_picture->bpp	=	pi_bpp;
//
//				break;
//			default:
//				break;
//		}
//		_node=	g_node_new(_item);
//		_item->node	=	_node;
//
//		int _id_parent	=	c_parent;
//		MHItem * _parent;
//		_parent	=	g_hash_table_lookup( hash, &c_parent);
//
//		if(_parent	!=	NULL)
//		{
//		
//			g_node_prepend( _parent->node,_node );
//
//			_item->uri	=	g_strdup_printf("%s/%s",_parent->uri,n_name);
//
//		}
//	//dd		_dev_storage->indexer	=	_folder;
//		else
//		{
//			MHItem * _tmp_item;
//			MHItem * _parent_item;
//			GNode * _parent_node;
//
//			_tmp_item	=	mh_misc_get_item( &c_parent);
//			_parent_item	=	MH_ITEM(mh_folder_dup( MH_FOLDER(_tmp_item)));
//
//			_parent_node	=	g_node_new(_parent_item );
//			_parent_item->node	=	_parent_node;
//
//			g_node_prepend( _parent_node, _node);
//
//			_item->uri	=	g_strdup_printf("%s/%s",MH_ITEM(_parent_item)->uri,n_name);
//
//			g_hash_table_insert( hash, &(_parent_item->uniqueId),_parent_item);
//
//		
//			_id_parent	=((	MHItem *)(_tmp_item->node->parent->data))->uniqueId;
//			
//			while((_parent= g_hash_table_lookup( hash,& _id_parent))==	NULL)
//			{
//				MHItem * _ancestor_item;
//				GNode * _ancestor_node;
//
//				_tmp_item	=	MH_ITEM(mh_misc_get_item( & _id_parent ));
//				_ancestor_item	=	MH_ITEM(mh_folder_dup( MH_FOLDER(_tmp_item)));
//
//				_ancestor_node	=	g_node_new( _ancestor_item);
//				_ancestor_item->node	=	_ancestor_node;
//
//				g_node_prepend(_ancestor_item->node,_parent_item->node);
//				g_hash_table_insert(hash, &(_ancestor_item->uniqueId), _ancestor_item);
//
//				_id_parent	=((	MHItem *)(_tmp_item->node->parent->data))->uniqueId;
//				_parent_item	=	_ancestor_item;
//			}
//			g_node_prepend(_parent->node,_parent_item->node);
//
//		}
//		_item->uniqueId	=	n_node_id;
//		_item->name	=	g_strdup( n_name );
//		_item->size	=	n_size;
//		_item->type	=	n_type;
//		}
//	g_message("_filter_indexer->count:%d\n",g_node_n_children(MH_ITEM(_root)->node));
//	return _root;

}		/* -----  end of function _filter_indexer  ----- */



/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _restore_data
 *  Description:  
 * =====================================================================================
 */
static gpointer _restore_playlist( MHContents * self, gint64 playlist_id, guint * size)
{
	
	gchar * _sql	=	"select data from playlist where playlist_id =? ";
	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	gpointer _res	=	NULL;

	if(_stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);
		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}

	}
	sqlite3_reset( _stmt);
	sqlite3_bind_int64( _stmt, 1, playlist_id);

	if(sqlite3_step( _stmt )	==	SQLITE_ROW)
	{
		_res	=	(gpointer)sqlite3_column_blob( _stmt,0);
		* size	=	sqlite3_column_bytes( _stmt, 0);
	}
	else
	{
		g_message( "%s", sqlite3_errmsg( _db ));
	}
	return _res;

}		/* -----  end of static function _restore_data  ----- */
#define CONTNETS_NEW_SIZE 10
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_data_names
 *  Description:  
 * =====================================================================================
 */
static char **  _get_data_names( MHContents * self, MHDev * dev )
{
	gchar * _sql	=	"select name from data left join devices where devices.serial_number=? order by name";
	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	char ** _res	=	g_new0( char *, CONTNETS_NEW_SIZE);
	int _count	=	0;
	int _name_num	= 0;
	int _alloc_size	=	CONTNETS_NEW_SIZE;
	
	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL);
		if( _err != SQLITE_OK )
		{
			g_message( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}
	sqlite3_reset( _stmt );
	sqlite3_bind_text( _stmt, 1, dev->serial, -1, NULL);
	while( sqlite3_step( _stmt )	==	SQLITE_ROW)
	{
		if(_count >= 10)
		{
			_alloc_size	=	_alloc_size + CONTNETS_NEW_SIZE;
			_res	=	g_renew( char *, _res, _alloc_size);
			_count	=	0;
		}
		_res[_name_num++]	=	g_strdup(sqlite3_column_text(_stmt,0));
		g_message("_name_num:%d->%s", _name_num-1, _res[_name_num-1]);
		_count++;
		
		
	}
	_res[_name_num]	=	NULL;
//	int i=0;
//	g_message("_name_num:%d\n", _name_num);
//	for(i=0;_res[i]!=NULL;i++)
//	{
//		g_message("%s:%s\n",__func__,_res[i]);
//	}
	return _res;

}		/* -----  end of static function _get_data_names  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _update_node
 *  Description:  
 * =====================================================================================
 */
void _update_node(MHContents * self, MHItem * item)
{
	gchar * _sql	=	"update node set enable	= ? where node_id =	?";
	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	int _err;

	if( _stmt == NULL )
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL );

		if( _err != SQLITE_OK )
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt );

	sqlite3_bind_int(_stmt, 1, item->valid );
	sqlite3_bind_int64(_stmt, 2, item->uniqueId);

	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));
	}

}		/* -----  end of function _update_node  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _update_error_file
 *  Description:  
 * =====================================================================================
 */
static void _update_error_file( MHContents * self, gint64 id, MHItemValid error_flag)
{
	gchar * _sql	=	"update node set enable	= ? where node_id =	?";
	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	int _err;

	if( _stmt == NULL )
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL );

		if( _err != SQLITE_OK )
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt );

	sqlite3_bind_int(_stmt, 1, error_flag );
	sqlite3_bind_int64(_stmt, 2, id);

	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));
	}

}		/* -----  end of static function _update_error_file  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _bind_int64
 *  Description:  
 * =====================================================================================
 */
static void _bind_int64( MHContents * self, MHStmt * statement, uint32_t index, gint64 data)
{
	sqlite3_bind_int64( (sqlite3_stmt*) statement, index, data);
}		/* -----  end of static function _bind_int64  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _reset
 *  Description:  
 * =====================================================================================
 */
static void _reset( MHContents * self, MHStmt * statement)
{
	sqlite3_reset( (sqlite3_stmt*) statement);
}		/* -----  end of static function _reset  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _save_playlist
 *  Description:  
 * =====================================================================================
 */
static gint64  _save_playlist( MHContents *self, MHDev * dev, const char *name, gint64 tag_id, gpointer data, guint64 size )
{
	gchar * _sql		=	"insert into playlist values(NULL, ?, ?, ?, ?)";

	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );
	sqlite3 * _db	=	_priv->db;

	static sqlite3_stmt * _stmt		=	NULL;

	int _err;
	gint64 _res;

	if( _stmt == NULL )
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL );

		if( _err != SQLITE_OK )
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt );

	sqlite3_bind_text( _stmt, 1, name, -1, NULL );
	sqlite3_bind_int64( _stmt, 2, dev->uniqueId );
	sqlite3_bind_int64( _stmt, 3, tag_id );
	sqlite3_bind_blob ( _stmt, 4,  data, size, NULL);
	g_message("%s-->insert into playlist values(NULL, %s, %lld, %lld, blob->:%lld", __func__, name, dev->uniqueId, tag_id, size); 
	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));
	}
	_res	=	sqlite3_last_insert_rowid( _db );
	g_message("%s-->return id:%lld", __func__, _res);
	return _res;
}		/* -----  end of static function _save_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _update_playlist
 *  Description:  
 * =====================================================================================
 */
static void _update_playlist( MHContents * self, MHDev *dev, gint64 playlist_id, const char * name, gint64 tag_id, gpointer data, guint64 size)
{
	gchar * _sql	=	"update playlist set name=?, device_id = ?, tag_id = ?, data = ? where playlist_id = ? ";

	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );
	sqlite3 * _db	=	_priv->db;

	static sqlite3_stmt * _stmt		=	NULL;

	int _err;

	if( _stmt == NULL )
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL );

		if( _err != SQLITE_OK )
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt );

	sqlite3_bind_text( _stmt, 1, name, -1, NULL );
	sqlite3_bind_int64( _stmt, 2, dev->uniqueId );
	sqlite3_bind_int64( _stmt, 3, tag_id );
	sqlite3_bind_blob ( _stmt, 4, data, size, NULL);
	sqlite3_bind_int64( _stmt, 5, playlist_id);
	g_message("%s--->update playlist set name=%s,  device_id = %lld, tag_id = %lld, data =  where playlist_id = %lld ",__func__,
			name, dev->uniqueId, tag_id, playlist_id);
	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));
	}

}		/* -----  end of static function _update_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _delete_playlist
 *  Description:  
 * =====================================================================================
 */
static void _delete_playlist( MHContents * self, gint64 playlist_id)
{
	gchar * _sql	=	"delete from playlist where playlist_id = ? ";

	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );
	sqlite3 * _db	=	_priv->db;

	static sqlite3_stmt * _stmt		=	NULL;
	int _err;

	if( _stmt == NULL )
	{
		_err	=	sqlite3_prepare_v2( _db, _sql, -1, &_stmt, NULL );

		if( _err != SQLITE_OK )
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt );

	sqlite3_bind_int64( _stmt, 1, playlist_id);
	if(sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));
	}

}		/* -----  end of static function _delete_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_playlistid_by_tagId
 *  Description:  
 * =====================================================================================
 */
static gint64 _get_playlistid_by_tagId( MHContents * self, gint64 tagId)
{
	gchar * _sql	=	"select playlist_id from playlist where tag_id = ?";

	static sqlite3_stmt * _stmt	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	int _err;
	gint64 _res = -1;

	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, tagId);

	if( sqlite3_step( _stmt ) == SQLITE_ROW )
	{
		_res	=	sqlite3_column_int64( _stmt, 0);
	}

	return _res;

}		/* -----  end of static function _get_playlistid_by_tagId  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _deinit
 *  Description:  
 * =====================================================================================
 */
static gboolean _deinit(MHContents * self)
{
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );
	gboolean _res	=	TRUE;
	if( sqlite3_close( _priv->db )	!=  SQLITE_OK)
	{
		g_message("sqlite3_close failed:%s",sqlite3_errmsg( _priv->db));
	//	_res	=	FALSE;
		_res	=	TRUE;
	
	}
	return _res;
}		/* -----  end of static function _deinit  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _db_restore
 *  Description:  
 * =====================================================================================
 */
static void _db_restore(MHContents * self)
{
	sqlite3_stmt * _stmt;

	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	int _err;


	gchar * _sql	=	g_strdup("delete from music;");

	if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}	
	if(	SQLITE_DONE !=  sqlite3_step( _stmt ) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}
	if( SQLITE_OK != sqlite3_finalize( _stmt ))
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	g_free( _sql );

	_sql	=	g_strdup("delete from movie;");

	if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}	
	if(	SQLITE_DONE !=  sqlite3_step( _stmt ) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}
	if( SQLITE_OK != sqlite3_finalize( _stmt ))
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	g_free( _sql );

	_sql	=	g_strdup("delete from picture;");

	if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}	
	if(	SQLITE_DONE !=  sqlite3_step( _stmt ) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}
	if( SQLITE_OK != sqlite3_finalize( _stmt ))
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	g_free( _sql );

	_sql	=	g_strdup("delete from playlist;");

	if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}	
	if(	SQLITE_DONE !=  sqlite3_step( _stmt ) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}
	if( SQLITE_OK != sqlite3_finalize( _stmt ))
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	g_free( _sql );

	_sql	=	g_strdup("delete from closure;");

	if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}	
	if(	SQLITE_DONE !=  sqlite3_step( _stmt ) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}
	if( SQLITE_OK != sqlite3_finalize( _stmt ))
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	g_free( _sql );

	_sql	=	g_strdup("delete from node;");

	if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}	
	if(	SQLITE_DONE !=  sqlite3_step( _stmt ) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}
	if( SQLITE_OK != sqlite3_finalize( _stmt ))
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	g_free( _sql );

	_sql	=	g_strdup("delete from devices;");

	if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}	
	if(	SQLITE_DONE !=  sqlite3_step( _stmt ) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));

	}
	if( SQLITE_OK != sqlite3_finalize( _stmt ))
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	g_free( _sql );



}		/* -----  end of static function _db_restore  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _delete_device
 *  Description:  
 * =====================================================================================
 */
static void _delete_device( MHContents * self, gint64 device_id)
{
#if 0	//del db by deviceId
	gchar * _sql	=	g_strdup("select * from node where device_id = ?;");

	static sqlite3_stmt * _stmt1	=	NULL;
	static sqlite3_stmt * _stmt2	=	NULL;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;	
	gint64 * _list;
	uint32_t _count = 0;
	uint32_t _alloc = 1;
	if( _stmt1	==	NULL)
	{

		if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt1, NULL) )
		{
			g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
			
		}
	}
	_list	=	(gint64 *)g_malloc0( _alloc * sizeof( gint64 ));

	sqlite3_reset( _stmt1 );

	sqlite3_bind_int64(_stmt1, 1, device_id);

	while( sqlite3_step( _stmt1 ) == SQLITE_ROW )
	{
		_list[ _count ] = sqlite3_column_int64( _stmt1, 0);
		_count ++;
		if( _alloc <= _count)
		{
			_alloc	=	_alloc << 1;
			_list	=	g_realloc( _list, _alloc * sizeof( gint64 ));
			memset( _list + _count, 0, (_alloc - _count ) * sizeof( gint64));
		}
		
	}
	_delete_node_by_id( self, _list, _count);
	g_free( _list );

	_sql	=	g_strdup("delete from devices where device_id =?;");
	if( _stmt2	==	NULL)
	{

		if( SQLITE_OK != sqlite3_prepare_v2(_db, _sql, -1, &_stmt2, NULL) )
		{
			g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
			
		}
	}

	sqlite3_reset( _stmt2 );

	sqlite3_bind_int64(_stmt2, 1, device_id);

	if( SQLITE_DONE != sqlite3_step( _stmt2 ) )
	{
		g_warning( "%s ->%d: %s", __func__,__LINE__, sqlite3_errmsg( _db ));		
	}
	g_free( _sql );

#else
	static sqlite3_stmt * _stmt_music	= NULL;
	static sqlite3_stmt * _stmt_movie	= NULL;
	static sqlite3_stmt * _stmt_picture = NULL;
	static sqlite3_stmt * _stmt_closure = NULL;
	static sqlite3_stmt * _stmt_node	=	NULL;
	static sqlite3_stmt * _stmt_playlist	=	NULL;
	static sqlite3_stmt * _stmt_devices	=	NULL;
	
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	int _err;

	if( _stmt_music == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db,"delete from music where music_device_id = ? ; ", -1, &_stmt_music, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}

	}
	if( _stmt_movie == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db, "delete from movie where movie_device_id = ? ; ", -1, &_stmt_movie, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}

	if( _stmt_picture == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db, "delete from picture where pic_device_id = ? ; ", -1, &_stmt_picture, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}

	if( _stmt_closure == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db, "delete from closure where closure_device_id = ? ; ", -1, &_stmt_closure, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}


	if( _stmt_node == NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2( _db, "delete from node where device_id = ? ; ", -1, &_stmt_node, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}

	if( _stmt_playlist	==	NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2(_db, "delete from playlist where device_id = ?", -1, &_stmt_playlist, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}
	
	if( _stmt_devices	==	NULL)
	{
		if( SQLITE_OK != sqlite3_prepare_v2(_db, "delete from devices where device_id = ?", -1, &_stmt_devices, NULL))
		{
			g_warning( "%s -->%d prepare failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
		}
	}

	sqlite3_reset( _stmt_music );
	sqlite3_reset( _stmt_movie );
	sqlite3_reset( _stmt_picture );
	sqlite3_reset( _stmt_closure );
	sqlite3_reset( _stmt_node );
	sqlite3_reset( _stmt_playlist );
	sqlite3_reset( _stmt_devices );
	
	sqlite3_bind_int64(_stmt_music, 1, device_id);
	sqlite3_bind_int64(_stmt_movie, 1, device_id);
	sqlite3_bind_int64(_stmt_picture, 1, device_id);
	sqlite3_bind_int64(_stmt_closure, 1, device_id);
	sqlite3_bind_int64(_stmt_node, 1, device_id);
	sqlite3_bind_int64(_stmt_playlist, 1, device_id);
	sqlite3_bind_int64(_stmt_devices, 1, device_id);

	if( SQLITE_DONE != sqlite3_step( _stmt_music ) )
	{
		g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	if( SQLITE_DONE != sqlite3_step( _stmt_movie ) )
	{
		g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	if( SQLITE_DONE != sqlite3_step( _stmt_picture ) )
	{
		g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	if( SQLITE_DONE != sqlite3_step( _stmt_closure ) )
	{
		g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	if( SQLITE_DONE != sqlite3_step( _stmt_node ) )
	{
		g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	if( SQLITE_DONE != sqlite3_step( _stmt_playlist ) )
	{
		g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	if( SQLITE_DONE != sqlite3_step( _stmt_devices ) )
	{
		g_warning( "%s -->%d step failed: %s", __func__,__LINE__, sqlite3_errmsg( _db ));
	}
	
#endif


}		/* -----  end of static function _delete_device  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_descendant
 *  Description:  
 * =====================================================================================
 */
static gint64 * _get_descendant( MHContents * self, gint64 node_id, uint32_t * count)
{
	gchar * _sql	=	"select descendant from closure where ancestor = ? ; ";

	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	gint64 * _list;
	uint32_t _alloc = 2;
	uint32_t _count = 0;
	static sqlite3_stmt * _stmt = NULL;
	int _err;
	if( _stmt == NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

		}
	
	}
	_list	=	(gint64 *)g_malloc0( _alloc * sizeof( gint64 ));

	_list[_count]	=	node_id;
	_count ++;

	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, node_id);
	while( sqlite3_step( _stmt ) == SQLITE_ROW )
	{
		_list[ _count ] = sqlite3_column_int64( _stmt,0);	

		_count++;

		if( _alloc <= _count)
		{
			_alloc	=	_alloc << 1;
			_list	=	g_realloc( _list, _alloc * sizeof( gint64));
			memset( _list + _count, 0, (_alloc - _count ) * sizeof(gint64));
		}
	}
	*count	=	_count;
	return _list;

}		/* -----  end of static function _get_descendant  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_ancestor
 *  Description:  
 * =====================================================================================
 */
static gint64 * _get_ancestor( MHContents * self, gint64 node_id, uint32_t * count)
{
	gchar * _sql	=	"select ancestor from closure where descendant = ? ; ";

	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;
	gint64 * _list;
	uint32_t _alloc = 2;
	uint32_t _count = 0;
	static sqlite3_stmt * _stmt = NULL;
	int _err;
	if( _stmt == NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

		}
	
	}
	_list	=	(gint64 *)g_malloc0( _alloc * sizeof( gint64 ));

//	_list[_count]	=	node_id;
//	_count ++;

	sqlite3_reset( _stmt );

	sqlite3_bind_int64(_stmt, 1, node_id);
	g_message("select ancestor from closure where descendant = %lld;", node_id);
	while( sqlite3_step( _stmt ) == SQLITE_ROW )
	{
		_list[ _count ] = sqlite3_column_int64( _stmt,0);	

		_count++;

		if( _alloc <= _count)
		{
			_alloc	=	_alloc << 1;
			_list	=	g_realloc( _list, _alloc * sizeof( gint64));
			memset( _list + _count, 0, (_alloc - _count ) * sizeof(gint64));
		}
	}
	if( _count == 1 && _list[0] == node_id)
	{
		g_message("root");
	}
	else
	{
		_list[_count]	=	node_id;
		_count ++;
	}
	g_message("_count:%d", _count);
	*count	=	_count;
	return _list;

}		/* -----  end of static function _get_ancestor  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _update_music
 *  Description:  
 * =====================================================================================
 */
static void _update_music( MHContents * self, gint64 node_id, MHMusic * music)
{
	gchar * _sql	=	"update music set title=?, rating=?, duration=?, album_title=?, \
						 track=?, track_count=?, disc=?, disc_count=?, artist=?,\
						 album_artist=?, genre=?, composer=?, year=?, media_type=?,\
						 compliation=? where node_id=?";
	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

//	sqlite3_bind_int64(_stmt, 1, MH_ITEM( music )->uniqueId );
	sqlite3_bind_text( _stmt, 1, (music->title)? music->title : "" , -1, NULL );
	sqlite3_bind_int(_stmt, 2, music->rating);
	sqlite3_bind_int(_stmt, 3, music->duration);
	sqlite3_bind_text( _stmt, 4, (music->album_title )? music->album_title : "", -1, NULL );
	sqlite3_bind_int(_stmt, 5, music->track);
	sqlite3_bind_int(_stmt, 6, music->track_count);
	sqlite3_bind_int(_stmt, 7, music->disc);
	sqlite3_bind_int(_stmt, 8, music->disc_count);
	sqlite3_bind_text( _stmt, 9, (music->artist ) ? music->artist : "", -1, NULL );
	sqlite3_bind_text( _stmt, 10, (music->album_artist ) ? music->album_artist : "", -1, NULL );
	sqlite3_bind_text( _stmt, 11, (music->genre ) ? music->genre : "", -1, NULL );
	sqlite3_bind_text( _stmt, 12, (music->composer ) ? music->composer : "", -1, NULL );
	sqlite3_bind_int(_stmt, 13, music->year);
	sqlite3_bind_int( _stmt, 14, music->mediaType);
	sqlite3_bind_int( _stmt, 15, music->album_compliation);
	sqlite3_bind_int64( _stmt, 16, MH_ITEM( music)->uniqueId);
	if( sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));

	}

}		/* -----  end of static function _update_music  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _update_movie
 *  Description:  
 * =====================================================================================
 */
static void _update_movie( MHContents * self, gint64 node_id, MHMovie * movie)
{
	gchar * _sql	=	"update movie set title=?, year=?, director=?, duration=?, \
						 genre=?, fps=?, xres=?, yres=?, language=? where node_id=?";
	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

	sqlite3_bind_text( _stmt, 1, movie->title, -1, NULL );
	sqlite3_bind_int(_stmt, 2, movie->year);
	sqlite3_bind_text( _stmt, 3, movie->director, -1, NULL );
	sqlite3_bind_int(_stmt, 4, movie->duration);
	sqlite3_bind_text( _stmt, 5, movie->genre, -1, NULL );
	sqlite3_bind_int(_stmt, 6, movie->fps);
	sqlite3_bind_int(_stmt, 7,  movie->xres);
	sqlite3_bind_int(_stmt, 8,  movie->yres);
	sqlite3_bind_text( _stmt, 9,  movie->language, -1, NULL );	
	sqlite3_bind_int64(_stmt, 10, MH_ITEM( movie )->uniqueId );

	if( sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));

	}
}		/* -----  end of static function _update_movie  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _update_picture
 *  Description:  
 * =====================================================================================
 */
static void _update_picture( MHContents * self, gint64 node_id, MHPicture * picture)
{
	gchar * _sql	=	"update picture set format=?, width=?, height=?, bpp=? where node_id=?";
	static sqlite3_stmt * _stmt	=	NULL;
	int _err;
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );

	sqlite3 * _db	=	_priv->db;

	if( _stmt	==	NULL)
	{
		_err	=	sqlite3_prepare_v2(_db, _sql, -1, &_stmt, NULL);

		if( _err != SQLITE_OK)
		{
			g_warning( "%s prepare failed: %s", __func__, sqlite3_errmsg( _db ));

			
		}
	}
	sqlite3_reset( _stmt );

	sqlite3_bind_text( _stmt, 1, picture->format, -1, NULL );
	sqlite3_bind_int(_stmt, 2, picture->width);
	sqlite3_bind_int(_stmt, 3, picture->height);
	sqlite3_bind_int(_stmt, 4, picture->bpp);
	sqlite3_bind_int64(_stmt, 5, MH_ITEM( picture )->uniqueId );


	if( sqlite3_step( _stmt ) != SQLITE_DONE )
	{
		g_warning( "%s step failed: %s", __func__, sqlite3_errmsg( _db ));

	}
}		/* -----  end of static function _update_picture  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_dispose
 *  Description:
 * =====================================================================================
 */
static void mh_contents_dispose( GObject * object )
{
	MHContents * _self	=	MH_CONTENTS( object );

	G_OBJECT_CLASS( mh_contents_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_finalize
 *  Description:
 * =====================================================================================
 */
static void mh_contents_finalize( GObject * object )
{
	MHContents * _self	=	MH_CONTENTS( object );
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( _self );

	G_OBJECT_CLASS( mh_contents_parent_class )->finalize( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_constructor
 *  Description:  
 * =====================================================================================
 */
static GObject * mh_contents_constructor( GType type, guint n_construct_params, 
									GObjectConstructParam * construct_params )
{
	GObject * _obj	=	G_OBJECT( contentsObject );
	if(contentsObject == NULL)
	{
		_obj	=	G_OBJECT_CLASS( mh_contents_parent_class )->constructor( type, 
						n_construct_params,	construct_params );
	}
	return _obj ;
}		/* -----  end of static function mh_contents_constructor  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_init
 *  Description:
 * =====================================================================================
 */
static void mh_contents_init( MHContents * self )
{
	g_message("mh_contents_init IN!!!!!!!!!!");
	MHContentsPrivate * _priv	=	mh_contents_get_instance_private( self );
	sqlite3 * _db;
//	GRecMutex * _mutex;
	g_message("mh_contents_init wait db_open_sem before!!!!!!!!!!");
	sem_wait(&db_open_sem);
	g_message("mh_contents_init wait db_open_sem after!!!!!!!!!!");
	_db	=	db_create_database();
	db_create_table(_db);
	_priv->db	=	_db;
	g_message("mh_contents_init OUT!!!!!!!!!!");
//	_mutex	=	g_new0( GRecMutex,1);
//	g_rec_mutex_init( _mutex );
	
}       /* -----  end of static function mh_contents_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_contents_class_init( MHContentsClass * klass )
{
	GObjectClass * _parentClass	=	G_OBJECT_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	mh_contents_dispose;
	_gobjectClass->finalize	=	mh_contents_finalize;
	_gobjectClass->constructor = mh_contents_constructor;

	/* assemble ios of mh_contents class */

	/* assemble methods of mh_contents class */
//	klass->instance	=	_instance;
	klass->get_device	=	_get_device;
	klass->add_device	=	_add_device;
	klass->update_device_private	=	_update_device_private;
	klass->get_device_private	=	_get_device_private;
	klass->get_id_by_tagId	=	_get_id_by_tagId;
	klass->delete_node_by_device_id	=	_delete_node_by_device_id;
	klass->delete_playlist_by_device_id	=	_delete_playlist_by_device_id;


	klass->add_node	=	_add_node;
	klass->add_closure	=	_add_closure;
	klass->add_music	=	_add_music;
	klass->add_movie	=	_add_movie;
	klass->add_picture	=	_add_picture;
	klass->begin_transaction	=	_begin_transaction;
	klass->commit_transaction	=	_commit_transaction;
	klass->rollback_transaction	=	_rollback_transaction;
	klass->prepare	=	_prepare;
	klass->step	=	_step;
	klass->release	=	_release;

	klass->del_node	=	_del_node;
	klass->restore_playlist	=	_restore_playlist;
	klass->get_data_names	=	_get_data_names;
	klass->update_node	=	_update_node;
	klass->update_error_file	=	_update_error_file;
	klass->bind_int64	=	_bind_int64;
	klass->reset	=	_reset;

	klass->save_playlist	=	_save_playlist;
	klass->update_playlist	=	_update_playlist;
	klass->delete_playlist	=	_delete_playlist;
	klass->get_playlistid_by_tagId	=	_get_playlistid_by_tagId;
	klass->deinit	=	_deinit;
	klass->db_restore	=	_db_restore;
	klass->delete_device	=	_delete_device;
	klass->get_descendant	=	_get_descendant;
	klass->get_ancestor		=	_get_ancestor;

	klass->update_music	=	_update_music;
	klass->update_movie	=	_update_movie;
	klass->update_picture	=	_update_picture;
	/* Ios */
	/* Signals */
}       /* -----  end of static function mh_contents_class_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_instance
 *  Description:
 * =====================================================================================
 */
MHContents * mh_contents_instance()
{
	contentsObject	=	g_object_new( MH_TYPE_CONTENTS, NULL );
	return contentsObject;
}		/* -----  end of function mh_contents_instance  ----- */

		/* -----  end of function mh_contents_instance  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_get_device
 *  Description:  
 * =====================================================================================
 */
gint64 mh_contents_get_device( MHContents * self, char *  serial_number)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), 0);
	gint64 res	=	-1;
	if( MH_CONTENTS_GET_CLASS( self )->get_device!= NULL )
	{
		res = MH_CONTENTS_GET_CLASS( self )->get_device( MH_CONTENTS( self ), 
			serial_number);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::get_device()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return res;
}		/* -----  end of static function mh_contents_get_device  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_add_device
 *  Description:
 * =====================================================================================
 */
gint64 mh_contents_add_device(MHContents * self, char *  serial_number )
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), 0);
	gint64 res=0;
	if( MH_CONTENTS_GET_CLASS( self )->add_device!= NULL )
	{
		res=MH_CONTENTS_GET_CLASS( self )->add_device( MH_CONTENTS( self ), 
			serial_number);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::add_device()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return res;
}		/* -----  end of function mh_contents_add_device  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_update_device_private
 *  Description:  
 * =====================================================================================
 */
gint64 mh_contents_update_device_private(MHContents * self, gint64 device_id, gpointer private_data, guint mixer_size)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), 0);
	gint64 res=0;
	if( MH_CONTENTS_GET_CLASS( self )->update_device_private!= NULL )
	{
		res=MH_CONTENTS_GET_CLASS( self )->update_device_private( MH_CONTENTS( self ), 
			device_id,private_data,  mixer_size);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::update_device_private()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return res;
}		/* -----  end of static function mh_contents_update_device_private  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_get_id_by_name
 *  Description:  
 * =====================================================================================
 */
gint64 mh_contents_get_id_by_tagId(MHContents * self, gint64 device_id, gint64 tagId)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), -1);
	gint64 res = -1;
	if( MH_CONTENTS_GET_CLASS( self )->get_id_by_tagId!= NULL )
	{
		res = MH_CONTENTS_GET_CLASS( self )->get_id_by_tagId( MH_CONTENTS( self ), 
			device_id, tagId);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::get_id_by_tagId()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return res;
}		/* -----  end of static function mh_contents_get_id_by_name  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_delete_node_by_device_id
 *  Description:  
 * =====================================================================================
 */
void mh_contents_delete_node_by_device_id(MHContents * self, gint64 device_id)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));

	if( MH_CONTENTS_GET_CLASS( self )->delete_node_by_device_id!= NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->delete_node_by_device_id( MH_CONTENTS( self ), 
			device_id);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::delete_node_by_device_id()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_delete_node_by_device_id  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_add_node
 *  Description:
 * =====================================================================================
 */
gint64 mh_contents_add_node(MHContents * self, gint64 device_id, MHItem * item)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), 0);
	gint64 res=0;
	if( MH_CONTENTS_GET_CLASS( self )->add_node!= NULL )
	{
		res=MH_CONTENTS_GET_CLASS( self )->add_node( MH_CONTENTS( self ),device_id, 
			item );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::add_node()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return res;
}		/* -----  end of function mh_contents_add_node  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_add_closure
 *  Description:
 * =====================================================================================
 */
void mh_contents_add_closure(MHContents * self, gint64 descendant, gint64 ancestor, gint64 parent, gint64 device_id)//del db by deviceId
{
	g_return_if_fail( MH_IS_CONTENTS( self ) );
	if( MH_CONTENTS_GET_CLASS( self )->add_closure != NULL )
	{
	   MH_CONTENTS_GET_CLASS( self )->add_closure(  MH_CONTENTS( self ), 
 			descendant, ancestor, parent, device_id);//del db by deviceId
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::add_closure()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_add_closure  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_add_music
 *  Description:
 * =====================================================================================
 */
void mh_contents_add_music(MHContents * self, MHMusic * music, gint64 device_id)//del db by deviceId
{
	g_return_if_fail( MH_IS_CONTENTS( self ));

	if( MH_CONTENTS_GET_CLASS( self )->add_music != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->add_music(  MH_CONTENTS( self ), 
 			music, device_id);//del db by deviceId
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::add_music()'",
				G_OBJECT_TYPE_NAME( self ));
	}

}		/* -----  end of function mh_contents_add_music  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_add_movie
 *  Description:
 * =====================================================================================
 */
void mh_contents_add_movie( MHContents * self, MHMovie * movie, gint64 device_id)//del db by deviceId
{
	g_return_if_fail( MH_IS_CONTENTS( self ));

	if( MH_CONTENTS_GET_CLASS( self )->add_movie != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->add_movie(  MH_CONTENTS( self ), 
 			movie, device_id);//del db by deviceId
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::add_movie()'",
				G_OBJECT_TYPE_NAME( self ));
	}

}		/* -----  end of function mh_contents_add_movie  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_add_image
 *  Description:
 * =====================================================================================
 */
void mh_contents_add_picture(MHContents * self, MHPicture * picture , gint64 device_id)//del db by deviceId
{
	g_return_if_fail( MH_IS_CONTENTS( self ));

	if( MH_CONTENTS_GET_CLASS( self )->add_picture != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->add_picture(  MH_CONTENTS( self ), 
 			picture, device_id);//del db by deviceId
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::add_image()'",
				G_OBJECT_TYPE_NAME( self ));
	}

}		/* -----  end of function mh_contents_add_image  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_begin_transaction
 *  Description:
 * =====================================================================================
 */
void mh_contents_begin_transaction( MHContents * self )
{
	g_return_if_fail( MH_IS_CONTENTS( self ));

	if( MH_CONTENTS_GET_CLASS( self )->begin_transaction != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->begin_transaction( MH_CONTENTS( self ));
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::begin_transaction()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_begin_transaction  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_commit_transaction
 *  Description:
 * =====================================================================================
 */
void mh_contents_commit_transaction( MHContents * self )
{
	g_return_if_fail( MH_IS_CONTENTS( self ));

	if( MH_CONTENTS_GET_CLASS( self )->commit_transaction != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->commit_transaction( MH_CONTENTS( self ) );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::commit_transaction()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_commit_transaction  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_rollback_transaction
 *  Description:
 * =====================================================================================
 */
void mh_contents_rollback_transaction( MHContents * self )
{
	g_return_if_fail( MH_IS_CONTENTS( self ));

	if( MH_CONTENTS_GET_CLASS( self )->rollback_transaction != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->rollback_transaction( MH_CONTENTS( self ) );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::rollback_transaction()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_rollback_transaction  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_prepare
 *  Description:
 * =====================================================================================
 */
MHStmt * mh_contents_prepare( MHContents * self,char * sql )
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), NULL);
	
	MHStmt * _res	=	NULL;
	if( MH_CONTENTS_GET_CLASS( self )->prepare != NULL )
	{
		_res =	MH_CONTENTS_GET_CLASS( self )->prepare( MH_CONTENTS( self ),sql );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::prepare()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _res;
}		/* -----  end of function mh_contents_prepare  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_step
 *  Description:
 * =====================================================================================
 */
MHContentsResult  mh_contents_step( MHContents * self, MHStmt * statement, ... )
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ),MH_INVALID_PARAM);

	MHContentsResult _res	=	MH_CONTENTS_OK;

	va_list _ap;

	va_start( _ap, statement);

	gboolean _step_res;

	if( MH_CONTENTS_GET_CLASS( self )->step != NULL )
	{
		_step_res = MH_CONTENTS_GET_CLASS( self )->step( MH_CONTENTS( self ), statement, _ap );
		if(_step_res ==	TRUE)
		{
			_res	=	MH_CONTENTS_STEP_CONTINUE;
		}
		else
		{
			_res	=	MH_CONTENTS_STEP_FINISH;
		}
		
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::step()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_CONTENTS_INVALID_PARA;
	}
	va_end( _ap );
	return _res;

}		/* -----  end of function mh_contents_step  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_release
 *  Description:
 * =====================================================================================
 */
void mh_contents_release( MHContents * self, MHStmt * statement )
{
	g_return_if_fail( MH_IS_CONTENTS( self ));

	if( MH_CONTENTS_GET_CLASS( self )->release != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->release(  MH_CONTENTS( self ), statement );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::release()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_release  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_get_device_mixer
 *  Description:  
 * =====================================================================================
 */
gpointer mh_contents_get_device_private( MHContents * self, gint64 device_id, int * size)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), NULL);
	gpointer res	=	NULL ;

	if( MH_CONTENTS_GET_CLASS( self )->get_device_private!= NULL )
	{
		res	=	MH_CONTENTS_GET_CLASS( self )->get_device_private(  MH_CONTENTS( self ),device_id,size );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::get_device_private()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return res;
}		/* -----  end of function mh_contents_get_device_mixer  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_del_node
 *  Description:  
 * =====================================================================================
 */
void mh_contents_del_node(MHContents * self, MHItem * item)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	g_return_if_fail( MH_IS_ITEM( item ));

	if( MH_CONTENTS_GET_CLASS( self )->del_node!= NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->del_node(  MH_CONTENTS( self ),item);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::del_node()'",
				G_OBJECT_TYPE_NAME( self ));
	}

}		/* -----  end of function mh_contents_del_node  ----- */



/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_restore_playlist
 *  Description:  
 * =====================================================================================
 */
gpointer mh_contents_restore_playlist( MHContents * self, gint64 playlist_id, guint * size)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ),NULL);

	if( MH_CONTENTS_GET_CLASS( self )->restore_playlist!= NULL )
	{
		return MH_CONTENTS_GET_CLASS( self )->restore_playlist(  MH_CONTENTS( self ), playlist_id, size);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::restore_playlist()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return NULL;
}		/* -----  end of function mh_contents_restore_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_get_data_names
 *  Description:  
 * =====================================================================================
 */
char ** mh_contents_get_data_names( MHContents * self, MHDev * dev)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ),NULL);

	if( MH_CONTENTS_GET_CLASS( self )->get_data_names!= NULL )
	{
		return MH_CONTENTS_GET_CLASS( self )->get_data_names(  MH_CONTENTS( self ), dev);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::get_data_names()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return NULL;

}		/* -----  end of function mh_contents_get_data_names  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_update_node
 *  Description:  
 * =====================================================================================
 */
void mh_contents_update_node( MHContents * self, MHItem * item)  
{
	g_return_if_fail( MH_IS_CONTENTS( self ) );
	g_return_if_fail( MH_IS_ITEM( item ) );

	if( MH_CONTENTS_GET_CLASS( self )->update_node!= NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->update_node(  MH_CONTENTS( self ), item);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::update_node()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_update_node_enable  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_update_error_file
 *  Description:  
 * =====================================================================================
 */
void mh_contents_update_error_file( MHContents * self, gint64 id, MHItemValid error_flag)
{
	g_return_if_fail( MH_IS_CONTENTS( self ) );

	if( MH_CONTENTS_GET_CLASS( self )->update_error_file!= NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->update_error_file(  MH_CONTENTS( self ), id, error_flag);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::update_error_file()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_update_error_file  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_save_playlist
 *  Description:  
 * =====================================================================================
 */
gint64 mh_contents_save_playlist( MHContents *self, MHDev * dev, const char *name, gint64 tag_id, gpointer data, guint64 size)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ) , 0);
	
	gint64 _res	=	0;

	if( MH_CONTENTS_GET_CLASS( self )->save_playlist!= NULL )
	{
		_res	=	MH_CONTENTS_GET_CLASS( self )->save_playlist(  MH_CONTENTS( self ), dev, name, tag_id, data, size);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::save_playlist()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _res;
}		/* -----  end of function mh_contents_save_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_bind_int64
 *  Description:  
 * =====================================================================================
 */
void mh_contents_bind_int64(MHContents * self, MHStmt * statement, uint32_t index, gint64 data)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	

	if( MH_CONTENTS_GET_CLASS( self )->bind_int64!= NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->bind_int64(  MH_CONTENTS( self ), statement, index, data);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::bind_int64()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_bind_int64  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_reset
 *  Description:  
 * =====================================================================================
 */
void mh_contents_reset(MHContents * self, MHStmt * statement)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	

	if( MH_CONTENTS_GET_CLASS( self )->reset!= NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->reset(  MH_CONTENTS( self ), statement);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::reset()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_reset  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_update_playlist
 *  Description:  
 * =====================================================================================
 */
void mh_contents_update_playlist( MHContents * self, MHDev * dev, gint64 playlist_id, const char * name, gint64 tag_id, gpointer data, guint64 size)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	

	if( MH_CONTENTS_GET_CLASS( self )->update_playlist!= NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->update_playlist(  MH_CONTENTS( self ), dev, playlist_id, name, tag_id, data, size);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::update_playlist()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_update_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_delete_playlist
 *  Description:  
 * =====================================================================================
 */
void mh_contents_delete_playlist( MHContents * self, gint64 playlist_id)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	g_return_if_fail( playlist_id != 0);
	

	if( MH_CONTENTS_GET_CLASS( self )->delete_playlist!= NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->delete_playlist(  MH_CONTENTS( self ), playlist_id);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::delete_playlist()'",
				G_OBJECT_TYPE_NAME( self ));
	}

}		/* -----  end of function mh_contents_delete_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_get_playlistid_by_tagId
 *  Description:  
 * =====================================================================================
 */
gint64 mh_contents_get_playlistid_by_tagId( MHContents * self, gint64 tagId)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), -1);

	gint64 res = -1;

	if( MH_CONTENTS_GET_CLASS( self )->get_playlistid_by_tagId!= NULL )
	{
		res = MH_CONTENTS_GET_CLASS( self )->get_playlistid_by_tagId( MH_CONTENTS( self ), tagId);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::get_playlistid_by_tagId()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return res;

}		/* -----  end of function mh_contents_get_playlistid_by_tagId  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_deinit
 *  Description:  
 * =====================================================================================
 */
gboolean mh_contents_deinit( MHContents * self)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ), FALSE);
	gboolean _res	=	FALSE;
	if( MH_CONTENTS_GET_CLASS( self )->deinit != NULL )
	{
		_res	=	MH_CONTENTS_GET_CLASS( self )->deinit(  MH_CONTENTS( self ) );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::deinit()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _res;
}		/* -----  end of function mh_contents_deinit  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_delete_playlist_by_device_id
 *  Description:  
 * =====================================================================================
 */
void mh_contents_delete_playlist_by_device_id( MHContents * self, gint64 device_id)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	
	if( MH_CONTENTS_GET_CLASS( self )->delete_playlist_by_device_id != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->delete_playlist_by_device_id(  MH_CONTENTS( self ), device_id );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::delete_playlist_by_device_id()'",
				G_OBJECT_TYPE_NAME( self ));
	}

}		/* -----  end of function mh_contents_delete_playlist_by_device_id  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_db_restore
 *  Description:  
 * =====================================================================================
 */
void mh_contents_db_restore( MHContents * self)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	
	if( MH_CONTENTS_GET_CLASS( self )->db_restore != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->db_restore(  MH_CONTENTS( self ));
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::db_restore()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_db_restore  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_delete_device
 *  Description:  
 * =====================================================================================
 */
void mh_contents_delete_device( MHContents * self, gint64 device_id)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	
	if( MH_CONTENTS_GET_CLASS( self )->delete_device != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->delete_device(  MH_CONTENTS( self ), device_id);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::delete_device()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_delete_device  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_get_descendant
 *  Description:  
 * =====================================================================================
 */
gint64 * mh_contents_get_descendant( MHContents * self, gint64 node_id, uint32_t * count)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ),NULL);
	gint64 * _res;
	if( MH_CONTENTS_GET_CLASS( self )->get_descendant != NULL )
	{
		_res = MH_CONTENTS_GET_CLASS( self )->get_descendant(  MH_CONTENTS( self ), node_id, count);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::get_descendant()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _res;
}		/* -----  end of function mh_contents_get_descendant  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_get_ancestor
 *  Description:  
 * =====================================================================================
 */
gint64 * mh_contents_get_ancestor( MHContents * self, gint64 node_id, uint32_t * count)
{
	g_return_val_if_fail( MH_IS_CONTENTS( self ),NULL);
	gint64 * _res;
	if( MH_CONTENTS_GET_CLASS( self )->get_ancestor != NULL )
	{
		_res = MH_CONTENTS_GET_CLASS( self )->get_ancestor(  MH_CONTENTS( self ), node_id, count);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::get_ancestor()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _res;
}		/* -----  end of function mh_contents_get_ancestor  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_update_music
 *  Description:  
 * =====================================================================================
 */
void mh_contents_update_music( MHContents * self, gint64 node_id, MHMusic * music)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	
	if( MH_CONTENTS_GET_CLASS( self )->update_music != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->update_music(  MH_CONTENTS( self ), node_id, music );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::update_music()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_update_music  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_update_movie
 *  Description:  
 * =====================================================================================
 */
void mh_contents_update_movie( MHContents * self, gint64 node_id, MHMovie * movie)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	
	if( MH_CONTENTS_GET_CLASS( self )->update_movie != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->update_movie(  MH_CONTENTS( self ), node_id, movie );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::update_movie()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_update_movie  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_contents_update_picture
 *  Description:  
 * =====================================================================================
 */
void mh_contents_update_picture( MHContents * self, gint64 node_id, MHPicture * picture)
{
	g_return_if_fail( MH_IS_CONTENTS( self ));
	
	if( MH_CONTENTS_GET_CLASS( self )->update_picture != NULL )
	{
		MH_CONTENTS_GET_CLASS( self )->update_picture(  MH_CONTENTS( self ), node_id, picture );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHContentsClass::update_picture()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_contents_update_picture  ----- */
