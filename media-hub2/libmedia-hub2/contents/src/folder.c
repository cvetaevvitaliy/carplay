/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include <mh_folder.h>
#include <mh_playlist.h>
#include <stdio.h>
#include <string.h>
#include <mh_misc.h>
#include <mh_music.h>
#include <mh_movie.h>
#include <mh_picture.h>
#include <mh_filter.h>
#include "order.h"
#include <mh_contents.h>
#include <mh_dev.h>
#include <stdlib.h>

#define AUTO_EXTENDED_FACTOR	20

typedef struct _MHFolderPrivate MHFolderPrivate;

struct _MHFolderPrivate
{
	gint dummy;
};

G_DEFINE_TYPE_WITH_PRIVATE( MHFolder, mh_folder, MH_TYPE_ITEM )
	
enum
{
	PROP_0,

	PROP_FOLDER_MUSIC_FILE_COUNT,
	PROP_FOLDER_MOVIE_FILE_COUNT,

	N_PROPERTIES
};

static GParamSpec *folderProperties[ N_PROPERTIES ] = { NULL, };


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _scan_folder
 *  Description:  
 * =====================================================================================
 */
static void _scan_folder( MHFolder * folder, MHItemOrderType order, int max_file_infolder)
{
	if( !folder->scanned )
	{
		DIR * _dir;
		struct dirent * _file;
		MHItemType _type;
		MHMusic * _music;
		MHMovie * _movie;
		MHPicture * _picture;
		folder->hash	=	g_hash_table_new( g_str_hash, g_str_equal );

		int fileCnt = 0;
		_dir	=	opendir( MH_ITEM( folder )->uri );

		if( _dir )
		{
			while(( _file = readdir( _dir )) != NULL )
			{
				if( strncmp( _file->d_name, ".", 1 ) != 0
				   && g_strcmp0( _file->d_name, "$RECYCLE.BIN")!=0
				   && g_strcmp0( _file->d_name, "System Volume Information")!=0)
//				   && g_strcmp0( _file->d_name, "Recycled" ) !=0 )/* Omits ., .. and all hidden files */
				{
					MHItem * _item;
					if( _file->d_type == DT_DIR )
					{
						_item	=	MH_ITEM( g_object_new( MH_TYPE_FOLDER, NULL ));
						_type	=	MH_ITEM_FOLDER;
					}
					else
					{
					

						_type	=	mh_misc_get_file_type( _file->d_name );
						if(max_file_infolder != 0 && fileCnt >= max_file_infolder)
						{
							//g_message("_scan_folder check file cnt >= %d", max_file_infolder);
							continue;
						}
						switch( _type )
						{
							case MH_ITEM_MUSIC:

								_music	=	g_object_new( MH_TYPE_MUSIC, NULL);
								_item	=	MH_ITEM( _music );
								_item->type	=	_type;
								fileCnt++;
								break;
							
							case MH_ITEM_MOVIE:
							
								_movie	=	g_object_new( MH_TYPE_MOVIE, NULL);
								_item	=	MH_ITEM( _movie );
								_item->type	=	_type;
								fileCnt++;
								break;

							case MH_ITEM_PICTURE:
							
								_picture	=	g_object_new( MH_TYPE_PICTURE, NULL);
								_item	=	MH_ITEM( _picture );
								_item->type	=	_type;
								fileCnt++;
							    break;
							case MH_ITEM_PLAYLIST:

								_item	=	g_object_new( MH_TYPE_ITEM, NULL);
								_item->type	=	_type;
								break;

							default:
								break;
						}
							
					}
					if( _type !=	MH_ITEM_NONE )
					{

					
						_item->dev	=	MH_ITEM( folder )->dev;
						_item->name	=	g_strdup( _file->d_name );
						_item->node	=	g_node_new( _item );
						_item->uri	=	g_strdup_printf( "%s/%s", MH_ITEM( folder )->uri, _item->name );
		
						g_node_append( MH_ITEM( folder )->node, _item->node );

						g_hash_table_insert( folder->hash, _item->name, _item->node );
						if(MH_DEV(_item->dev)->dev_status==false)
						{
							g_message("_scan_folder check dev_status == false");
							break;
						}

					}
				}
			}

			closedir( _dir );

			folder->scanned	=	TRUE;
		}
		else
		{
			g_warning( "opendir: %s failed", MH_ITEM( folder )->uri );
		}
	}

	if( folder->order != order )
	{
		switch( order )
		{
		case MH_ITEM_ORDER_BY_ALPHABET:
			MH_ITEM( folder )->node->children	=	
				( GNode * )g_list_sort( ( GList * )(MH_ITEM( folder )->node->children), orderByAlphabet );
			break;
		case MH_ITEM_ORDER_BY_PINYIN:
			MH_ITEM( folder )->node->children	=	
				( GNode * )g_list_sort( ( GList * )(MH_ITEM( folder )->node->children), orderByPinyin );
			break;
		case MH_ITEM_ORDER_BY_ALPHABET_FOR_NAGIVI:
			MH_ITEM( folder )->node->children	=	
				( GNode * )g_list_sort( ( GList * )(MH_ITEM( folder )->node->children), orderByAlphabetForNagivi );
			break;
		case MH_ITEM_ORDER_BY_ALPHABET_FOR_NAGIVI_JP:
			MH_ITEM( folder )->node->children	=	
				( GNode * )g_list_sort( ( GList * )(MH_ITEM( folder )->node->children), orderByAlphabetForNagiviJp );
			break;
		default:
			break;
		}

		if( order != MH_ITEM_ORDER_BY_DEFAULT )
			folder->order	=	order;
	}
}		/* -----  end of static function _scan_folder  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  filter_to_hash
 *  Description:  
 * =====================================================================================
 */
static GHashTable * filter_to_hash(char * filter)
{
	GHashTable * _res	=	NULL;
	char * _str;
	char * _key;

	if( filter	!=	NULL)
	{
		g_message("--->filter != NULL\n");
		_res	=	g_hash_table_new( g_str_hash, g_str_equal );
		while(( _str	=	g_strrstr( filter, ";")) != NULL )
		{
//			_key	=	g_strdup( _str + 1 );
//			_key	=	g_strdown( _key );
			_key	=	g_ascii_strdown( _str + 1, strlen( _str + 1));
			g_hash_table_insert( _res, _key, "");
			* _str	=	'\0';
			
		}
		_key	=	g_ascii_strdown( filter, strlen(filter)	);
		g_hash_table_insert( _res, _key, "");

	}

	return _res;
}		/* -----  end of static function filter_to_hash  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_children
 *  Description:
 * =====================================================================================
 */
static MHItem ** _get_children( MHFolder * self, MHFilter * filter, MHFolderPosition pos, int32_t * count, MHItemOrderType order )
{
//	g_message("_get_children:%s", MH_ITEM(self)->name);
	g_return_val_if_fail(( *count ) != 0, NULL );

	int _offset	=	0;
	int _alloc	=	AUTO_EXTENDED_FACTOR;
	GNode * _curNode;
	MHItem * _item	=	NULL;
	MHItem ** _items	=	NULL;
	GHashTable * _filter_hash	=	NULL;
	int max_file_infolder = 0;
	const char * _max_file_infolder_str	=	getenv("MH_DEV_MAX_FILE_IN_FOLDER");

	if( !MH_IS_FOLDER( self ))
	{
		* count	=	0;

		return NULL;
	}

	_max_file_infolder_str	=	_max_file_infolder_str ? _max_file_infolder_str : "0" ;
	
	max_file_infolder	=	(guint)atoi( _max_file_infolder_str);
	
	_scan_folder( self, order, max_file_infolder );

	_curNode	=	( pos == FOLDER_CUR ) ? self->curChild : MH_ITEM( self )->node->children;

	if( _curNode == NULL )
	{
		* count	=	0;
		return NULL;

	}
	
	if( * count < 0 )                           /* Get all children of this folder */
	{
		_items	=	g_new0( MHItem *, _alloc );
	}
	else
	{
		_items	=	g_new0( MHItem *, * count );
		_alloc	=	*count;
	}


	while( _curNode )
	{
		gboolean _valid	=	TRUE;

		if(( * count ) < 0 && _offset == _alloc )
		{
			_alloc	*=	2;                  /* Reduces the times of memory allocation by extend the memory to double*/
			_items	=	g_renew( MHItem *, _items, _alloc );
		}

		_item	=	MH_ITEM( _curNode->data );

		if( _item->type != MH_ITEM_FOLDER )
		{
			if( filter != NULL )
			{
				_filter_hash	=	filter->hash;
				gchar * _ext	=	g_strrstr( _item->name, "." );

				if( _ext != NULL )
				{
					_ext	=	g_ascii_strdown( _ext + 1, strlen( _ext + 1 ));

					if( g_hash_table_lookup( _filter_hash, _ext ) == NULL )
					{
						_valid	=	FALSE;
					}

					g_free( _ext );
				}
				else
				{
					_valid	=	FALSE;
				}
			}
		}
		else
		{
	//		if(_item->uniqueId	!=	0&& filter 	!=	NULL)
			if( filter != 	NULL)
			{
				MHFolder * _folder	=	MH_FOLDER( _item );
				if( filter->type == FILTER_FOLDER)
				{
					_valid	=	TRUE;
				}
				else if(	_folder->music_count != 0 && (filter->type&FILTER_MUSIC))
				{
					_valid	=	TRUE;
				}
				else if( _folder->movie_count != 0 && (filter->type&FILTER_MOVIE))
				{
					_valid	=	TRUE;
				}
				else if( _folder->picture_count != 0 && (filter->type & FILTER_PICTURE))
				{
					_valid	=	TRUE;
				}
				else if( _folder->playlist_count != 0 && (filter->type & FILTER_PLAYLIST))
				{
					_valid	=	TRUE;
				}

				else
				{
					_valid	=	FALSE;
				}
			}
		}

		_curNode	=	_curNode->next;

		self->curChild	=	_curNode;

		if( _valid )
		{
			_items[ _offset ]	=	_item;
//			g_message("%d:%s", _offset, _item->name);
			_offset	++;

			if(( * count ) > 0 && _offset == (* count ))
				break;
		}
	}
	if(_offset < _alloc)
	{
		_items[_offset]	=	NULL;
	}
	else
	{
		_items	=	g_renew( MHItem *, _items, _offset+1 );
		_items[_offset]	=	NULL;

	}
	* count	=	_offset;
	return _items;
}      /* -----  end of static function _get_children  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_playlist
 *  Description:  
 * =====================================================================================
 */
static void _add_playlist( MHPlaylist * playlist, MHFolder * self, MHFilter * filter, bool recursive)
{
	int _count = -1;
	int i = 0;
//	MHItem ** _items	=	mh_folder_get_children( self, filter, FOLDER_BEGIN, &_count, MH_ITEM_ORDER_BY_ALPHABET);
	MHItem ** _items	=	mh_folder_get_children( self, filter, FOLDER_BEGIN, &_count, MH_ITEM_ORDER_BY_DEFAULT);
	if( _items != NULL)
	{
		//g_message("%s playlist->dev->searchType = %d",__func__,playlist->dev->searchType);
		if (DEPTH_FIRST == playlist->dev->searchType)
		{
			for( i = 0; i < _count; i++)
			{
				if( _items[i]->type == MH_ITEM_FOLDER )
				{
					if( recursive == true)
					{
						_add_playlist( playlist, MH_FOLDER( _items[i]), filter, recursive);
					}

				}
				else
				{
					mh_playlist_append( playlist, &_items[i], 1);

				}
			}
		}
		else
		{
			GSList * _folder_list=NULL;
			GSList * _element=NULL;
			MHFolder * _folder=NULL;

			for( i = 0; i < _count; i++)
			{
				if( _items[i]->type == MH_ITEM_FOLDER )
				{
					if( recursive == true)
					{
						//_add_playlist( playlist, MH_FOLDER( _items[i]), filter, recursive);
						_folder	=	MH_FOLDER( _items[i]);
						_folder_list	=	g_slist_append(_folder_list, _folder);
					}

				}
				else
				{
					mh_playlist_append( playlist, &_items[i], 1);

				}
			}

			if (NULL != _folder_list)
			{
				_element	=	_folder_list;
				while(_element)
				{
					_folder	=	(MHFolder *)_element->data;
					_add_playlist( playlist, _folder, filter, recursive);
					_folder_list	=	g_slist_remove( _folder_list, _folder_list->data);
					_element	=	_folder_list;
				}
			}
		}
		g_free( _items);
	}

}		/* -----  end of static function _add_playlist  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _create_playlist
 *  Description:
 * =====================================================================================
 */
static MHPlaylist * _create_playlist( MHFolder * self, MHFilter * filter, bool recursive )
{
	int _count	=	-1;
	int _folder	=	0;

	MHPlaylist * _playlist	=	g_object_new( MH_TYPE_PLAYLIST, NULL );

	_playlist->dev	=	MH_ITEM( self )->dev;

	_add_playlist( _playlist, self, filter, recursive );

//	MHItem ** _items	=	mh_folder_get_children( self,filter, FOLDER_BEGIN, &_count, MH_ITEM_ORDER_BY_DEFAULT );
//
//
//	if( _items != NULL )
//	{
//		while( _folder < _count &&
//				_items[ _folder ]->type == MH_ITEM_FOLDER )
//		{
//			_folder	++;
//		}
//
//		if( _count > 0 )
//			mh_playlist_append( _playlist, _items + _folder, _count - _folder );
//	}
//
//	g_free( _items );
//
	return _playlist;

}      /* -----  end of static function _create_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _dup
 *  Description:  
 * =====================================================================================
 */
static MHFolder * _dup(	MHFolder * self	)
{
	MHFolder * _res	=	g_object_new( MH_TYPE_FOLDER, NULL);
	MHItem * _res_item 	=	MH_ITEM(_res);
	MHItem * _item	=	MH_ITEM( self );
	_res_item->uniqueId	=	_item->uniqueId;
	_res_item->name	=	g_strdup( _item->name);
	_res_item->size	=	_item->size;
	_res_item->type	=	_item->type;
	_res_item->dev	=	_item->dev;
	_res_item->uri	=	g_strdup( _item->uri );
	return _res;
}		/* -----  end of static function _dup  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_type_count
 *  Description:  
 * =====================================================================================
 */
static void _add_type_count(MHFolder * folder, MHItemType type)
{
	MHItem * _item;
	GNode * _node;
	MHFolder * _folder;

	_item	=	MH_ITEM( folder );
	_node	=	_item->node;

	switch( type )
	{
		case MH_ITEM_MUSIC:
			folder->music_count	=	folder->music_count + 1;
			if(folder->music_count	==	1)
			{
				if(_node->parent !=	NULL)
				{
					_folder	=	(MHFolder *)_item->node->parent->data;
					_add_type_count( _folder, type);
			//		g_signal_emit_by_name(_item->dev,"dev_events",MH_DEV_UPDATE_FILE,MH_ITEM_MUSIC, (guint)_folder,0 );
				}
				
			}
			break;
		case MH_ITEM_MOVIE:
			folder->movie_count	=	folder->movie_count + 1;
			if(folder->movie_count	==	1)
			{
				if(_node->parent !=	NULL)
				{
					_folder	=	(MHFolder *)_item->node->parent->data;
					_add_type_count( _folder, type);
		//			g_signal_emit_by_name(_item->dev,"dev_events",MH_DEV_UPDATE_FILE,MH_ITEM_MOVIE, (guint)_folder, 0 );

				}
				
			}

			break;
		case MH_ITEM_PICTURE:
			folder->picture_count = folder->picture_count + 1;
			if(folder->picture_count	==	1)
			{
				if(_node->parent !=	NULL)
				{
					_folder	=	(MHFolder *)_item->node->parent->data;
					_add_type_count( _folder, type);
		//			g_signal_emit_by_name(_item->dev,"dev_events",MH_DEV_UPDATE_FILE,MH_ITEM_PICTURE, (guint)_folder, 0 );

				}
				
			}

			break;
		case MH_ITEM_PLAYLIST:
			folder->playlist_count	=	folder->playlist_count + 1;
			if(folder->playlist_count == 1)
			{
				if(_node->parent != NULL)
				{
					_folder	=	(MHFolder *) _item->node->parent->data;
					_add_type_count( _folder, type);
			//		g_signal_emit_by_name(_item->dev,"dev_events",MH_DEV_UPDATE_FILE,MH_ITEM_PLAYLIST, (guint)_folder, 0 );

				}
			}
			break;
	}

}		/* -----  end of static function _add_type_count  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _del_type_count
 *  Description:  
 * =====================================================================================
 */
static void _del_type_count(MHFolder * folder, MHItemType type)
{
	MHItem * _item;
	GNode * _node;
	MHFolder * _folder;

	_item	=	MH_ITEM( folder );
	_node	=	_item->node;

	switch( type )
	{
		case MH_ITEM_MUSIC:
			folder->music_count	=	folder->music_count - 1;
			if(folder->music_count	==	0)
			{
				if(_node->parent !=	NULL)
				{
					_folder	=	(MHFolder *)_item->node->parent->data;
					_del_type_count( _folder, type);
		//			g_signal_emit_by_name(_item->dev,"dev_events",MH_DEV_UPDATE_FILE,MH_ITEM_MUSIC, (guint)_folder, 0);
				}
				
			}
			break;
		case MH_ITEM_MOVIE:
			folder->movie_count	=	folder->movie_count - 1;
			if(folder->movie_count	==	0)
			{
				if(_node->parent !=	NULL)
				{
					_folder	=	(MHFolder *)_item->node->parent->data;
					_del_type_count( _folder, type);
		//			g_signal_emit_by_name(_item->dev,"dev_events",MH_DEV_UPDATE_FILE,MH_ITEM_MOVIE, (guint)_folder, 0);
				}
				
			}

			break;
		case MH_ITEM_PICTURE:
			folder->picture_count = folder->picture_count - 1;
			if(folder->picture_count	==	0)
			{
				if(_node->parent !=	NULL)
				{
					_folder	=	(MHFolder *)_item->node->parent->data;
					_del_type_count( _folder, type);
		//			g_signal_emit_by_name(_item->dev,"dev_events",MH_DEV_UPDATE_FILE,MH_ITEM_PICTURE, (guint)_folder, 0);
				}
				
			}

			break;
		case MH_ITEM_PLAYLIST:
			folder->playlist_count = folder->playlist_count - 1;
			if(folder->playlist_count	==	0)
			{
				if(_node->parent !=	NULL)
				{
					_folder	=	(MHFolder *)_item->node->parent->data;
					_del_type_count( _folder, type);
		//			g_signal_emit_by_name(_item->dev,"dev_events",MH_DEV_UPDATE_FILE,MH_ITEM_PLAYLIST, (guint)_folder, 0);
				}
				
			}

			break;

	}
}		/* -----  end of static function _del_type_count  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _seek
 *  Description:  
 * =====================================================================================
 */
static void _seek(MHFolder * folder, MHFilter * filter, int32_t pos,MHItemOrderType order)
{

	GNode * _curNode;
	MHItem * _item;
	GHashTable * _filter_hash = NULL;
	gchar * _ext	=	NULL;
	gboolean _valid	=	TRUE;
	int max_file_infolder = 0;
	const char * _max_file_infolder_str	=	getenv("MH_DEV_MAX_FILE_IN_FOLDER");

	_max_file_infolder_str	=	_max_file_infolder_str ? _max_file_infolder_str : "0" ;
	
	max_file_infolder	=	(guint)atoi( _max_file_infolder_str);
	
	_scan_folder( folder, order, max_file_infolder );

	_curNode	=	MH_ITEM( folder )->node->children;
	if( _curNode == NULL)
	{
		return;
	}
	while( _curNode )	
	{
		_item	=	MH_ITEM(_curNode->data);
		if( _item->type != MH_ITEM_FOLDER)
		{
			if( filter != NULL)
			{
				_filter_hash 	=	filter->hash;
				_ext	=	g_strrstr( _item->name, ".");
				if( _ext	!=	NULL)
				{
					_ext	=	g_ascii_strdown( _ext + 1, strlen(_ext + 1 ));
					if( g_hash_table_lookup( _filter_hash, _ext ) == NULL)
					{
						_valid	=	FALSE;
					}
					g_free( _ext);
				}

			}
		}
		else
		{
//			if(_item->uniqueId	!=	0&& filter 	!=	NULL)
			if( filter !=	NULL)
			{
				MHFolder * _folder	=	MH_FOLDER( _item );

				if(	_folder->music_count != 0 && (filter->type&FILTER_MUSIC))
				{
					_valid	=	TRUE;
				}
				else if( _folder->movie_count != 0 && (filter->type&FILTER_MOVIE))
				{
					_valid	=	TRUE;
				}
				else if( _folder->picture_count != 0 && (filter->type & FILTER_PICTURE))
				{
					_valid	=	TRUE;
				}
				else if( _folder->playlist_count != 0 && (filter->type & FILTER_PLAYLIST))
				{
					_valid	=	TRUE;
				}
				else
				{
					_valid	=	FALSE;
				}
			}

		}
		folder->curChild	=	_curNode;
		_curNode	=	_curNode->next;
		if( _valid )
		{
			pos--;
			if(pos	<	0)
				break;
		}
	}
	return ;
}		/* -----  end of static function _seek  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_dispose
 *  Description:
 * =====================================================================================
 */
static void _dispose( GObject * object )
{
	MHFolder * _self	=	MH_FOLDER( object );
	if( _self->hash !=	NULL)
	{
		g_hash_table_destroy( _self->hash );
	}

	G_OBJECT_CLASS( mh_folder_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_finalize
 *  Description:
 * =====================================================================================
 */
static void _finalize( GObject * object )
{
	MHFolder * _self	=	MH_FOLDER( object );
	MHFolderPrivate * _priv	=	mh_folder_get_instance_private( _self );

	G_OBJECT_CLASS( mh_folder_parent_class )->finalize( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_property
 *  Description:
 * =====================================================================================
 */
static void _get_property( GObject * object, guint property_id, GValue * value,
		        GParamSpec * spec)
{
	MHFolder * _self  =   MH_FOLDER( object );

	switch( property_id )
	{
	case PROP_FOLDER_MUSIC_FILE_COUNT:
		g_value_set_uint( value, _self->music_count);
		break;
		
	case PROP_FOLDER_MOVIE_FILE_COUNT:
		g_value_set_uint( value, _self->movie_count);
		break;
	default:
		break;
	}
}       /*  -----  end of static function _get_property  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_init
 *  Description:
 * =====================================================================================
 */
static void mh_folder_init( MHFolder * self )
{
	MHFolderPrivate * _priv	=	mh_folder_get_instance_private( self );
	MHItem * _item	=	MH_ITEM( self );
	//g_message("%s self = %p",__func__,self);
	_item->type	=	MH_ITEM_FOLDER;
	self->order	=	MH_ITEM_ORDER_BY_DEFAULT;
	self->music_count	=	0;
	self->movie_count	=	0;
	self->picture_count	=	0;
	self->playlist_count=	0;
}       /* -----  end of static function mh_folder_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_folder_class_init( MHFolderClass * klass )
{
	MHItemClass * _parentClass	=	MH_ITEM_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	_dispose;
	_gobjectClass->finalize	=	_finalize;
	_gobjectClass->get_property =   _get_property;

	/* assemble ios of mh_folder class */

	/* assemble methods of mh_folder class */
	klass->get_children	=	_get_children;
	klass->create_playlist	=	_create_playlist;
	klass->dup	=	_dup;
	klass->add_type_count	=	_add_type_count;
	klass->del_type_count	=	_del_type_count;
	klass->seek				=	_seek;
	/* Ios */
	/* Signals */
	folderProperties[ PROP_FOLDER_MUSIC_FILE_COUNT] =
	g_param_spec_uint( "music_count", "MHFolder's property", "file count of music",
			0, G_MAXUINT, 0, G_PARAM_READABLE );

	folderProperties[ PROP_FOLDER_MOVIE_FILE_COUNT] =
	g_param_spec_uint( "movie_count", "MHFolder's property", "file count of movie",
			0, G_MAXUINT, 0, G_PARAM_READABLE );

	g_object_class_install_properties( _gobjectClass, N_PROPERTIES, folderProperties );
}       /* -----  end of static function mh_folder_class_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_get_children
 *  Description:
 * =====================================================================================
 */
MHItem ** mh_folder_get_children( MHFolder * self, MHFilter * filter, MHFolderPosition pos, int32_t * count, MHItemOrderType type )
{
//	g_message("%s pos:%d, count:%d", __func__, pos, *count);
	g_return_val_if_fail( MH_IS_FOLDER( self ), NULL);
	if( MH_FOLDER_GET_CLASS( self )->get_children != NULL )
	{
		return MH_FOLDER_GET_CLASS( self )->get_children( self, filter, pos, count, type );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHFolderClass::get_children()'",
				G_OBJECT_TYPE_NAME( self ));

		* count	=	0;
	}

	return NULL;
}		/* -----  end of function mh_folder_get_children  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_create_playlist
 *  Description:  
 * =====================================================================================
 */
MHPlaylist * mh_folder_create_playlist( MHFolder * self, MHFilter * filter, bool recursive )
{
	g_message("%s recursive:%d", __func__, recursive);
	g_return_val_if_fail( MH_IS_FOLDER( self ), NULL);

	if( MH_FOLDER_GET_CLASS( self )->create_playlist != NULL )
	{
		return MH_FOLDER_GET_CLASS( self )->create_playlist( self, filter, recursive );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHFolderClass::create_playlist()'",
				G_OBJECT_TYPE_NAME( self ));
	}

		return NULL;
}		/* -----  end of function mh_folder_create_playlist  ----- */

bool mh_folder_get_properties( MHFolder * self, const char * first_property_name, ... )
{
	g_message("%s", __func__);
	va_list _varArgs;

	g_return_val_if_fail( MH_IS_FOLDER( self ), false );

	va_start( _varArgs, first_property_name );

	g_object_get_valist( G_OBJECT( self ), first_property_name, _varArgs );

	va_end( _varArgs );

	return true;

}
bool mh_folder_set_properties( MHFolder * self, const char * first_property_name, ... )
{
	g_message("%s", __func__);
	va_list _varArgs;

	g_return_val_if_fail( MH_IS_FOLDER( self ), false );

	va_start( _varArgs, first_property_name );

	g_object_set_valist( G_OBJECT( self ), first_property_name, _varArgs );

	va_end( _varArgs );

	return true;

}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_dup
 *  Description:  
 * =====================================================================================
 */
MHFolder * mh_folder_dup(MHFolder * self )
{
	g_message("%s", __func__);
	g_return_val_if_fail( MH_IS_FOLDER( self ), NULL);

	if( MH_FOLDER_GET_CLASS( self )->dup != NULL )
	{
		return MH_FOLDER_GET_CLASS( self )->dup( self);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHFolderClass::dup()'",
				G_OBJECT_TYPE_NAME( self ));
	}

	return NULL;
}		/* -----  end of function mh_folder_dup  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_add_type_count
 *  Description:  
 * =====================================================================================
 */
void mh_folder_add_type_count(MHFolder * self, MHItemType type)
{
	g_return_if_fail( MH_IS_FOLDER( self ));

	if( MH_FOLDER_GET_CLASS( self )->add_type_count != NULL )
	{
		MH_FOLDER_GET_CLASS( self )->add_type_count( self,type);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHFolderClass::add_type_count()'",
				G_OBJECT_TYPE_NAME( self ));
	}

}		/* -----  end of function mh_folder_add_type_count  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_del_type_count
 *  Description:  
 * =====================================================================================
 */
void mh_folder_del_type_count( MHFolder * self, MHItemType type)
{
	g_return_if_fail( MH_IS_FOLDER( self ));

	if( MH_FOLDER_GET_CLASS( self )->del_type_count != NULL )
	{
		MH_FOLDER_GET_CLASS( self )->del_type_count( self,type);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHFolderClass::del_type_count()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_folder_del_type_count  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_folder_seek
 *  Description:  
 * =====================================================================================
 */
MHResult mh_folder_seek( MHFolder * self, MHFilter * filter, int32_t pos, MHItemOrderType order)
{
	g_message("%s pos:%d, order:%d", __func__, pos, order);
	g_return_val_if_fail( MH_IS_FOLDER( self ), MH_INVALID_PARAM);
		
	MHResult _res	=	MH_OK;

	if( MH_FOLDER_GET_CLASS( self )->seek != NULL )
	{
		MH_FOLDER_GET_CLASS( self )->seek( self, filter, pos,order);
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHFolderClass::seek()'",
				G_OBJECT_TYPE_NAME( self ));
		_res	=	MH_FUNC_NOT_IMPLEMENT;
	}
	return _res;
}		/* -----  end of function mh_folder_seek  ----- */
