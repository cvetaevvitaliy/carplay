/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include <mh_player.h>
#include <string.h>
#include <mh_core.h>
#include <mh_pb.h>
#include <mh_dev.h>
#include <gst/app/gstappsrc.h>
#include <alsa/asoundlib.h>

#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
#include <sys/time.h>
#include <iconv.h>
#define DEBUG_TIME_BEGIN() \
{ \
	struct timeval _start = {0, 0}, _current = {0, 0}, _result = {0, 0}; \
	float _max = 0, _min = 10000, _avg = 0; \
	int count = 0; \
	float _tmp; \
	printf("**********TIME MEASURING BEGIN**********\n");

#define DEBUG_TIME_DUR_BEGIN() \
	gettimeofday(&_start, NULL);

#define DEBUG_TIME_DUR_END() \
	gettimeofday(&_current, NULL); \
	timersub(&_current, &_start, &_result); \
	{ \
		_tmp    =   _result.tv_sec + (float)_result.tv_usec / 1000000; \
		if(_tmp > _max) _max =   _tmp; \
		if(_tmp < _min) _min =   _tmp; \
		_avg    +=  (_tmp - _avg) / ( ++ count); \
		fprintf(stdout, "***CNT:%d MAX:%03fs MIN:%03fs AVG:%03fs CUR:%03f\n", count, _max, _min, _avg, _tmp); \
	}

#define DEBUG_TIME_END() \
	printf("***********TIME MEASURING END (%d)***********\n", count); \
}


#define FASTNULL 0
#define FORWORD  1
#define BACKWORD 2

#define FORWORD_PLAYTIME        (1000)
#define BACKWORD_PLAYTIME       (1000)

typedef struct _MHPlayerPrivate MHPlayerPrivate;

struct _MHPlayerPrivate
{
	GstBus * bus;
	GstBus * bus_mpeg4;
	gboolean bmute;
	gint64 duration;
	gdouble volume;
	GMainLoop * g_main_loop;
	GMainContext * context;
	gint watchid;
	gint watchid_mpeg4;
	GThread * g_main_loop_thread;
	GMutex	context_id_mutex;
	GSource * time_source;
	guint time_source_start;
	gint64 stream_length;
 	gint current_time;
	char * mrl;
	char * old_mrl;
	MHPlayerMetadata metadata_info;
	gint64	fast_elapsed_timer;
	guint	fast_playtime; 
	guint	fast_id;
	guint   fast_interval;
	guint   sfast_interval;
	guint	fast_direction;   /*  1:forward, 2:backward */ 
	guint	fast_play_flag;   /*  1:no play, 2:play */
	GstElement * video_sink;
	GstElement * audio_sink;
	gint disp_x;
	gint disp_y;
	gint disp_width;
	gint disp_height;
	gint pixel_n;
	gint pixel_d;
};

typedef enum {
	GST_PLAY_FLAG_VIDEO         = (1 << 0),
	GST_PLAY_FLAG_AUDIO         = (1 << 1),
	GST_PLAY_FLAG_TEXT          = (1 << 2),
	GST_PLAY_FLAG_VIS           = (1 << 3),
	GST_PLAY_FLAG_SOFT_VOLUME   = (1 << 4),
	GST_PLAY_FLAG_NATIVE_AUDIO  = (1 << 5),
	GST_PLAY_FLAG_NATIVE_VIDEO  = (1 << 6),
	GST_PLAY_FLAG_DOWNLOAD      = (1 << 7),
	GST_PLAY_FLAG_BUFFERING     = (1 << 8),
	GST_PLAY_FLAG_DEINTERLACE   = (1 << 9)
} GstPlayFlags;

G_DEFINE_TYPE_WITH_PRIVATE( MHPlayer, mh_player, MH_TYPE_IO )

enum {
	/* Ios */

	/* Signals */
	PLAYER_EVENT,

	N_SIGNALS
};

typedef struct _media_data
{
	MHPb * pb;
	guint type;
	void * user_data;
} media_data;				/* ----------  end of struct media_data  ---------- */

static guint signals[ N_SIGNALS ] = {0};

/*
 * ===  FUNCTION  ======================================================================
 *         Name: main_loop_thread
 *  Description:
 * =====================================================================================
 */
void main_loop_thread(gpointer data)
{
	if(data)
	{
		MHPlayer* _mh_player = ( MHPlayer * )data;
	//	MHPlayerPrivate * _priv = ( MHPlayerPrivate * )_mh_player->property_handle;
		MHPlayerPrivate * _priv	=	mh_player_get_instance_private( _mh_player );
		if( _priv->g_main_loop )
		{   
			GMainLoop *loop =  g_main_loop_ref( _priv->g_main_loop );
			GMainContext *context = g_main_loop_get_context(loop);
			while (g_main_loop_is_running(loop))
			{
				while (g_main_context_iteration (context, FALSE));
				usleep(10000);
			}
			g_main_loop_unref(loop);
		}
	}
}      /* -----  end of static function main_loop_thread  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_source
 *  Description:
 * =====================================================================================
 */
static void _set_source( MHPlayer * self, gpointer name )
{

	//Method default implement.
	//g_assert_not_reached();
}      /* -----  end of static function _set_source  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: _state_change
 *  Description:
 * =====================================================================================
 */
static gboolean _state_change(GstState sRecState, GstElement * elem)
{
    GstStateChangeReturn _result = GST_STATE_CHANGE_FAILURE;
	GstState _current;
	gchar * _ele_name = gst_element_get_name( elem );
	_result = gst_element_set_state( elem, sRecState );
	if(_result == GST_STATE_CHANGE_FAILURE)
	{
		if( NULL != _ele_name )
		{
			g_free( _ele_name );
		}
		return FALSE;
	}
	int _count = 0;
	while( TRUE )
	{
		if (gst_element_get_state( elem, &_current, NULL, GST_SECOND)!=GST_STATE_CHANGE_FAILURE)
		{
			if( sRecState == _current || _current == GST_STATE_NULL )
			{
				break;
			}
			if( _count == 3)
			{
				if( NULL != _ele_name )
				{
					g_free( _ele_name );
				}
				return FALSE;
			}
			usleep( 1000000 );

			_count	++;
		}else{
			return FALSE;
		}
	}
	if( NULL != _ele_name )
	{
		g_free( _ele_name );
	}
	return TRUE;
}      /* -----  end of static function _state_change  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_video_sink
 *  Description:
 * =====================================================================================
 */
static gboolean _set_video_sink( MHPlayer * self, gpointer name )
{
	gboolean _result = FALSE;
	gboolean _ret = FALSE;
	char * video_sink_name = ( char * )name;

	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	_ret = _state_change( GST_STATE_READY, GST_ELEMENT( self->playbin2 ));

	if( _ret == FALSE )
	{
		g_message("try to ready failed\n");
		return _ret;
	}else{
		g_message("try to ready success\n");
	}

	g_message("video_sink_name = [%s]\n",video_sink_name);

	_priv->video_sink = gst_element_factory_make( video_sink_name, NULL );

	if( _priv->video_sink != NULL )
	{
		g_object_set( self->playbin2, "video-sink", _priv->video_sink, NULL);

		return TRUE;
	}

	return _result;
}      /* -----  end of static function _set_video_sink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_audio_sink
 *  Description:
 * =====================================================================================
 */
static void _set_audio_sink( MHPlayer * self, gpointer name )
{

	//Method default implement.
	//g_assert_not_reached();
}      /* -----  end of static function _set_audio_sink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_track_info
 *  Description:
 * =====================================================================================
 */
static MHPbTrackInfo * _get_track_info( MHPlayer * self )
{
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( self );
	
	gint i;
	gchar *str;
	GstTagList *tags;

	MHPbTrackInfo	* _info	=	(MHPbTrackInfo *)g_malloc0(sizeof( MHPbTrackInfo));

	g_object_get( G_OBJECT( self->playbin2 ), "n-audio", &_info->total_count, NULL );
	g_object_get( G_OBJECT( self->playbin2 ), "current-audio", &_info->current_count, NULL );
	
	_info->track_name	=	g_new0( char *, _info->total_count );

	for ( i = 0; i < _info->total_count; i++ ) 
	{  
		tags = NULL;  
		/*  Retrieve the stream's audio tags */  
		g_signal_emit_by_name ( self->playbin2, "get-audio-tags", i, &tags );  

		if ( tags ) 
		{  
			if ( gst_tag_list_get_string ( tags, GST_TAG_LANGUAGE_CODE, &str )) 
			{  
				g_message ("  language: %s\n", str);  
				_info->track_name[i] =	g_strdup( str );
				g_free (str);  
			}  

			gst_tag_list_free (tags);  
		}  
	}

	return _info;
}      /* -----  end of static function _get_track_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_subtitle_info
 *  Description:
 * =====================================================================================
 */
static MHPbSubtitleInfo * _get_subtitle_info( MHPlayer * self )
{
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( self );

	gint i;
	gchar *str;
	GstTagList *tags;

	MHPbSubtitleInfo	* _info	=	(MHPbSubtitleInfo *)g_malloc0(sizeof( MHPbSubtitleInfo));

	g_object_get( G_OBJECT( self->playbin2 ), "n-text", &_info->total_count, NULL );
	g_object_get( G_OBJECT( self->playbin2 ), "current-text", &_info->current_count, NULL );
	
	_info->subtitle_name	=	g_new0( char *, _info->total_count );

	g_message("total_count = %d, current_count	=	%d\n",_info->total_count,_info->current_count);

	for (i = 0; i < _info->total_count; i++) {  
		tags = NULL;  
		/*  Retrieve the stream's audio tags */  
		g_signal_emit_by_name ( self->playbin2, "get-text-tags", i, &tags );  

		if (tags) {  

			if (gst_tag_list_get_string (tags, GST_TAG_LANGUAGE_CODE, &str)) {  
				g_message ("  language: %s\n", str);  
				_info->subtitle_name[i] =	g_strdup( str );
				g_free (str);  
			}  

			gst_tag_list_free (tags);  
		}else{
			g_message(" no tags found\n");
		}
	}

	return _info;
}      /* -----  end of static function _get_subtitle_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_audio_track
 *  Description:
 * =====================================================================================
 */
static gboolean _set_audio_track( MHPlayer * self, guint track )
{
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( self );
	gint _current_audio_index = -1;
	gint _total_audio_number = 0;

	GstTagList *tags;

	g_object_get( G_OBJECT( self->playbin2 ), "n-audio", &_total_audio_number, NULL );
	g_object_get( G_OBJECT( self->playbin2 ), "current-audio", &_current_audio_index, NULL );

	g_message(" _total_audio_number = [%d] _current_audio_index = [%d]\n",_total_audio_number,_current_audio_index);

	if( track != _current_audio_index )
	{
		gint _flags;

		g_object_get( G_OBJECT( self->playbin2 ), "flags", &_flags, NULL );

		if( !( _flags & GST_PLAY_FLAG_AUDIO ))
		{
			_flags |= GST_PLAY_FLAG_AUDIO;
		}

		g_object_set( G_OBJECT( self->playbin2 ),"flags", _flags, "current-audio", track, NULL);

		g_object_get( G_OBJECT( self->playbin2 ), "current-audio", &_current_audio_index, NULL );

		g_signal_emit_by_name( G_OBJECT( self->playbin2), "get-audio-tags", track, &tags);

		g_message( "_current_audio_index	=	[%d]\n",_current_audio_index);
		
		gint64 position;  

		GstFormat format = GST_FORMAT_TIME;  

		if (gst_element_query_position ( self->playbin2, format, &position)) 
		{
			g_message("position	=	[%lld]\n",(long long int)position);	

			GstSeekFlags _seek_flags = GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE;

			GstEvent *_seek_event = NULL;

			_seek_event = gst_event_new_seek( 1.0, GST_FORMAT_TIME,
					_seek_flags,
					GST_SEEK_TYPE_SET,position,
					GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE );

			if( gst_element_send_event( self->playbin2, _seek_event ) == FALSE)
			{
				g_message( " Seek Failer: send seek event failed!\n" );
				return FALSE;
			}
		}
	}
	return TRUE;
}      /* -----  end of static function _set_audio_track  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  set_media_info
 *  Description:
 * =====================================================================================
 */
static gboolean set_media_info( gpointer user_data )
{
	media_data * _data = ( media_data * )user_data;

	if( _data->pb != NULL )
	mh_dev_set_media_info( _data->pb->mhDev, _data->pb, _data->type, _data->user_data );

	return FALSE;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_media_info
 *  Description:
 * =====================================================================================
 */
static void _set_media_info( MHPlayer * self, MHPb * pb, guint type, void * user_data )
{
	GSource * _source	=	g_idle_source_new();

	media_data * _data = g_new( media_data, 1 );
	_data->pb	=	pb;
	_data->type	=	type;
	_data->user_data	=	user_data;

	g_source_set_callback( _source, set_media_info, ( gpointer )_data, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}      /* -----  end of static function _set_media_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_subtitle
 *  Description:
 * =====================================================================================
 */
static gboolean _set_subtitle( MHPlayer * self, guint subtitle )
{
	GstTagList *tags;

	gint _flags, _total_number, _current_number;

	g_object_get( G_OBJECT( self->playbin2 ), "n-text", &_total_number, NULL );

	g_object_get( G_OBJECT( self->playbin2 ), "current-text", &_current_number, NULL );	

	g_message("_total_number	=	[%d], _current_number	=	[%d]\n", _total_number, _current_number );

	if( subtitle !=	_current_number )
	{
		g_object_get( G_OBJECT( self->playbin2 ), "flags", &_flags, NULL );

		if( !( _flags & GST_PLAY_FLAG_TEXT ))
		{
			_flags |= GST_PLAY_FLAG_TEXT;
		}

		g_object_set( G_OBJECT( self->playbin2 ),"flags", _flags, "current-text", subtitle, NULL);

		g_object_get( G_OBJECT( self->playbin2 ), "current-text", &subtitle, NULL);	

		g_signal_emit_by_name( G_OBJECT( self->playbin2), "get-text-tags", subtitle, &tags);
	}

	return TRUE;
}      /* -----  end of static function _set_subtitle  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_intvaltime
 *  Description:
 * =====================================================================================
 */
static gboolean _set_intvaltime( MHPlayer * self, guint intvaltime )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );
	
	_priv->sfast_interval = intvaltime;

	return TRUE;
}      /* -----  end of static function _set_intvaltime  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  is_isink
 *  Description:
 * =====================================================================================
 */
static gboolean is_isink( GstElement * video_sink )
{
	gchar * _ele_name = NULL;
	gboolean _result = FALSE;

	_ele_name = gst_element_get_name( video_sink );

	if( g_strrstr( _ele_name, "isink" )) 
	{
		_result = TRUE;
	}

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result;
}      /* -----  end of static function is_isink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  is_glimagesink
 *  Description:
 * =====================================================================================
 */
static gboolean is_glimagesink( GstElement * video_sink )
{
	gchar * _ele_name = NULL;
	gboolean _result = FALSE;

	_ele_name = gst_element_get_name( video_sink );

	if( g_strrstr( _ele_name, "glimagesink" )) 
	{
		_result = TRUE;
	}

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result;
}      /* -----  end of static function is_glimagesink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  is_v4l2sink
 *  Description:
 * =====================================================================================
 */
static gboolean is_v4l2sink( GstElement * video_sink )
{
	gchar * _ele_name = NULL;
	gboolean _result = FALSE;

	_ele_name = gst_element_get_name( video_sink );

	if( g_strrstr( _ele_name, "v4l2sink" )) 
	{
		_result = TRUE;
	}

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result;
}      /* -----  end of static function is_v4l2sink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  is_mfxsink
 *  Description:
 * =====================================================================================
 */
static gboolean is_mfxsink( GstElement * video_sink )
{
	gchar * _ele_name = NULL;
	gboolean _result = FALSE;

	_ele_name = gst_element_get_name( video_sink );

	if( g_strrstr( _ele_name, "mfxsink" )) 
	{
		_result = TRUE;
	}

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result;
}      /* -----  end of static function is_mfxsink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  update_mfw_isink_size
 *  Description:
 * =====================================================================================
 */
static gboolean update_mfw_isink_size( MHPlayer * self, GstElement * video_sink, gint offsetx, gint offsety, gint width, gint height )
{
	gboolean _result = TRUE;
	gint _offsetx = 0;
	gint _offsety = 0;
	gint _disp_width = 0;
	gint _disp_height = 0;

	MHPlayerPrivate * _priv =   mh_player_get_instance_private( self );

	gchar * _ele_name = gst_element_get_name( video_sink );

	g_object_get( G_OBJECT( video_sink ), "axis-left", &_offsetx, NULL );
	g_object_get( G_OBJECT( video_sink ), "axis-top", &_offsety, NULL );
	g_object_get( G_OBJECT( video_sink ), "disp-width", &_disp_width, NULL );
	g_object_get( G_OBJECT( video_sink ), "disp-height", &_disp_height, NULL );

	if(( _priv->disp_x != offsetx ) || ( _priv->disp_y != offsety ) 
			|| ( _priv->disp_width != width ) || ( _priv->disp_height != height )) 
	{
		gint _cnt = 0;
		gint _paraset;

		_priv->disp_x = offsetx;
		_priv->disp_y = offsety;
		_priv->disp_width = width;
		_priv->disp_height = height;

		g_object_set( G_OBJECT( video_sink ),
				"axis-left", _priv->disp_x,
				"axis-top", _priv->disp_y,
				"disp-width", _priv->disp_width,
				"disp-height", _priv->disp_height,
				NULL );

		g_object_set( G_OBJECT( video_sink ), "disp-config", 1, NULL );
		g_object_get( G_OBJECT( video_sink ), "disp-config", &_paraset, NULL );

		while(( _paraset ) && _cnt < 100 ) 
		{
			usleep( 20000 );
			_cnt++;
			g_object_get( G_OBJECT( video_sink ), "disp-config", &_paraset, NULL );
		}

		if( _cnt >= 100 ) 
		{
			g_message( "%s(): reconfig %s failure!\n",__func__, _ele_name );
			_result = false;
		}else {
			g_message( "%s(): reconfig %s successfully!\n",__func__, _ele_name );
		}

		g_object_get( G_OBJECT( video_sink ), "axis-left", &_offsetx, NULL );
		g_object_get( G_OBJECT( video_sink ), "axis-top", &_offsety, NULL );
		g_object_get( G_OBJECT( video_sink ), "disp-width", &_disp_width, NULL );
		g_object_get( G_OBJECT( video_sink ), "disp-height", &_disp_height, NULL );
	}

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result ;
}      /* -----  end of static function update_mfw_isink_size  ----- */
	
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  update_mfw_isink_pixel_aspect_ratio
 *  Description:
 * =====================================================================================
 */
static gboolean update_mfw_isink_pixel_aspect_ratio( MHPlayer * self, GstElement * video_sink, gint pixel_n, gint pixel_d )
{
	gboolean _result = TRUE;
	gint _pixel_n = 0;
	gint _pixel_d = 0;

	MHPlayerPrivate * _priv =   mh_player_get_instance_private( self );

	gchar * _ele_name = gst_element_get_name( video_sink );

	g_object_get( G_OBJECT( video_sink ), "pixel-aspect-ratio", &_pixel_n, &_pixel_d, NULL );


	if(( _priv->pixel_n != pixel_n ) || ( _priv->pixel_d != pixel_d )) 
	{

		_priv->pixel_n = pixel_n;
		_priv->pixel_d = pixel_d;


		g_object_set( G_OBJECT( video_sink ),
				"pixel-aspect-ratio", _priv->pixel_n, _priv->pixel_d,
				NULL );

	}

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result ;
}      /* -----  end of static function update_mfw_isink_pixel_aspect_ratio  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  update_glimagesink_size
 *  Description:
 * =====================================================================================
 */
static gboolean update_glimagesink_size( MHPlayer * self, GstElement * video_sink, gint offsetx, gint offsety, gint width, gint height )
{
	gboolean _result = TRUE;
	gint _offsetx = 0;
	gint _offsety = 0;
	gint _disp_width = 0;
	gint _disp_height = 0;
	MHPlayerPrivate * _priv =   mh_player_get_instance_private( self );

	gchar * _ele_name = gst_element_get_name( video_sink );

	/*  glimagesink window_x=0 window_y=0 window_width=768 window_height=424 window_layer=1 force-aspect-ratio=true */
	g_object_get( G_OBJECT( video_sink ), "window_x", &_offsetx, NULL );
	g_object_get( G_OBJECT( video_sink ), "window_y", &_offsety, NULL );
	g_object_get( G_OBJECT( video_sink ), "window_width", &_disp_width, NULL );
	g_object_get( G_OBJECT( video_sink ), "window_height", &_disp_height, NULL );

	_priv->disp_x = offsetx;
	_priv->disp_y = offsety;
	_priv->disp_width = width;
	_priv->disp_height = height;

	g_object_set(G_OBJECT( video_sink ),
			"window_x", _priv->disp_x,
			"window_y", _priv->disp_y,
			"window_width", _priv->disp_width,
			"window_height", _priv->disp_height,
			NULL );

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result ;
}      /* -----  end of static function update_glimagesink_size  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  update_v4l2sink_size
 *  Description:
 * =====================================================================================
 */
static gboolean update_v4l2sink_size( MHPlayer * self, GstElement * video_sink, gint offsetx, gint offsety, gint width, gint height )
{
	gboolean _result = TRUE;
	gint _offsetx = 0;
	gint _offsety = 0;
	gint _disp_width = 0;
	gint _disp_height = 0;
	MHPlayerPrivate * _priv =   mh_player_get_instance_private( self );

	gchar * _ele_name = gst_element_get_name( video_sink );

	g_object_get( G_OBJECT( video_sink ), "overlay-set-left", &_offsetx, NULL );
	g_object_get( G_OBJECT( video_sink ), "overlay-set-top", &_offsety, NULL );
	g_object_get( G_OBJECT( video_sink ), "overlay-set-width", &_disp_width, NULL );
	g_object_get( G_OBJECT( video_sink ), "overlay-set-height", &_disp_height, NULL );
	g_message(" get %s offsetx = %d, offsety = %d, width = %d, height = %d",__func__,_offsetx,_offsety,_disp_width,_disp_height);

	_priv->disp_x = offsetx;
	_priv->disp_y = offsety;
	_priv->disp_width = width;
	_priv->disp_height = height;
	g_message("set %s offsetx = %d, offsety = %d, width = %d, height = %d",__func__,offsetx,offsety,width,height);

	g_object_set(G_OBJECT( video_sink ),
			"overlay-set-left", _priv->disp_x,
			"overlay-set-top", _priv->disp_y,
			"overlay-set-width", _priv->disp_width,
			"overlay-set-height", _priv->disp_height,
			"overlay-set-update", 1,
			NULL );

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result ;
}      /* -----  end of static function update_v4l2sink_size  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  update_v4l2sink_pixel_aspect_ratio
 *  Description:
 * =====================================================================================
 */
static gboolean update_v4l2sink_pixel_aspect_ratio( MHPlayer * self, GstElement * video_sink, gint pixel_n, gint pixel_d )
{
	gboolean _result = TRUE;
//	gint _pixel_n = 0;
//	gint _pixel_d = 0;

	MHPlayerPrivate * _priv =   mh_player_get_instance_private( self );

	gchar * _ele_name = gst_element_get_name( video_sink );

//	g_object_get( G_OBJECT( video_sink ), "aspectratio", &_pixel_n, NULL );


	_priv->pixel_n = pixel_n;
	_priv->pixel_d = pixel_d;

	g_message("%s pixel_n = %d,pixel_d = %d",__func__,pixel_n,pixel_d);
	g_object_set(G_OBJECT( video_sink ),"aspectratio", _priv->pixel_n, NULL );

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}
	
	return _result ;
}      /* -----  end of static function update_v4l2sink_pixel_aspect_ratio  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  update_glimagesink_pixel_aspect_ratio
 *  Description:
 * =====================================================================================
 */
static gboolean update_glimagesink_pixel_aspect_ratio( MHPlayer * self, GstElement * video_sink, gint pixel_n, gint pixel_d )
{
	gboolean _result = TRUE;
	gint _pixel_n = 0;
	gint _pixel_d = 0;

	MHPlayerPrivate * _priv =   mh_player_get_instance_private( self );

	gchar * _ele_name = gst_element_get_name( video_sink );

	g_object_get( G_OBJECT( video_sink ), "pixel-aspect-ratio", &_pixel_n, &_pixel_d, NULL );


	_priv->pixel_n = pixel_n;
	_priv->pixel_d = pixel_d;

	g_message("%s pixel_n = %d,pixel_d = %d",__func__,pixel_n,pixel_d);
	g_object_set(G_OBJECT( video_sink ),
			"pixel-aspect-ratio", _priv->pixel_n, _priv->pixel_d,
			NULL );

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result ;
}      /* -----  end of static function update_glimagesink_pixel_aspect_ratio  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  update_mfxsink_pixel_aspect_ratio
 *  Description:
 * =====================================================================================
 */
static gboolean update_mfxsink_pixel_aspect_ratio( MHPlayer * self, GstElement * video_sink, gint pixel_n, gint pixel_d )
{
	gboolean _result = TRUE;
	gint _pixel_n = 0;
	gint _pixel_d = 0;

	MHPlayerPrivate * _priv =   mh_player_get_instance_private( self );

	gchar * _ele_name = gst_element_get_name( video_sink );

	g_object_get( G_OBJECT( video_sink ), "pixel-aspect-ratio", &_pixel_n, &_pixel_d, NULL );


	_priv->pixel_n = pixel_n;
	_priv->pixel_d = pixel_d;

	g_message("%s pixel_n = %d,pixel_d = %d",__func__,pixel_n,pixel_d);
	g_object_set(G_OBJECT( video_sink ),
			"pixel-aspect-ratio", _priv->pixel_n, _priv->pixel_d,
			NULL );

	if( NULL != _ele_name ) 
	{
		g_free( _ele_name );
	}

	return _result ;
}      /* -----  end of static function update_mfxsink_pixel_aspect_ratio  ----- */

/*
 * ===  function  ======================================================================
 *         name:  _resize
 *  description:
 * =====================================================================================
 */
static gboolean _resize( MHPlayer * self, guint offsetx, guint offsety, guint width, guint height )
{
	GstElement * _video_sink = NULL;

	gboolean _result = FALSE;

	g_object_get( G_OBJECT( self->playbin2 ), "video-sink", &_video_sink, NULL );

	g_message( "offsetx = [%d] offsety = [%d] width = [%d] height = [%d]\n", offsetx, offsety, width, height );

	if( _video_sink != NULL )
	{
		if( TRUE == is_isink( _video_sink ))
		{
			_result = update_mfw_isink_size( self, _video_sink , offsetx, offsety, width, height );
		}
		else if ( TRUE == is_glimagesink( _video_sink )) 
		{
			_result = update_glimagesink_size( self, _video_sink , offsetx, offsety, width, height);
		}
		else if ( TRUE == is_v4l2sink( _video_sink ) )
		{
			_result = update_v4l2sink_size( self, _video_sink , offsetx, offsety, width, height);
		}
		if( _result	==	TRUE )
		{
			GstState _current;

			gst_element_get_state( self->playbin2, &_current, NULL, GST_SECOND );

			if( _current != GST_STATE_PLAYING )
			{
				GstFormat _fmt = GST_FORMAT_TIME;
				gint64 _pos = -1;

				GstEvent *_seek_event = NULL;
				GstSeekFlags _seek_flags = GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE;

				gst_element_query_position( _video_sink, _fmt, &_pos ); 

				_seek_event = gst_event_new_seek( 1.0, GST_FORMAT_TIME,
						_seek_flags,
						GST_SEEK_TYPE_SET, _pos,
						GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE );

				if( gst_element_send_event( self->playbin2, _seek_event ) == FALSE )
				{
					g_message( " Seek Failer: send seek event failed!\n" );
					return FALSE;
				}
			}
		}
	}
	return _result;
}      /*  -----  end of static function _resize  ----- */ 

/*
 * ===  function  ======================================================================
 *         name:  _pixel_aspect_ratio
 *  description:
 * =====================================================================================
 */
static gboolean _pixel_aspect_ratio( MHPlayer * self, guint pixel_n, guint pixel_d )
{
	GstElement * _video_sink = NULL;

	gboolean _result = FALSE;
	g_message( "pixel_n = [%d] pixel_d = [%d]\n", pixel_n, pixel_d );
	if (self->playbin2_mpeg4 != NULL)
	{
		g_message("%s mpeg4",__func__);
		g_object_get( G_OBJECT( self->playbin2_normal ), "video-sink", &_video_sink, NULL );
		if( _video_sink != NULL )
		{
			if( TRUE == is_isink( _video_sink ))
			{
				_result = update_mfw_isink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d );
			}
			else if ( TRUE == is_glimagesink( _video_sink )) 
			{
				_result = update_glimagesink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d);
			}
			else if ( TRUE == is_v4l2sink( _video_sink ) )
			{
				_result = update_v4l2sink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d);
			}
			else if ( TRUE == is_mfxsink( _video_sink )) 
			{
				_result = update_mfxsink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d);
			}
		}
		g_object_get( G_OBJECT( self->playbin2_mpeg4 ), "video-sink", &_video_sink, NULL );
		if( _video_sink != NULL )
		{
			if ( TRUE == is_glimagesink( _video_sink )) 
			{
				_result = update_glimagesink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d);
			}
		}
	}
	else
	{
		g_object_get( G_OBJECT( self->playbin2 ), "video-sink", &_video_sink, NULL );

		if( _video_sink != NULL )
		{
			if( TRUE == is_isink( _video_sink ))
			{
				_result = update_mfw_isink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d );
			}
			else if ( TRUE == is_glimagesink( _video_sink )) 
			{
				_result = update_glimagesink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d);
			}
			else if ( TRUE == is_v4l2sink( _video_sink ) )
			{
				_result = update_v4l2sink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d);
			}
			else if ( TRUE == is_mfxsink( _video_sink )) 
			{
				_result = update_mfxsink_pixel_aspect_ratio( self, _video_sink , pixel_n, pixel_d);
			}
		}
	}
	return _result;
}      /*  -----  end of static function _pixel_aspect_ratio  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _stop_fast_timeout
 *  Description:
 * =====================================================================================
 */
static void _stop_fast_timeout( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	if( _priv->fast_id != 0 ) 
	{
		g_source_remove( _priv->fast_id );
		_priv->fast_id = 0;
		_priv->fast_interval = 0;
		_priv->fast_playtime = 0;
		_priv->fast_direction = FASTNULL;
		_priv->fast_elapsed_timer = g_get_monotonic_time();

		if( _priv->fast_play_flag	==	1 )
		{
			g_source_set_ready_time( _priv->time_source, 0 );
		}
		_priv->fast_play_flag	=	0;
	}
}      /*  -----  end of static function _stop_fast_timeout  ----- */ 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _seek
 *  Description:
 * =====================================================================================
 */
static gboolean _seek( MHPlayer * self, guint position )
{
	GstEvent *_seek_event = NULL;
	guint64 _seekpos;
	GstSeekFlags _seek_flags = GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE;
//	GstSeekFlags _seek_flags = GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT;
	gboolean _ret;
//	GstState _current;

	_stop_fast_timeout( self );	

//	gst_element_get_state( self->playbin2, &_current, NULL, GST_SECOND );
//
//	if( _current < GST_STATE_PAUSED )
//	{
//		_ret = _state_change( GST_STATE_PAUSED, GST_ELEMENT( self->playbin2 ));
//
//		if( _ret == FALSE )
//		{
//			g_message("try to pause failed\n");
//			return _ret;
//		}else{
//			g_message("try to pause success\n");
//		}
//	}

	_seekpos = ( guint64 )position * GST_MSECOND;

	g_message("_seekpos = [%lld]\n",(long long int )_seekpos );

	_seek_event = gst_event_new_seek( 1.0, GST_FORMAT_TIME,
					_seek_flags,
					GST_SEEK_TYPE_SET,_seekpos,
					GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE );

	if( gst_element_send_event( self->playbin2, _seek_event ) == FALSE )
	{
		g_message( " Seek Failer: send seek event failed!\n" );
		return FALSE;
	}

	return TRUE;
}      /* -----  end of static function _seek  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_rate
 *  Description:
 * =====================================================================================
 */
static gboolean _set_rate( MHPlayer * self, gdouble rate )
{
	gint64 position;
	GstFormat format = GST_FORMAT_TIME;
	GstEvent *seek_event;
	GstElement *video_sink;

	if (!gst_element_query_position (self->playbin2, format, &position)) {
		g_message("%s error",__func__);
		return FALSE;
	}

	if (rate > 0) {
		seek_event = gst_event_new_seek (rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE,
				GST_SEEK_TYPE_SET, position, GST_SEEK_TYPE_SET, -1);
	}
	else
	{
		seek_event = gst_event_new_seek (rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE,
				GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, position);
	}

	g_object_get (self->playbin2, "video-sink", &video_sink, NULL);

	gst_element_send_event (video_sink, seek_event);

	g_message("%s rate = %f",__func__,rate);

	return TRUE;
}      /* -----  end of static function _set_rate  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _mute
 *  Description:
 * =====================================================================================
 */
static void _mute( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );
	GValue _value = { 0 };
	g_value_init( &_value, G_TYPE_BOOLEAN);
	g_value_set_boolean( &_value, !_priv->bmute );
	g_object_set_property( G_OBJECT( self->playbin2 ), "mute", &_value );
	_priv->bmute = !_priv->bmute;
}      /* -----  end of static function _mute  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play
 *  Description:
 * =====================================================================================
 */
static gboolean _play( MHPlayer * self )
{
	gboolean _ret;

	_stop_fast_timeout( self );

	_ret	=	_state_change( GST_STATE_PLAYING, GST_ELEMENT( self->playbin2 ));
	GST_DEBUG_BIN_TO_DOT_FILE( GST_BIN(self->playbin2), GST_DEBUG_GRAPH_SHOW_ALL, "ReadyToPlaying");

	if( _ret == FALSE )
	{
		g_message("try to play failed\n");
	}else{
		g_message("try to play success\n");
	}
	return _ret;
}      /* -----  end of static function _play  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pause
 *  Description:
 * =====================================================================================
 */
static gboolean _pause( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	gboolean _ret	= FALSE;

	_stop_fast_timeout( self );

	_ret = _state_change( GST_STATE_PAUSED, GST_ELEMENT( self->playbin2 ));

	if( _ret == FALSE )
	{
		g_message("try to pause failed\n");
	}else{
		g_message("try to pause success\n");
	}

	/* pause ptime source */
	g_source_set_ready_time( _priv->time_source, -1 );

	return _ret;
}      /* -----  end of static function _pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _close
 *  Description:
 * =====================================================================================
 */
static gboolean _close( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	_stop_fast_timeout( self );

	if( self->playbin2 != NULL )
	{
		gst_element_set_state( GST_ELEMENT( self->playbin2 ), GST_STATE_NULL );
		gst_element_get_state( GST_ELEMENT( self->playbin2 ), NULL, NULL, -1 );
	}

	/* disable ptime source */
	g_source_set_ready_time( _priv->time_source, -1 );
	return TRUE;
}      /* -----  end of static function _close  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _fast_timeout
 *  Description:
 * =====================================================================================
 */
static gboolean _fast_timeout( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );
	gboolean _bquery = TRUE;
	GstFormat _fmt = GST_FORMAT_TIME;
	gint64 _duration;
	gint64 _seekpos;
	GstSeekFlags _seek_flags = GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP |GST_SEEK_FLAG_ACCURATE;
	GstState _cur_state;

//	if(( _bquery )&&( _priv->duration != 0)) 
	if(( _bquery ))
	{
		if( _priv->fast_direction == FORWORD ) 
		{
			_seekpos = ( gint64 )_priv->fast_elapsed_timer + ( gint64 )_priv->fast_interval * GST_MSECOND;

			if( (_seekpos >= _priv->duration) && (_priv->duration != 0)  ) 
			{
				_seekpos = _priv->duration;
				_priv->current_time = 0;	

				if((_priv->fast_play_flag == 1)&&(_priv->fast_id == 0))
					_priv->fast_play_flag = 0;

				mh_dev_set_media_info( self->pb->mhDev, self->pb, MH_PLAYER_EOS, NULL );
				return FALSE;
			}

			_priv->fast_elapsed_timer	=	_seekpos;
		}else{
			_seekpos = ( gint64 )_priv->fast_elapsed_timer - ( gint64 )_priv->fast_interval * GST_MSECOND;

			if( _seekpos <= 0 ) 
			{
				_seekpos = 0;
			}

			_priv->fast_elapsed_timer	=	_seekpos;
		}

		g_message( "_seekpos = [%lld]\n",(long long int) _seekpos );
		_bquery = gst_element_seek( self->playbin2, DEFAULT_PLAYBACK_RATE,
				GST_FORMAT_TIME, _seek_flags,
				GST_SEEK_TYPE_SET, _seekpos,
				GST_SEEK_TYPE_SET, -1 );
		if( !_bquery ) 
		{
			g_message(" Seek Failed: send seek event failed!\n");
		}
	}else{
		g_message("duration = %lld\n",(long long int)_priv->duration);
		return FALSE;
	}
	
	if( _priv->fast_play_flag == 1 )
	{
		MHPbInfoData *_info = g_slice_new( MHPbInfoData );

		_info->time_info.current_time	 = _seekpos / GST_MSECOND;

		gint64 _duration	=	-1;

		if( gst_element_query_duration( GST_ELEMENT( self->playbin2 ), _fmt, &_duration ))
			{
			_priv->duration = _duration ;
		}
		_info->time_info.duration = _priv->duration / GST_MSECOND;

		_set_media_info( self, self->pb, MH_PLAYER_PTIME_CHANGE, _info );

	}

	if( _seekpos <= 0 )
	{
		_bquery = FALSE;
		gst_element_set_state( self->playbin2, GST_STATE_PLAYING );

		if( _priv->fast_play_flag == 1 )
		{
			g_source_set_ready_time( _priv->time_source, 0 );
			_priv->fast_play_flag = 0;
		}
		_set_media_info( self, self->pb, MH_PLAYER_BOS, NULL );
	}
	return _bquery;
}      /* -----  end of static function _fast_timeout  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _start_fast_timeout
 *  Description:
 * =====================================================================================
 */
static void _start_fast_timeout( MHPlayer * self, guint msecs )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	if( msecs > 0 )
	{
		_stop_fast_timeout( self );

		GstState _cur_state;

		gst_element_get_state( self->playbin2, &_cur_state, NULL, 0 );

		if( _cur_state < GST_STATE_PLAYING ) 
		{
			gst_element_set_state( self->playbin2, GST_STATE_PLAYING );
		}

		if( _priv->fast_play_flag == 1 )
		{
			g_source_set_ready_time( _priv->time_source, -1 );
		}
		_priv->fast_id = g_timeout_add( msecs, ( GSourceFunc )_fast_timeout, self );
	}
}      /* -----  end of static function _start_fast_timeout  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward
 *  Description:
 * =====================================================================================
 */
static gboolean _forward( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	GstQuery * _query;
	gboolean _ret;
	int retryCnt = 0;
	_stop_fast_timeout( self );

	while(_ret == FALSE || retryCnt > 3)
	{
		_query = gst_query_new_position( GST_FORMAT_TIME );
		_ret = gst_element_query( self->playbin2, _query );
		retryCnt++;
		usleep(100*1000);
	}
	
	if( _ret )
	{
		gst_query_parse_position( _query, NULL, &_priv->fast_elapsed_timer );
		g_message( "_priv->fast_elapsed_timer = %lld, %d\n",(long long int) _priv->fast_elapsed_timer, retryCnt );

		if(_priv->sfast_interval == 0 )
		{
			const char * _forward_intvaltime	=	getenv( "MH_PLAYER_FORWARD_INTVALTIME" );
			_forward_intvaltime	=	_forward_intvaltime ? _forward_intvaltime : "8000";
			_priv->fast_interval = ( guint )atoi( _forward_intvaltime );
		}else{
			_priv->fast_interval	=	_priv->sfast_interval;
		}

		const char * _forward_play_time	=	getenv( "MH_PLAYER_FORWARD_PLAY_TIME" );
		_forward_play_time	=	_forward_play_time ? _forward_play_time : "1000";
		_priv->fast_playtime = ( guint )atoi( _forward_play_time );

		const char * _forward_play_flag	=	getenv( "MH_PLAYER_FORWARD_PLAY_FLAG" );
		_forward_play_flag	=	_forward_play_flag ? _forward_play_flag : "2";
		_priv->fast_play_flag = ( guint )atoi( _forward_play_flag );

		_priv->fast_direction = FORWORD;

		if( TRUE == _fast_timeout( self )) 
		{
			_start_fast_timeout( self, FORWORD_PLAYTIME );
		}
	}
	else
	{
		g_message ("current_postion query failed...\n");
	}

	return _ret;
}      /* -----  end of static function _forward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward
 *  Description:
 * =====================================================================================
 */
static gboolean _backward( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	GstQuery * _query;
	gboolean _ret;
	int retryCnt = 0;
	
	_stop_fast_timeout( self );
	while(_ret == FALSE || retryCnt > 3)
	{
		_query = gst_query_new_position( GST_FORMAT_TIME );
		_ret = gst_element_query( self->playbin2, _query );
		retryCnt++;
		usleep(100*1000);
	}

	if( _ret )
	{
		gst_query_parse_position( _query, NULL, &_priv->fast_elapsed_timer );
		g_message( "_priv->fast_elapsed_timer = %lld, %d\n",(long long int) _priv->fast_elapsed_timer, retryCnt );

		if(_priv->sfast_interval == 0 )
		{
			const char * _backward_intvaltime	=	getenv( "MH_PLAYER_BACKWARD_INTVALTIME" );
			_backward_intvaltime	=	_backward_intvaltime ? _backward_intvaltime : "8000";
			_priv->fast_interval = ( guint )atoi( _backward_intvaltime );
		}else{
			_priv->fast_interval	=	_priv->sfast_interval;
		}

		const char * _forward_play_time	=	getenv( "MH_PLAYER_BACKWARD_PLAY_TIME" );
		_forward_play_time	=	_forward_play_time ? _forward_play_time : "1000";
		_priv->fast_playtime = ( guint )atoi( _forward_play_time );

		const char * _forward_play_flag	=	getenv( "MH_PLAYER_BACKWARD_PLAY_FLAG" );
		_forward_play_flag	=	_forward_play_flag ? _forward_play_flag : "2";
		_priv->fast_play_flag = ( guint )atoi( _forward_play_flag );

		_priv->fast_direction = BACKWORD;

		if( TRUE == _fast_timeout( self )) 
		{
			_start_fast_timeout( self, FORWORD_PLAYTIME );
		}
	}
	else
	{
		g_message ("current_postion query failed...\n");
	}

	return _ret;
}      /* -----  end of static function _backward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward_done
 *  Description:
 * =====================================================================================
 */
static gboolean _forward_done( MHPlayer * self )
{
	_stop_fast_timeout( self );

	return FALSE;
}      /* -----  end of static function _forward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward_done
 *  Description:
 * =====================================================================================
 */
static gboolean _backward_done( MHPlayer * self )
{
	_stop_fast_timeout( self );

	return FALSE;
}      /* -----  end of static function _backward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _eos
 *  Description:
 * =====================================================================================
 */
static gboolean _eos( gpointer user_data )
{
	MHPlayer * _self	=	MH_PLAYER( user_data );
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( _self );
	_priv->current_time = 0;	
	/* is this needed when a stream was end */

	mh_dev_set_media_info( _self->pb->mhDev, _self->pb, MH_PLAYER_EOS, NULL );

	return FALSE;
}    

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _stop
 *  Description:
 * =====================================================================================
 */
static gboolean  _stop( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	gboolean _ret =	FALSE;

	_stop_fast_timeout( self );

	g_source_set_ready_time( _priv->time_source, -1 );

	_ret = _state_change( GST_STATE_READY, GST_ELEMENT( self->playbin2 ));

	if( _ret == FALSE )
	{
		g_message("try to stop failed\n");
	}else{
		g_message("try to stop success\n");
	}

	return _ret;
}      /* -----  end of static function _stop  ----- */

static gboolean _busFunc( GstBus * bus, GstMessage * message, gpointer user_data );
gboolean is_mpeg4File(char* uri)
{
	char *_p,*_ext;
	g_message("%s uri = %s",__func__,uri);
	_p	=	g_strrstr( uri, ".");
	_ext	=	g_ascii_strdown( _p + 1, strlen(_p + 1));
	g_message("%s _ext = %s",__func__,_ext);
	if( g_strcmp0( _ext, "mp4")==0)
	{
		return TRUE;
	}
	return FALSE;
}

gboolean getdec_mpeg4(const gchar * uri)
{
	AVFormatContext	*	pFormatCtx	=	NULL;
	AVCodecContext	*	pCodecCtx	=	NULL;
	gint32 i;
	gint32 videoStream = -1;
	gboolean ret = FALSE;
	av_register_all();
	if( avformat_open_input( &pFormatCtx, uri, NULL, NULL )!=0 ) 
	{
		g_message( "avformat_open_input(%s) fail\n",uri );
		goto error;
	}
	if (avformat_find_stream_info( pFormatCtx, NULL) < 0)
	{
		g_message("Couldn't find stream information\n");
		goto error;
	}
	for( i = 0; i < pFormatCtx->nb_streams; i++) 
	{
		if(pFormatCtx->streams[i] == NULL){ continue;}
		if(pFormatCtx->streams[i]->codec == NULL){ continue;}
		if((pFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
				&&((pFormatCtx->streams[i]->disposition
						& AV_DISPOSITION_ATTACHED_PIC) == 0))
		{
			videoStream = i;
			break;
		}
	}
	g_message("%s videoStream = %d",__func__,videoStream);
	if (videoStream != -1)
	{
		pCodecCtx = pFormatCtx->streams[videoStream]->codec;
		if( pCodecCtx == NULL )
		{
			g_message("count not find codec context\n");
			goto error; 
		}
		g_message("%s pCodecCtx->codec_id = %d",__func__,pCodecCtx->codec_id);
		if (pCodecCtx->codec_id == AV_CODEC_ID_MPEG4)
		{
			ret = TRUE;
		}
		if( pCodecCtx != NULL )
			avcodec_close(pCodecCtx);
	}
	if( pFormatCtx != NULL )
		avformat_close_input(&pFormatCtx);
	return ret;
error:
	if( pFormatCtx != NULL )
		avformat_close_input(&pFormatCtx);
	return FALSE;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_media_location
 *  Description:
 * =====================================================================================
 */
static gboolean _set_media_location( MHPlayer * self, const gchar * location )
{
	g_message( "%s location = [%s]\n",__func__, location );
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	gboolean _ret;
	gboolean is_mpeg4;
	if( _priv->mrl )
		g_free( _priv->mrl );
	_priv->mrl = g_filename_to_uri( location, NULL, NULL );

	if( _priv->bus != NULL )
		gst_bus_set_flushing( _priv->bus, FALSE );

	DEBUG_TIME_BEGIN();
	DEBUG_TIME_DUR_BEGIN();	
	if (self->playbin2_mpeg4 != NULL)
	{
		g_message("%s mpeg4",__func__);
//		is_mpeg4 = getdec_mpeg4(_priv->mrl);
		is_mpeg4 = getdec_mpeg4(location);
		g_message("%s is_mpeg4 = %d, self->playbin2_state = %d",__func__,is_mpeg4,self->playbin2_state);
		if (!is_mpeg4 && !self->playbin2_state )
		{
			g_message("%s Switch mpeg4 to normal",__func__);
			self->playbin2 = self->playbin2_normal;
			self->playbin2_state = TRUE;
		}
		else if(is_mpeg4 && self->playbin2_state )
		{
			g_message("%s Switch normal to mpeg4",__func__);
			self->playbin2 = self->playbin2_mpeg4;
			self->playbin2_state = FALSE;
		}
		else
		{
			g_message("%s keep playbin2",__func__);
		}
	}
	DEBUG_TIME_DUR_END();
	DEBUG_TIME_END();
	g_object_set (G_OBJECT( self->playbin2), "uri", _priv->mrl, NULL );

	_ret = _state_change( GST_STATE_READY, GST_ELEMENT( self->playbin2 ));
	GST_DEBUG_BIN_TO_DOT_FILE( GST_BIN(self->playbin2), GST_DEBUG_GRAPH_SHOW_ALL, "NullToReady");

	if( _ret == FALSE )
	{
		g_message("try to location failed\n");
	}else{
		g_message("try to location success\n");
	}
	return _ret;
}      /* -----  end of static function _set_media_location  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  is_magiced_by_c2c3
 *  Description:
 * =====================================================================================
 */
static bool is_magiced_by_c2c3(const char str[], uint32_t len)
{
	uint32_t i;
	if(len >= 2)
	{
		for(i = 0; i < len - 2; i++) 
{

			if((uint8_t)str[i] < 0x7F) 
			{
			}
			else if((((uint8_t)str[i] == 0xC2U) || ((uint8_t)str[i] == 0xC3U))
					&& (((uint8_t)str[i + 2] == 0xC2U)|| ((uint8_t)str[i + 2] == 0xC3U)) )
			{
					return true;
			}
		}
	}
	return false;
}		/* -----  end of static function is_magiced_by_c2c3  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  fix_c2c3_string
 *  Description:
 * =====================================================================================
 */
static char * fix_c2c3_string( gchar * string )
{
	gchar * _revert	=	string;
	if(is_magiced_by_c2c3(string,strlen(string))== true)
	{
		_revert	=	g_convert( string, strlen( string ),  "iso-8859-1", "utf-8", NULL, NULL, NULL );
		printf("** Message: [%s : %d]-----after g_convert[%s]\n","gstplayer.c", __LINE__, _revert);
		g_free( string );
		if( _revert	!=	NULL )
		{
			if(g_utf8_validate(_revert, -1, NULL))
			{
				printf("** Message: [%s : %d]-----valid utf-8 str[%s]\n", "gstplayer.c", __LINE__, _revert);
			}
			else
			{
				iconv_t cd = iconv_open("utf-8", "gb18030");
				 if((iconv_t)-1 == cd)
				 {
					 printf("** Message: [%s : %d]-----iconv_open failed!!!!!\n","gstplayer.c", __LINE__);
				 }
				 else
				 {
					 printf("** Message: [%s : %d]-----iconv_open success!!!!!\n","gstplayer.c", __LINE__);
					 int _inbytes_left = strlen(_revert);
					 int _outbytes_left;
					 if(_inbytes_left < 128)
					 {
						 _outbytes_left = _inbytes_left * 2;
					 }
					 else
					 {
						 _outbytes_left = 256;
					 }
					 printf("** Message: [%s : %d]-----make iconv args!!!!![_inbytes_left=%d, _outbytes_left=%d]\n","gstplayer.c", __LINE__, _inbytes_left, _outbytes_left);
					 gchar *_inbuf = _revert;
					 gchar *_outstr = g_malloc0(_outbytes_left);
					 gchar *_outbuf = _outstr;
					 int ret = iconv(cd, &_inbuf, &_inbytes_left, &_outbuf, &_outbytes_left);
					 if(-1 == ret)
					 {
						 printf("** Message: [%s : %d]-----iconv() failed!!!!![%s]\n","gstplayer.c", __LINE__, strerror(errno));
						 g_free(_revert);
						 g_free(_outstr);
						 _revert = NULL;
						 _outstr = NULL;
					 }
					 else
					 {
						 printf("** Message: [%s : %d]-----iconv() success!!!!![%s]\n","gstplayer.c", __LINE__, _outstr);
						 g_free(_revert);
						 _revert = _outstr;
						 iconv_close(cd);
					 }
				 }
			}
		}
	}
	return _revert;
}		/* -----  end of static function _text_invaild_UTF8_chang_loc_cn  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _tag_func
 *  Description:
 * =====================================================================================
 */
static void _tag_func( const GstTagList * list, const gchar * tag, gpointer user_data )
{
	GValue _value	=	G_VALUE_INIT;
	const gchar * _string;
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( MH_PLAYER( user_data ));
	gchar * _cnv_string = NULL;
							
	if( gst_tag_list_copy_value( &_value, list, tag ))
	{
		switch( G_VALUE_TYPE( &_value ))
		{
			case G_TYPE_STRING:
				_string	=	g_value_get_string( &_value );		
//				g_message( "tag: [ %s ] value: [ %s ]", tag, _string );
				if( _string && *_string != '\0' && g_utf8_validate(_string, -1, NULL)) 
				{
//					printf("** Message: [%s : %d]-----_string [%s]\n","gstplayer.c", __LINE__, _string);
					_cnv_string = g_strdup_printf("%s", _string) ;
//					printf("** Message: [%s : %d]-----11111111cnv_string [%s]\n","gstplayer.c", __LINE__, _cnv_string);
					_cnv_string = fix_c2c3_string(_cnv_string);
//					printf("** Message: [%s : %d]-----22222222cnv_string [%s]\n","gstplayer.c", __LINE__, _cnv_string);
				}
				else {
					_cnv_string = NULL;
				}
				printf("** Message: [%s : %d]-----[tag is %s, _cnv_string is %s]\n", "gstplayer.c", __LINE__, tag, _cnv_string);

				if( _cnv_string == NULL ) break;
				if(( strncmp(gst_tag_get_nick(tag), "title", 5) == 0 )&&( _priv->metadata_info.title == NULL ))
				{
					_priv->metadata_info.title = g_strdup( _cnv_string );
//					printf( "** Message: [%s : %d]-----tag: [ %s ] value: [ %s ]\n", "gstplayer.c", __LINE__, tag, _priv->metadata_info.title);
				}
				if(( strncmp(gst_tag_get_nick(tag), "artist", 6) == 0 )&&( _priv->metadata_info.artist == NULL ))
				{
					_priv->metadata_info.artist = g_strdup( _cnv_string );
//					printf( "** Message: [%s : %d]-----tag: [ %s ] value: [ %s ]\n", "gstplayer.c", __LINE__, tag, _priv->metadata_info.artist);
				}
				if(( strcmp(gst_tag_get_nick(tag), "album") == 0 )&&( _priv->metadata_info.album == NULL ))
				{	
					_priv->metadata_info.album = g_strdup( _cnv_string );
//					printf( "** Message: [%s : %d]-----tag: [ %s ] value: [ %s ]\n", "gstplayer.c", __LINE__, tag, _priv->metadata_info.album);
				}
				if(( strncmp(gst_tag_get_nick(tag), "genre", 5) == 0 )&&( _priv->metadata_info.genre == NULL ))
				{	
					_priv->metadata_info.genre = g_strdup( _cnv_string );
//					printf( "** Message: [%s : %d]-----tag: [ %s ] value: [ %s ]\n", "gstplayer.c", __LINE__, tag, _priv->metadata_info.genre);
				}
				break;								
			case G_TYPE_UINT:				
				g_message( "tag: [ %s ] value: [ %u ]", tag, g_value_get_uint( &_value ));
				break;
			case G_TYPE_BOOLEAN:
				g_message( "tag: [ %s ] value: [ %s ]", tag, g_value_get_boolean( &_value ) ? "TRUE" : "FALSE" );
				break;
			case G_TYPE_UINT64:
				g_message( "tag: [ %s ] value: [ %lld ]", tag,(long long int) g_value_get_uint64( &_value ));
				break;
			default:
				break;
		}	
		g_value_unset( &_value );
	}
	if( _cnv_string != NULL)
		g_free( _cnv_string );
}		/*  -----  end of static function _tag_func  ----- */ 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_volume
 *  Description:
 * =====================================================================================
 */
static gboolean _set_volume( MHPlayer * self, gdouble volume )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	GValue _value = { 0 };
	if( volume == 0.0 )
	{
		g_message( "Set volume Fail!");
		return FALSE;
	}
	_priv->volume = volume;
	g_value_init( &_value, G_TYPE_DOUBLE);
	g_value_set_double( &_value, _priv->volume );
	g_object_set_property( G_OBJECT( self->playbin2), "volume" ,&_value );
	return TRUE;
}      /* -----  end of static function _set_volume  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _rotate
 *  Description:
 * =====================================================================================
 */
static void _rotate( MHPlayer * self, guint value )
{

	//Method default implement.
	//g_assert_not_reached();
}      /* -----  end of static function _rotate  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_playback_rate
 *  Description:
 * =====================================================================================
 */
static void _set_playback_rate( MHPlayer * self, gdouble rate )
{

	//Method default implement.
	//g_assert_not_reached();
}      /* -----  end of static function _set_playback_rate  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_dispose
 *  Description:
 * =====================================================================================
 */
static void mh_player_dispose( GObject * object )
{
	MHPlayer * _self	=	MH_PLAYER( object );
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( _self );

	_stop_fast_timeout( _self );

	if( _priv->old_mrl != NULL )
		g_free( _priv->old_mrl );

	if (_self->playbin2_mpeg4 != NULL)
	{
		g_message("%s mpeg4",__func__);
		if( _self->playbin2_normal != NULL )
		{
			_state_change( GST_STATE_NULL, ( _self->playbin2_normal ));
			gst_object_unref ( GST_OBJECT( _self->playbin2_normal ));
		}
		if( _self->playbin2_mpeg4 != NULL )
		{
			_state_change( GST_STATE_NULL, ( _self->playbin2_mpeg4 ));
			gst_object_unref ( GST_OBJECT( _self->playbin2_mpeg4 ));
		}
		if( _priv->bus_mpeg4 )
			gst_object_unref ( _priv->bus_mpeg4 );

		if( _priv->watchid_mpeg4 )
		{
			g_source_remove( _priv->watchid_mpeg4 );
			_priv->watchid_mpeg4 = 0;
		}
	}
	else
	{
		if( _self->playbin2 != NULL )
		{
			_state_change( GST_STATE_NULL, ( _self->playbin2 ));
			gst_object_unref ( GST_OBJECT( _self->playbin2 ));
		}
	}
	if( _priv->video_sink )
		gst_object_unref ( GST_OBJECT( _priv->video_sink ));
	
	if( _priv->bus )
		gst_object_unref ( _priv->bus );
	
	if( _priv->watchid )
	{
		g_source_remove( _priv->watchid );
		_priv->watchid = 0;
	}
	if( _priv->metadata_info.title != NULL )
		g_free( _priv->metadata_info.title );
	
	if( _priv->metadata_info.artist != NULL )
		g_free( _priv->metadata_info.artist );
	
	if( _priv->metadata_info.album != NULL )
		g_free( _priv->metadata_info.album );

	if( _priv->metadata_info.genre != NULL )
		g_free( _priv->metadata_info.genre );
	if( _priv->mrl )
		g_free( _priv->mrl );
	
	G_OBJECT_CLASS( mh_player_parent_class )->dispose( object );
}      /* -----  end of static function mh_player_dispose  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_finalize
 *  Description:
 * =====================================================================================
 */
static void mh_player_finalize( GObject * object )
{
	MHPlayer * _self	=	MH_PLAYER( object );

	G_OBJECT_CLASS( mh_player_parent_class )->finalize( object );
}      /* -----  end of static function mh_player_finalize  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _busFunc
 *  Description:  
 * =====================================================================================
 */
static gboolean _busFunc( GstBus * bus, GstMessage * message, gpointer user_data )
{
	g_return_val_if_fail( MH_IS_PLAYER( user_data ),FALSE);
	GError * _error;
	gchar * _debugInfo;
	GstTagList * _tagList =	NULL;	
	GstClock * _clock;
	GstStreamStatusType _type;
	GstElement * _owner;
	GstFormat _format;
	gint64 _duration;
	MHPlayer * _player	=	MH_PLAYER( user_data );
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( _player);

	uint32_t bands = 0;
	int i = 0;
	const GstStructure *structure;

//	g_message ("Got [ %s ] message from element [ %s ]", GST_MESSAGE_TYPE_NAME( message ), gst_element_get_name( message->src ));
	switch( GST_MESSAGE_TYPE( message ))
	{
	case GST_MESSAGE_UNKNOWN:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_EOS:
		{
			GSource * _source	=	g_idle_source_new();
			g_message("Error message[ GST_MESSAGE_EOS ]");

			g_source_set_callback( _source, _eos, ( gpointer )user_data , NULL );

			mh_io_dispatch( MH_IO( user_data ), _source );	

			g_source_unref( _source );
		}
		break;
	case GST_MESSAGE_ERROR:
		gst_message_parse_error( message, &_error, &_debugInfo );
		g_warning ( "Error from element[ %s ]\n: %s\n", GST_OBJECT_NAME( message->src ), 
				_debugInfo ? _debugInfo : "none" );
		g_message("Error message[ %s ]\n",_error->message);
		
		gst_bus_set_flushing( bus, TRUE );
		if( strncmp( _error->message, "Resource not found.", 19 ) == 0 )
		{
			_set_media_info( _player, _player->pb, MH_PLAYER_ERROR_NOT_EXIST, NULL );
		}else{
			_set_media_info( _player, _player->pb, MH_PLAYER_ERROR, NULL );
		}
		g_error_free( _error );
		g_free( _debugInfo );

		/*  flush any other error messages from the bus and clean up */ 
		if( _player->playbin2 ) {
			gst_element_set_state( _player->playbin2, GST_STATE_NULL );
		}
		
		break;
	case GST_MESSAGE_WARNING:
		gst_message_parse_warning (message, &_error, &_debugInfo);

		g_warning ( "Warning from element[ %s ]: %s", GST_OBJECT_NAME( message->src ), 
				_debugInfo ? _debugInfo : "none" );
		g_error_free( _error );
		g_free( _debugInfo );
		break;
	case GST_MESSAGE_INFO:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_TAG:
		{
		gchar *ele_name =	gst_element_get_name( message->src );

		if(( strncmp( ele_name, "id3demux", 8 ) == 0 )
					|| ( strncmp( ele_name, "aiurdemux", 9 ) == 0 )
					|| ( strncmp( ele_name, "apedemux", 8 ) == 0) 
					|| ( strncmp( ele_name, "pulsesink", 9 ) == 0)
					|| ( strncmp( ele_name, "alsasink", 8 ) == 0))
		{		
				if( g_strcmp0(_priv->mrl, _priv->old_mrl ) != 0 ) 
				{
					if( _priv->old_mrl != NULL )
						g_free( _priv->old_mrl );
					_priv->old_mrl	=	g_strdup( _priv->mrl );

					if( _priv->metadata_info.title != NULL )
					{
						g_free( _priv->metadata_info.title );
						_priv->metadata_info.title	=	NULL;
					}

					if( _priv->metadata_info.artist != NULL )
					{
						g_free( _priv->metadata_info.artist );
						_priv->metadata_info.artist	=	NULL;
					}

					if( _priv->metadata_info.album != NULL )
					{
						g_free( _priv->metadata_info.album );
						_priv->metadata_info.album	=	NULL;
					}
					if( _priv->metadata_info.genre != NULL )
					{
						g_free( _priv->metadata_info.genre );
						_priv->metadata_info.genre	=	NULL;
					}
				}
				gst_message_parse_tag( message, &_tagList );
				gst_tag_list_foreach( _tagList, _tag_func, MH_PLAYER( user_data ) );
				gst_tag_list_free( _tagList );     
//				if(  _priv->metadata_info.title != "\0") 
				if(( _priv->metadata_info.title != NULL ) || ( _priv->metadata_info.artist != NULL )
						|| ( _priv->metadata_info.album != NULL ) || ( _priv->metadata_info.genre != NULL )) //MH2.1
				{
					MHPbInfoData *_info = g_slice_new( MHPbInfoData );
					_info->tag_info.title	=	g_strdup( _priv->metadata_info.title ? _priv->metadata_info.title : "");
					_info->tag_info.artist	=	g_strdup( _priv->metadata_info.artist ? _priv->metadata_info.artist : "");
					_info->tag_info.album	=	g_strdup( _priv->metadata_info.album ? _priv->metadata_info.album : "");

					_info->tag_info.genre	=	g_strdup( _priv->metadata_info.genre ? _priv->metadata_info.genre : "");
					_set_media_info( _player, _player->pb, MH_PLAYER_TAG_INFO, _info );
				}
		}
		if( ele_name != NULL)
			g_free( ele_name );
		}
		break;
	case GST_MESSAGE_BUFFERING:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_STATE_CHANGED:
		{
		GstState _old_state, _new_state, _pending;
		gst_message_parse_state_changed( message, &_old_state, &_new_state, &_pending );

		if( _old_state == _new_state)
			break;
		if(( _old_state == GST_STATE_PAUSED )&&( _new_state == GST_STATE_PLAYING ))
		{
//			if(_priv->start_flag == 1){
//				_priv->start_flag = 0;
//				printf("###GST_MESSAGE_STATE_CHANGED   start###\n");
//				_reconfigure_timeout_source( MH_PLAYER( user_data ), 200, 0 );
				if(( _priv->time_source != NULL )&&(_priv->fast_play_flag != 1))
					g_source_set_ready_time( _priv->time_source, 0 );
//			}
		}
	//	g_message( "%s -> %s, pending: %s", gst_element_state_get_name( _old_state ),
	//			gst_element_state_get_name( _new_state ), gst_element_state_get_name( _pending ));
		}
		break;
	case GST_MESSAGE_STATE_DIRTY:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_STEP_DONE:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_CLOCK_PROVIDE:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_CLOCK_LOST:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_NEW_CLOCK:
		gst_message_parse_new_clock( message, &_clock );

		g_message( "%lld",(long long int) gst_clock_get_time( _clock ));
		break;
	case GST_MESSAGE_STRUCTURE_CHANGE:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_STREAM_STATUS:
		gst_message_parse_stream_status( message, &_type, &_owner );

	//	g_message( "Stream Status: [ %d ], Element Name: [ %s ]", _type, gst_element_get_name( _owner ));
		break;
//	case GST_MESSAGE_APPLICATION:
////		g_message( "GST_MESSAGE_APPLICATION");
//		structure = gst_message_get_structure(message);
//		if (g_strcmp0 (gst_structure_get_name (structure), "frequency-analysis-result") == 0)
//		{
//			char* band_str = NULL;
//			char* smpl_tr1 = NULL;
//			gst_structure_get_uint(structure, "bands", &bands);
////			g_message( "GST_MESSAGE_APPLICATION bands: [ %d ]", bands);
//			MHPbInfoData *_info = g_slice_new( MHPbInfoData );
//			_info->frequency_analysis_result.band = bands;
//			_info->frequency_analysis_result.bands = g_new(double, bands);
//			_info->frequency_analysis_result.amplitudes = g_new(double, bands);
//			for (i=0 ;i<bands; i++)
//			{
//				band_str = g_strdup_printf("band.%d",i);
////				g_message( "GST_MESSAGE_APPLICATION band_str: [ %s ]", band_str);
//				gst_structure_get_double(structure, band_str, &_info->frequency_analysis_result.bands[i]);
////				g_message( "GST_MESSAGE_APPLICATION bands[%d]=[ %lf ]",i, _info->frequency_analysis_result.bands[i]);
//				g_free(band_str);
//				smpl_tr1 = g_strdup_printf("ampl.%d",i);
////				g_message( "GST_MESSAGE_APPLICATION smpl_tr1: [ %s ]", smpl_tr1);
//				gst_structure_get_double(structure, smpl_tr1, &_info->frequency_analysis_result.amplitudes[i]);
////				g_message( "GST_MESSAGE_APPLICATION amplitudes[%d]=[ %lf ]",i, _info->frequency_analysis_result.amplitudes[i]);
//				g_free(smpl_tr1);
//			}
//			_set_media_info( _player, _player->pb, MH_PLAYER_FREQUENCY_ANALYSIS_RESULT, _info );
//		}
//
//		//g_assert_not_reached();
//		break;
	case GST_MESSAGE_ELEMENT:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_SEGMENT_START:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_SEGMENT_DONE:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_DURATION:

		break;
	case GST_MESSAGE_LATENCY:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_ASYNC_START:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_ASYNC_DONE:
		g_message( "[ GST_MESSAGE_ASYNC_DONE ]" );

		break;
	case GST_MESSAGE_REQUEST_STATE:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_STEP_START:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_QOS:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_PROGRESS:
		//g_assert_not_reached();
		break;
	case GST_MESSAGE_ANY:
		//g_assert_not_reached();
		break;
	default:
		g_message( "un-catched message" );
		//g_assert_not_reached();
		/*  unhandled message */
		break;
	}
	return TRUE;
}		/* -----  end of static function _busFunc  ----- */

void createNormalPlaybin2( MHPlayer * self )
{
	g_message("%s",__func__);
	self->playbin2_normal = gst_element_factory_make("playbin", NULL);
}

void createMpeg4Playbin2( MHPlayer * self )
{
	g_message("%s",__func__);
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( MH_PLAYER( self ));
	GstElement	* _sink;
	self->playbin2_mpeg4 = gst_element_factory_make("playbin", NULL);
	_sink	=	gst_element_factory_make( "glimagesink", NULL );
	g_object_set( self->playbin2_mpeg4, "video-sink", _sink, NULL);
//	g_object_set( _sink, "surfaceid", 888, NULL);
	if( self->playbin2_mpeg4 == NULL )
	{
		g_message("%s self->playbin2_mpeg4 == NULL",__func__);
	}
	_priv->bus_mpeg4 = gst_pipeline_get_bus(GST_PIPELINE( self->playbin2_mpeg4 ));
	if( _priv->bus_mpeg4 ==  NULL )
	{
		g_message("%s _priv->bus_mpeg4 == NULL",__func__);
	}
	_priv->watchid_mpeg4 = gst_bus_add_watch( _priv->bus_mpeg4, _busFunc, self);
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name: _construct_pipeline 
 *  Description:
 * =====================================================================================
 */
static gboolean _construct_pipeline( MHPlayer * self )
{
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( MH_PLAYER( self ));

#ifndef HS7
#else
	createMpeg4Playbin2(self);
#endif
	createNormalPlaybin2(self);
	self->playbin2 = self->playbin2_normal;
	self->playbin2_state = TRUE;

//	self->playbin2 = gst_element_factory_make("playbin", NULL);

	if( self->playbin2 == NULL )
	{
		g_message("%s self->playbin2 == NULL",__func__);
	}
	_priv->bus = gst_pipeline_get_bus(GST_PIPELINE( self->playbin2 ));
	if( _priv->bus ==  NULL )
	{
		g_message("%s _priv->bus == NULL",__func__);
	}
	_priv->watchid = gst_bus_add_watch( _priv->bus, _busFunc, self);

//	switch( _priv->pipelinetype )
//	{
//		case MH_PLAYER_USB_PIPELINE:
//			_priv->playbin2 = gst_element_factory_make("playbin2", NULL);
//
//			if( NULL == _priv->playbin2 )
//			{
//				printf( "Failed in gst_element_factory_make()!\n" );
//				return FALSE;
//			}
//
//			_priv->bus = gst_pipeline_get_bus(GST_PIPELINE( _priv->playbin2 ));
//
//			if( NULL == _priv->bus )
//			{
//				printf( "Failed in gst_pipeline_get_bus()!\n" );
//				return FALSE;
//			}
//
//			_priv->watchid = gst_bus_add_watch( _priv->bus, _busFunc, self);
//
//			break;
//		case MH_PLAYER_IAP2_DEVICE_MODE_PIPELINE:
//			{
//				GstElement *_source;
//				GstElement *_sink;
//				GstStateChangeReturn _result = GST_STATE_CHANGE_FAILURE;
//				_priv->playbin2 = gst_pipeline_new ("ApPlayer");  
//
//				_source = gst_element_factory_make ( "alsasrc", NULL);
//				_sink = gst_element_factory_make ("pulsesink", NULL);
//				if(( _source == NULL )||( _sink == NULL ))
//				{ 
//					printf( "Create Element Failed\n" ); 
//					return FALSE;
//				}
//				printf("pcm_card = [%s]\n",pcm_card );
//				g_object_set( G_OBJECT(_source), "device", pcm_card, "provide-clock", false, NULL);
//				gint64 _time = 1500000; 
//				g_object_set( G_OBJECT(_sink), "buffer-time", _time, NULL);
//				gst_bin_add_many (GST_BIN ( _priv->playbin2 ), _source, _sink, NULL);
//				gst_element_link( _source, _sink);
//				//			GST_DEBUG_BIN_TO_DOT_FILE( GST_BIN(_priv->playbin2), GST_DEBUG_GRAPH_SHOW_ALL , "myplayerxxx");	
//				_result = gst_element_set_state (_priv->playbin2, GST_STATE_PLAYING);
//
//				if(_result == GST_STATE_CHANGE_FAILURE)
//				{
//					printf(" GST_STATE_PLAYING Change Failed!\n");
//				}else{
//					printf(" GST_STATE_PLAYING Change success!\n");
//				}
//			}
//			break;
//		case MH_PLAYER_IAP2_HOST_MODE_PIPELINE:
//			{
//				GstStateChangeReturn _result = GST_STATE_CHANGE_FAILURE;
//
//				_priv->playbin2   =   gst_element_factory_make( "playbin2", "playbin" );
//
//				g_signal_connect( _priv->playbin2, "source-setup", G_CALLBACK( setupSrc ), self );
//
//				g_object_set( _priv->playbin2, "uri", "appsrc://", NULL );
//
//				_result	=	gst_element_set_state( _priv->playbin2, GST_STATE_PLAYING );
//
////				GST_DEBUG_BIN_TO_DOT_FILE( GST_BIN(_priv->playbin2), GST_DEBUG_GRAPH_SHOW_ALL , "myplayerxxx");	
//
//				if(_result == GST_STATE_CHANGE_FAILURE)
//				{
//					printf(" GST_STATE_PLAYING Change Failed!\n");
//				}else{
//					printf(" GST_STATE_PLAYING Change success!\n");
//				}
//				break;
//			}
//		default:
//			break;
//	}
	return TRUE;
}		/* -----  end of static function _construct_pipeline  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  ptimeDispatch
 *  Description:  
 * =====================================================================================
 */
static gboolean ptimeDispatch( GSource * source, GSourceFunc callback, gpointer user_data )
{
	GstFormat _fmt = GST_FORMAT_TIME;
	gint64 _pos = -1;
	MHPlayer * _self	=	MH_PLAYER( user_data );
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( MH_PLAYER( user_data ));

	if( gst_element_query_position( _self->playbin2, _fmt, &_pos )) 
	{
		if( _pos != -1 && _fmt == GST_FORMAT_TIME ) 
		{	
			MHPbInfoData *_info = g_slice_new( MHPbInfoData );

			_info->time_info.current_time	 = _pos / GST_MSECOND;

			g_source_set_ready_time( _priv->time_source, g_source_get_time( _priv->time_source ) + 
					(( _info->time_info.current_time / 1000 + 1 ) * 1000 + 10 - _pos / GST_MSECOND ) * 1000 );

			gint64 _duration	=	-1;

			if( gst_element_query_duration( GST_ELEMENT( _self->playbin2 ), _fmt, &_duration ))
			{
				_priv->duration = _duration ;
			}else{
				if( _info->time_info.current_time < 500)//get duration error,current_time is not 0
					_priv->duration =	0; 
			}
			_info->time_info.duration = _priv->duration / GST_MSECOND;

			_set_media_info( _self, _self->pb, MH_PLAYER_PTIME_CHANGE, _info );
			
		}
	}
	else {
		g_message("could not get position\n");

		g_source_set_ready_time( _priv->time_source, g_source_get_time( _priv->time_source ) + 
				500 * 1000 );
	}

	return G_SOURCE_CONTINUE;
}		/* -----  end of static function ptimeDispatch  ----- */

static GSourceFuncs ptimeFuncs  =
{
	.dispatch   =   ptimeDispatch
};

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_ptime_source
 *  Description:
 * =====================================================================================
 */
static void _set_ptime_source( MHPlayer * self )
{
	MHPlayerPrivate	* _priv	=	mh_player_get_instance_private( self );

	_priv->time_source	=	g_source_new( &ptimeFuncs, sizeof( GSource ));
	g_source_set_callback( _priv->time_source, NULL, self, NULL );
	g_source_set_ready_time( _priv->time_source, -1 );
	mh_io_dispatch( MH_IO( self ), _priv->time_source );
	g_source_unref( _priv->time_source );
}      /* -----  end of static function _set_ptime_source  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_init
 *  Description:
 * =====================================================================================
 */
static void mh_player_init( MHPlayer * self )
{
	MHPlayerPrivate * _priv	=	mh_player_get_instance_private( self );
	g_message("%s self = %p",__func__,self);
	_priv->bmute = FALSE;
	_priv->volume = 1.0;
	_priv->duration = 0;
	_priv->disp_x = 0;
	_priv->disp_y = 0;
	_priv->disp_width = 800;
	_priv->disp_height = 480;
	_priv->old_mrl	=	NULL;
	_priv->time_source	=	NULL;
	_priv->sfast_interval = 0;
	_priv->pixel_n = 0;
	_priv->pixel_d = 0;
	self->pb = NULL;
	/* create the ptime source and pause it */
//	_priv->time_source	=	g_source_new( &ptimeFuncs, sizeof( GSource ));
//	g_source_set_callback( _priv->time_source, NULL, self, NULL );
//	g_source_set_ready_time( _priv->time_source, -1 );
//	mh_io_dispatch( MH_IO( self ), _priv->time_source );
//	g_source_unref( _priv->time_source );

}       /* -----  end of static function mh_player_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_player_class_init( MHPlayerClass * klass )
{
	GObjectClass * _parentClass	=	G_OBJECT_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	mh_player_dispose;
	_gobjectClass->finalize	=	mh_player_finalize;

	/* assemble ios of mh_player class */

	/* assemble methods of mh_player class */
	klass->set_source	=	_set_source;
	klass->set_video_sink	=	_set_video_sink;
	klass->set_audio_sink	=	_set_audio_sink;
	klass->set_audio_track	=	_set_audio_track;
	klass->set_subtitle	=	_set_subtitle;
	klass->resize	=	_resize;
	klass->pixel_aspect_ratio	=	_pixel_aspect_ratio;
	klass->seek	=	_seek;
	klass->set_rate	=	_set_rate;
	klass->play	=	_play;
	klass->pause	=	_pause;
	klass->stop	=	_stop;
	klass->close	=	_close;
	klass->set_media_location	=	_set_media_location;
	klass->set_volume	=	_set_volume;
	klass->mute	=	_mute;
	klass->rotate	=	_rotate;
	klass->set_playback_rate	=	_set_playback_rate;
	klass->forward = _forward;
	klass->backward = _backward;
	klass->forward_done = _forward_done;
	klass->backward_done = _backward_done;
	klass->get_track_info	=	_get_track_info;
	klass->get_subtitle_info	=	_get_subtitle_info;
	klass->set_ptime_source	=	_set_ptime_source;
	klass->set_intvaltime	=	_set_intvaltime;

	/* Ios */
	/* Signals */
	signals[ PLAYER_EVENT ]	=
		g_signal_new( "player_event",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
			    2	
				, G_TYPE_UINT, G_TYPE_POINTER );

}       /* -----  end of static function mh_player_class_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_open
 *  Description:
 * =====================================================================================
 */
MHPlayer * mh_player_open()
{
	MHPlayer * _self = g_object_new( MH_TYPE_PLAYER, "io-name", "player", NULL );

	gboolean _ret = FALSE;

	_ret	=	_construct_pipeline( _self );

	if( _ret == FALSE )
	{
		g_message("construct pipeline failed !\n");

		g_object_unref( _self );

		_self	=	NULL;
	}
	return _self;
}		/* -----  end of function mh_player_open  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_source_by_name
 *  Description:
 * =====================================================================================
 */
void mh_player_set_source_by_name( MHPlayer * self, gpointer name )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_source != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_source( self, name );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_source()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_source_by_name  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_source
 *  Description:
 * =====================================================================================
 */
void mh_player_set_source( MHPlayer * self, gpointer name )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_source != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_source( self, name );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::get_source()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_source  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_video_sink
 *  Description:
 * =====================================================================================
 */
gboolean mh_player_set_video_sink( MHPlayer * self, gpointer name )
{
	gboolean _result = FALSE;
	g_return_val_if_fail( MH_IS_PLAYER( self ), _result );

	if( MH_PLAYER_GET_CLASS( self )->set_video_sink != NULL )
	{
		_result = MH_PLAYER_GET_CLASS( self )->set_video_sink( self, name );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_video_sink()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _result;
}		/* -----  end of function mh_player_set_video_sink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_audio_sink
 *  Description:
 * =====================================================================================
 */
void mh_player_set_audio_sink( MHPlayer * self, gpointer name )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_audio_sink != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_audio_sink( self, name );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_audio_sink()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_audio_sink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_audio_track
 *  Description:
 * =====================================================================================
 */
void mh_player_set_audio_track( MHPlayer * self, guint track )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_audio_track != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_audio_track( self, track );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_audio_track()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_audio_track  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_subtitle
 *  Description:
 * =====================================================================================
 */
void mh_player_set_subtitle( MHPlayer * self, guint subtitle )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_subtitle != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_subtitle( self, subtitle );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_subtitle()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_subtitle  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_resize
 *  Description:
 * =====================================================================================
 */
gboolean mh_player_resize( MHPlayer * self, guint offsetx, guint offsety, guint width, guint height )
{
	gboolean _result = FALSE;
	g_return_val_if_fail( MH_IS_PLAYER( self ), _result );

	if( MH_PLAYER_GET_CLASS( self )->resize != NULL )
	{
		_result = MH_PLAYER_GET_CLASS( self )->resize( self, offsetx, offsety, width, height );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::resize()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _result;
}		/* -----  end of function mh_player_resize  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_pixel_aspect_ratio
 *  Description:
 * =====================================================================================
 */
gboolean mh_player_pixel_aspect_ratio( MHPlayer * self, guint pixel_n, guint pixel_d )
{
	gboolean _result = FALSE;
	g_return_val_if_fail( MH_IS_PLAYER( self ), _result );

	if( MH_PLAYER_GET_CLASS( self )->pixel_aspect_ratio != NULL )
	{
		_result = MH_PLAYER_GET_CLASS( self )->pixel_aspect_ratio( self, pixel_n, pixel_d );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::pixel_aspect_ratio()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _result;
}		/* -----  end of function mh_player_pixel_aspect_ratio  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_seek
 *  Description:
 * =====================================================================================
 */
gboolean mh_player_seek( MHPlayer * self, guint position )
{
	gboolean _result = FALSE;
	g_return_val_if_fail( MH_IS_PLAYER( self ), _result );

	if( MH_PLAYER_GET_CLASS( self )->seek != NULL )
	{
		_result = MH_PLAYER_GET_CLASS( self )->seek( self, position );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::seek()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _result;
}		/* -----  end of function mh_player_seek  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_rate
 *  Description:
 * =====================================================================================
 */
gboolean mh_player_set_rate( MHPlayer * self, gdouble rate )
{
	gboolean _result = FALSE;
	g_return_val_if_fail( MH_IS_PLAYER( self ), _result );

	if( MH_PLAYER_GET_CLASS( self )->set_rate != NULL )
	{
		_result = MH_PLAYER_GET_CLASS( self )->set_rate( self, rate );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_rate()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _result;
}		/* -----  end of function mh_player_set_rate  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_forward
 *  Description:
 * =====================================================================================
 */
void mh_player_forward( MHPlayer * self )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->forward != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->forward( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::forward()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_forward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_backward
 *  Description:
 * =====================================================================================
 */
void mh_player_backward( MHPlayer * self )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->backward != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->backward( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::backward()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_backward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_forward_done
 *  Description:
 * =====================================================================================
 */
void mh_player_forward_done( MHPlayer * self )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->forward_done != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->forward_done( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::forward_done()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_forward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_backward_done
 *  Description:
 * =====================================================================================
 */
void mh_player_backward_done( MHPlayer * self )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->backward_done != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->backward_done( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::backward_done()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_backward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_play
 *  Description:
 * =====================================================================================
 */
gboolean mh_player_play( MHPlayer * self )
{
	gboolean _result = FALSE;
	g_return_val_if_fail( MH_IS_PLAYER( self ), _result );

	if( MH_PLAYER_GET_CLASS( self )->play != NULL )
	{
		_result = MH_PLAYER_GET_CLASS( self )->play( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::play()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _result;
}		/* -----  end of function mh_player_play  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_pause
 *  Description:
 * =====================================================================================
 */
gboolean mh_player_pause( MHPlayer * self )
{
	gboolean _result = FALSE;
	g_return_val_if_fail( MH_IS_PLAYER( self ), _result );

	if( MH_PLAYER_GET_CLASS( self )->pause != NULL )
	{
		_result = MH_PLAYER_GET_CLASS( self )->pause( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::pause()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _result;
}		/* -----  end of function mh_player_pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_stop
 *  Description:
 * =====================================================================================
 */
gboolean mh_player_stop( MHPlayer * self )
{
	gboolean _result = FALSE;
	g_return_val_if_fail( MH_IS_PLAYER( self ), _result );

	if( MH_PLAYER_GET_CLASS( self )->stop != NULL )
	{
		_result = MH_PLAYER_GET_CLASS( self )->stop( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::stop()'",
				G_OBJECT_TYPE_NAME( self ));
	}
	return _result;
}		/* -----  end of function mh_player_stop  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_close
 *  Description:
 * =====================================================================================
 */
void mh_player_close( MHPlayer * self )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->close != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->close( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::close()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_close  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_media_location
 *  Description:
 * =====================================================================================
 */
void mh_player_set_media_location( MHPlayer * self, const gchar * location )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_media_location != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_media_location( self, location );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_media_location()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_media_location  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_volume
 *  Description:
 * =====================================================================================
 */
void mh_player_set_volume( MHPlayer * self, gdouble volume )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_volume != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_volume( self, volume );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_volume()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_volume  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_mute
 *  Description:
 * =====================================================================================
 */
void mh_player_mute( MHPlayer * self )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->mute != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->mute( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::mute()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_mute  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_rotate
 *  Description:
 * =====================================================================================
 */
void mh_player_rotate( MHPlayer * self, guint value )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->rotate != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->rotate( self, value );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::rotate()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_rotate  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_playback_rate
 *  Description:
 * =====================================================================================
 */
void mh_player_set_playback_rate( MHPlayer * self, gdouble rate )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_playback_rate != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_playback_rate( self, rate );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_playback_rate()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_playback_rate  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_get_track_info
 *  Description:
 * =====================================================================================
 */
MHPbTrackInfo * mh_player_get_track_info( MHPlayer * self )
{
	g_return_val_if_fail( MH_IS_PLAYER( self ), NULL );

	MHPbTrackInfo * _res	=	NULL;

	if( MH_PLAYER_GET_CLASS( self )->get_track_info != NULL )
	{
		_res	=	MH_PLAYER_GET_CLASS( self )->get_track_info( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::get_track_info()'",
				G_OBJECT_TYPE_NAME( self ));
	}

	return _res;
}		/* -----  end of function mh_player_get_track_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_get_subtitle_info
 *  Description:
 * =====================================================================================
 */
MHPbSubtitleInfo * mh_player_get_subtitle_info( MHPlayer * self )
{
	g_return_val_if_fail( MH_IS_PLAYER( self ), NULL );

	MHPbSubtitleInfo * _res	=	NULL;

	if( MH_PLAYER_GET_CLASS( self )->get_subtitle_info != NULL )
	{
		_res	=	MH_PLAYER_GET_CLASS( self )->get_subtitle_info( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::get_subtitle_info()'",
				G_OBJECT_TYPE_NAME( self ));
	}

	return _res;
}		/* -----  end of function mh_player_get_subtitle_info  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_ptime_source
 *  Description:
 * =====================================================================================
 */
void mh_player_set_ptime_source( MHPlayer * self )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_ptime_source != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_ptime_source( self );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_ptime_source()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/* -----  end of function mh_player_set_ptime_source  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_player_set_intvaltime
 *  Description:
 * =====================================================================================
 */
void mh_player_set_intvaltime( MHPlayer * self, guint intvaltime )
{
	g_return_if_fail( MH_IS_PLAYER( self ));

	if( MH_PLAYER_GET_CLASS( self )->set_intvaltime != NULL )
	{
		MH_PLAYER_GET_CLASS( self )->set_intvaltime( self, intvaltime );
	}
	else
	{
		g_warning( "Class '%s' does not implement the pure virtual function 'MHPlayerClass::set_intvaltime()'",
				G_OBJECT_TYPE_NAME( self ));
	}
}		/*  -----  end of function mh_player_set_intvaltime  ----- */

