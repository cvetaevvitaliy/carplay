/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include <stdio.h>
#include "dev_carlife.h"
#include <mh_core.h>
//#include <mh_player.h>
#include <string.h>
//#include <gst/gst.h>
#include <CCarLifeLibWrapper_c.h>
#include <mh_dev.h>
#include <mh_pb.h>
#include <gst/gst.h>
#include <gst/app/gstappsrc.h>
#include <stdlib.h>
#include <mh_carlife.h>
#include <debug.h>
#include <CTransPackageProcess.h>
//#define ADB_LS_TMP	"adb shell ls /data/local/tmp"
//#define ADB_CHECK_BDSC_EXIST "adb shell ls /data/local/tmp/bdsc"
//#define ADB_CHECK_BDSC_EXEC "adb shell ps | grep bdsc | awk '{print $2}'"
//#define ADB_PUSH_BDSC_16 "adb push /etc/bdsc16 /data/local/tmp/bdsc"
//#define ADB_PUSH_BDSC_17 "adb push /etc/bdsc17 /data/local/tmp/bdsc"
//#define ADB_PUSH_BDSC_18 "adb push /etc/bdsc18 /data/local/tmp/bdsc"
//#define ADB_PUSH_BDSC_19 "adb push /etc/bdsc19 /data/local/tmp/bdsc"
//#define ADB_PUSH_BDSC_19_01 "adb push /etc/bdsc19_01 /data/local/tmp/bdsc"
//#define ADB_CHMOD_BDSC "adb shell chmod 777 /data/local/tmp/bdsc"
//#define ADB_EXE_BDSC "adb shell /data/local/tmp/bdsc &"
//#define ADB_CREATE_DALVIK_CACHE "adb shell mkdir /data/local/tmp/dalvik-cache"
//#define ADB_LS_BDIM	"adb shell ls /data/local/tmp | grep bdim"
//#define ADB_PUSH_BDIM "adb push /etc/bdim /data/local/tmp"
//#define ADB_CHMOD_BDIM "adb shell chmod 777 /data/local/tmp/bdim"
//#define ADB_PUSH_BDIM_JAR	"adb push /etc/bdim.jar /data/local/tmp"
//#define ADB_CHMOD_BDIM_JAR "adb shell chmod 777 /data/local/tmp/bdim.jar"
//#define ADB_EXE_BDIM "adb shell /data/local/tmp/bdim &"
//#define ADB_CHECK_APP_PROCESS "adb shell ps | grep app_process"
//#define ADB_GET_ANDROID_VER "adb -d shell getprop ro.build.version.release"
typedef struct _MHDevCarlifePrivate MHDevCarlifePrivate;
#define EA_NATIVE_CONTROL_HEAD_LEN	16
#define EA_NATIVE_MEDIA_HEAD_LEN 20

//add for aoa carlife start
#define DEBUG_SWITCH 1
#if DEBUG_SWITCH
#define g_message_dbg(format,...) g_message("dev_carlife.c:%d----->%s------->"format, __LINE__, __func__, ##__VA_ARGS__)
#else
#define g_message_dbg(format,...)
#endif

extern FILE * videoFp; 
extern FILE * audioFp; 
extern S_STATISTICS_INFO_t statisticsInfo;
struct _MHDevCarlifePrivate
{
	gint dummy;
};

G_DEFINE_TYPE_WITH_PRIVATE( MHDevCarlife, mh_dev_carlife, MH_TYPE_DEV )
extern MHDevCarlife * _carlife;
//enum {
//	/* Ios */
//	SIGNAL_0,
//	/* Signals */
//
//	N_SIGNALS
//};
//
//static guint signals[ N_SIGNALS ] = {0};
static uint64_t	UpTicks( void )
{
	uint64_t			nanos;
	struct timespec		ts;
	
	ts.tv_sec  = 0;
	ts.tv_nsec = 0;
	clock_gettime( CLOCK_MONOTONIC, &ts );
	nanos = ts.tv_sec;
	nanos *= 1000000000;
	nanos += ts.tv_nsec;
	return( nanos );
}


enum
{
	PROP_0,

	PROP_DEV_CARLIFE_EXIST,	
	PROP_DEV_CARLIFE_WIDTH, 
	PROP_DEV_CARLIFE_HEIGHT,
	PROP_DEV_CARLIFE_FRAMERATE,
	PROP_DEV_CARLIFE_MEDIA_CLIENT_NAME,
	PROP_DEV_CARLIFE_NAVI_CLIENT_NAME,
	PROP_DEV_CARLIFE_VRTTS_CLIENT_NAME,
	PROP_DEV_CARLIFE_VRRECORD_CLIENT_NAME,
	PROP_DEV_CARLIFE_MODULE_CONTROL,
	PROP_DEV_CARLIFE_HARDKEY,
	PROP_DEV_CARLIFE_VIDEO_STATUS,
	PROP_DEV_CARLIFE_CAR_VELOCITY,
	PROP_DEV_CARLIFE_CAR_GPS,
	PROP_DEV_CARLIFE_CAR_GYROSCOPE,
	PROP_DEV_CARLIFE_CAR_ACCELERATION,
	PROP_DEV_CARLIFE_CAR_OIL,
	PROP_DEV_CARLIFE_LAUNCH_MODE,
	PROP_DEV_CARLIFE_VIDEO_SINK,
	PROP_DEV_CARLIFE_AUDIO_SINK, 
	PROP_DEV_CARLIFE_SINK_SURFACEID,
	PROP_DEV_CARLIFE_CAR_INFO,
	PROP_DEV_CARLIFE_BT_START_IDENTIFY_REQ,
	PROP_DEV_CARLIFE_HU_BT_PAIR_INFO,
	PROP_DEV_CARLIFE_MD_BT_ADDRESS,
	PROP_DEV_CARLIFE_MD_BT_PASSKEY,
	PROP_DEV_CARLIFE_BT_HFP_INDICATION,
	PROP_DEV_CARLIFE_BT_HFP_CONNECTION,
	PROP_DEV_CARLIFE_BT_HFP_RESPONSE,
	PROP_DEV_CARLIFE_MD_OS,

	N_PROPERTIES
};
enum
{
	SIGNAL_DEV_CARLIFE_BT_HFP_REQUEST,
	SIGNAL_DEV_CARLIFE_N_SIGNALS
};
static GParamSpec *devCarlifeProperties[ N_PROPERTIES ] = { NULL, };
static guint signals[ SIGNAL_DEV_CARLIFE_N_SIGNALS]	=	{0};
void featureConfigRequest();

void ios_videoDataReceive( const uint8_t *data, uint32_t len);
void cmdMediaInfo(S_MEDIA_INFO_t* info);
void mediaInit(S_AUDIO_INIT_PARAMETER_t *initParam);
void ios_mediaNormalData(const uint8_t *data, uint32_t len);
void mediaPause();
void cmdMediaProgressBar(S_MEDIA_PROGRESS_BAR_t* data);
void cmdForeground();
void cmdBackground();
void cmdUIActionSound(void);
void vrInit( S_AUDIO_INIT_PARAMETER_t * initParam);
void ios_vrNormalData( const uint8_t * data, uint32_t len);
void vrStop();
void cmdMicRecordRecogStart();
void cmdMicRecordEnd();
void naviInit(S_AUDIO_INIT_PARAMETER_t *initParam);
void ios_naviNormalData(const uint8_t *data, uint32_t len);
void naviStop();
void cmdMicRecordWakeupStart();
void * adb_wait_for_device( void * user_data);
void cmdGoToDeskTop();
void cmdVideoEncoderInitDone(S_VIDEO_ENCODER_INIT_DONE_t* videoEncoderInitDone);
static void _carlife_init();
static uint64_t running = 100000000;
static uint64_t VRttsRunning	=	100000000; 
static uint64_t naviRunning	=	100000000; 
uint8_t* ios_video_long_buf = NULL;
uint32_t len_ios_video_long_buf = 0;
int vrEndFlag = 1;
//#define DUP_CARLIFE_MEDIA_DATA 
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_property
 *  Description:
 * =====================================================================================
 */
static void _get_property( GObject * object, guint property_id, GValue * value,
		        GParamSpec * spec)
{
	MHDevCarlife * _self  =   MH_DEV_CARLIFE( object );
	void * _videoSink;

	switch( property_id )
	{
		case PROP_DEV_CARLIFE_EXIST:
			g_value_set_uint( value, _self->exist);
			break;
		case PROP_DEV_CARLIFE_WIDTH:
			g_value_set_uint( value, _self->width);
			break;
		case PROP_DEV_CARLIFE_HEIGHT:
			g_value_set_uint( value, _self->height);
			break;
		case PROP_DEV_CARLIFE_FRAMERATE:
			g_value_set_uint( value, _self->frameRate);
			break;
		case PROP_DEV_CARLIFE_MD_BT_ADDRESS:
			g_value_set_string( value, _self->md_bt_address);
			break;
		case PROP_DEV_CARLIFE_MD_BT_PASSKEY:
			g_value_set_string( value, _self->md_bt_passKey);
			break;
		case PROP_DEV_CARLIFE_MD_OS:
			g_value_set_string( value, _self->md_os);
			break;
		default:
			break;
	}
}       /*  -----  end of static function _get_property  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_property
 *  Description:
 * =====================================================================================
 */
static void _set_property( GObject * object, guint property_id, const GValue * value,
		        GParamSpec * spec)
{
	g_message("%s", __func__);
	MHDevCarlife * _self  =   MH_DEV_CARLIFE( object );


	switch( property_id )
	{
	
		case PROP_DEV_CARLIFE_WIDTH:
			_self->width	=	g_value_get_uint( value);
			g_message("carlife setup_property---->width:%d", _self->width);
			break;
		case PROP_DEV_CARLIFE_HEIGHT:
			_self->height	=	g_value_get_uint( value);
			g_message("carlife setup_property---->height:%d", _self->height);
			break;
		case PROP_DEV_CARLIFE_FRAMERATE:
			_self->frameRate	=	g_value_get_uint( value);
			break;

		case PROP_DEV_CARLIFE_MEDIA_CLIENT_NAME:
			_self->audio_param->client_name	=	g_strdup( g_value_get_string( value ));
			g_message("carlife setup_property->audio_param client_name:%s", _self->audio_param->client_name);
			break;
		case PROP_DEV_CARLIFE_NAVI_CLIENT_NAME:
			_self->navi_param->client_name	=	g_strdup( g_value_get_string( value ));
			g_message("carlife setup_property->navi_param client_name:%s", _self->navi_param->client_name);
			break;
		case PROP_DEV_CARLIFE_VRTTS_CLIENT_NAME:
			_self->VRtts_param->client_name	=	g_strdup( g_value_get_string( value ));
			g_message("carlife setup_property->VRtts_param client_name:%s", _self->VRtts_param->client_name);
			break;
		case PROP_DEV_CARLIFE_VRRECORD_CLIENT_NAME:
			g_message("vr record is null");
			break;
		case PROP_DEV_CARLIFE_MODULE_CONTROL:
			{
				const gchar * _value;
				S_MODULE_STATUS_CONTROL_t _control;

				_value	=	g_value_get_string( value);
				g_message("%s--->%s", __func__, _value);
				uint32_t _param		=	atoi(_value);
				_control.moduleID	=	_param/10;
				_control.statusID	=	_param%10;
	
				g_message("carlife module_control->_module:%d, _status:%d", _control.moduleID, _control.statusID);
				if( !g_strcmp0( _self->md_os, "android"))
				{
					C_cmdModuleControl( &_control);	

				}
				else
				{
					int _len	=	0;

					ios_sendModuleControl( &_control, _self->sendPackage, &_len);

					mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
				}

			}

			break;
		case PROP_DEV_CARLIFE_HARDKEY:
			{
				S_TOUCH_CAR_HARD_KEY_CODE_t * _key	=	g_new0( S_TOUCH_CAR_HARD_KEY_CODE_t, 1);
				uint32_t _len	=	0;
				_key->keycode	=	g_value_get_uint( value);
				if( !g_strcmp0(_self->md_os, "ios"))
				{
					ios_sendCmdHardkey( _key, _self->sendPackage, &_len); 
					g_message("ios PROP_DEV_CARLIFE_HARDKEY start output hex");
					DEBUG_HEX_DISPLAY(_self->sendPackage , _len)
					g_message("ios PROP_DEV_CARLIFE_HARDKEY end output hex");
					mh_dev_write_ea_data( _self->iap2Dev, _self->sendPackage , _len);
				}
				else
				{
					C_ctrlTouchCarHardKeyCode( _key);
				}
				g_free( _key);
			}
			break;
		case PROP_DEV_CARLIFE_VIDEO_STATUS:
			{
				int _value	=	g_value_get_uint( value);
				if( !g_strcmp0( _self->md_os, "android"))
				{
					switch( _value)
					{
						case 0:
							C_cmdVideoEncoderPause();
							break;
						case 1:
							C_cmdVideoEncoderReset();
							break;
						case 2:
							g_message("set_property-->C_cmdVideoEncoderStart");
							gst_element_set_state( _self->video_param->pipeline, GST_STATE_PLAYING);
							C_cmdVideoEncoderStart();
							break;
						default:
							g_message("set Properties video status error status");
							break;
					}
				}
				else
				{
					int _len	=	0;
					switch( _value)
					{
						case 0:
							{
								g_message("set_property-->ios-->ios_sendCmdVideoEncoderPause");
								ios_sendCmdVideoEncoderPause( _self->sendPackage, &_len);

								mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
							}

							break;
						case 1:
							{
								g_message("set_property-->ios-->ios_sendCmdVideoEncoderReset");
								ios_sendCmdVideoEncoderReset( _self->sendPackage, &_len);

								mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
							}

							break;
						case 2:
							{
								g_message("set_property-->ios-->ios_sendCmdVideoEncoderStart");
								gst_element_set_state( _self->video_param->pipeline, GST_STATE_PLAYING);
								ios_sendCmdVideoEncoderStart( _self->sendPackage, &_len);
								//								gint len	=	mh_dev_write_ea_data( _self->iap2Dev, _self->sendPackage , _len);
								gint len	=	mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
								g_message("mh_dev_write_ea_native_data return %d", len);


							}

							break;
						default:
							break;
					}
				}
			}
			break;
		case PROP_DEV_CARLIFE_CAR_VELOCITY:
			{
				S_CAR_VELOCITY_t * _velocity	=	g_new0( S_CAR_VELOCITY_t, 1);

				GVariant * _var;
				g_variant_get( g_value_get_variant( value), "v", &_var);

				g_variant_get( _var, "(ut)", &_velocity->speed, &_velocity->timeStamp);

				g_message("dev_carlife.c->%s->_velocity:%d, %d", __func__, _velocity->speed,
						_velocity->timeStamp);
				if( !g_strcmp0( _self->md_os, "android"))
				{
					C_cmdCarVelocity( _velocity);
				}
				else
				{
					int _len	=	0;
					ios_sendCarVelocity( _velocity, _self->sendPackage, &_len);
					mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
				}

				g_free( _velocity);
			}
			break;
		case PROP_DEV_CARLIFE_CAR_GPS:
			{
				S_CAR_GPS_t * _gps	=	g_new0( S_CAR_GPS_t, 1);

				GVariant * _var;
				GVariant * _var1;
				GVariantIter * _it;

				_var	=	g_value_get_variant( value);

				g_variant_get(_var, "v", &_var1);

				g_variant_get( _var1, "au", &_it);

				g_variant_iter_loop( _it, "u", &_gps->antennaState);
				g_variant_iter_loop( _it, "u", &_gps->signalQuality);
				g_variant_iter_loop( _it, "u", &_gps->latitude);
				g_variant_iter_loop( _it, "u", &_gps->longitude);
				g_variant_iter_loop( _it, "u", &_gps->height);

				g_variant_iter_loop( _it, "u", &_gps->speed);
				g_variant_iter_loop( _it, "u", &_gps->heading);
				g_variant_iter_loop( _it, "u", &_gps->year);
				g_variant_iter_loop( _it, "u", &_gps->month);
				g_variant_iter_loop( _it, "u", &_gps->day);

				g_variant_iter_loop( _it, "u", &_gps->hrs);
				g_variant_iter_loop( _it, "u", &_gps->min);
				g_variant_iter_loop( _it, "u", &_gps->sec);
				g_variant_iter_loop( _it, "u", &_gps->fix);
				g_variant_iter_loop( _it, "u", &_gps->hdop);

				g_variant_iter_loop( _it, "u", &_gps->pdop);
				g_variant_iter_loop( _it, "u", &_gps->vdop);
				g_variant_iter_loop( _it, "u", &_gps->satsUsed);
				g_variant_iter_loop( _it, "u", &_gps->satsVisible);
				g_variant_iter_loop( _it, "u", &_gps->horPosError);

				g_variant_iter_loop( _it, "u", &_gps->vertPosError);
				g_variant_iter_loop( _it, "u", &_gps->northSpeed);
				g_variant_iter_loop( _it, "u", &_gps->eastSpeed);
				g_variant_iter_loop( _it, "u", &_gps->vertSpeed);
				


				g_message("dev_carlife.c->%s->gps:%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d",
						__func__, _gps->antennaState, _gps->signalQuality, _gps->latitude, _gps->longitude, _gps->height,
						_gps->speed, _gps->heading, _gps->year, _gps->month, _gps->day,
						_gps->hrs, _gps->min, _gps->sec, _gps->fix, _gps->hdop,
						_gps->pdop, _gps->vdop, _gps->satsUsed, _gps->satsVisible, _gps->horPosError,
						_gps->vertPosError, _gps->northSpeed, _gps->eastSpeed, _gps->vertSpeed );
				if( !g_strcmp0( _self->md_os, "android"))
				{
					C_cmdCarGPS( _gps);

				}
				else
				{
					int _len	=	0;

					ios_sendCarGPS( _gps, _self->sendPackage, &_len);

					mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
				}

				g_free( _gps);
				g_variant_iter_free (_it);

			}
			break;
		case PROP_DEV_CARLIFE_CAR_GYROSCOPE:
			{
				S_CAR_GYROSCOPE_t * _gyroscope	=	g_new0( S_CAR_GYROSCOPE_t, 1);

				GVariant * _var;

				g_variant_get(g_value_get_variant( value), "v", &_var);

				g_variant_get( _var, "(idddt)", &_gyroscope->gyroType,
						&_gyroscope->gyroX, &_gyroscope->gyroY, &_gyroscope->gyroZ, &_gyroscope->timeStamp);

				if( !g_strcmp0( _self->md_os, "android"))
				{
					C_cmdCarGyroscope( _gyroscope);

				}
				else
				{
					int _len	=	0;

					ios_sendCarGyroscope( _gyroscope, _self->sendPackage, &_len);

					mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
				}


				g_free( _gyroscope);
			}
			break;
		case PROP_DEV_CARLIFE_CAR_ACCELERATION:
			{
				S_CAR_ACCELERATION_t * _acceleration	=	g_new0( S_CAR_ACCELERATION_t, 1);

				GVariant * _var;

				g_variant_get( g_value_get_variant( value), "v", &_var);

				g_variant_get( _var, "(dddt)", &_acceleration->accX,
						&_acceleration->accY, &_acceleration->accZ, &_acceleration->timeStamp);


				if( !g_strcmp0( _self->md_os, "android"))
				{
					C_cmdCarAcceleration( _acceleration);

				}
				else
				{
					int _len	=	0;

					ios_sendCarAcceleration( _acceleration, _self->sendPackage, &_len);

					mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
				}



				g_free( _acceleration);
			}
			break;
		case PROP_DEV_CARLIFE_CAR_OIL:
			{
				S_CAR_OIL_t * _oil	=	g_new0( S_CAR_OIL_t, 1);

				GVariant * _var;

				g_variant_get( g_value_get_variant( value), "v", &_var);

				g_variant_get( _var, "(iib)", &_oil->level, &_oil->range, &_oil->lowFullWarning );

				g_message("dev_carlife.c->%s->_oil:%d, %d, %d", __func__, _oil->level,
						_oil->range, _oil->lowFullWarning);


				if( !g_strcmp0( _self->md_os, "android"))
				{
					C_cmdCarOil( _oil);

				}
				else
				{
					int _len	=	0;

					ios_sendCarOil(_oil, _self->sendPackage, &_len);

					mh_dev_write_ea_native_data( _self->iap2Dev, _self->sendPackage , _len);
				}


				g_free( _oil);
			}

			break;
		case PROP_DEV_CARLIFE_LAUNCH_MODE:
			{
				_self->launch_mode	=	g_value_get_uint( value );
			}
			break;
		case PROP_DEV_CARLIFE_VIDEO_SINK:
			{

				_self->video_sink_name	=	g_strdup(g_value_get_string( value ));
				g_message("carlife setup_property->video_sink_name:%s", _self->video_sink_name	);
			}
			break;
		case PROP_DEV_CARLIFE_AUDIO_SINK:
			{

				_self->audio_sink_name	=	g_strdup(g_value_get_string( value ));
				g_message("carlife setup_property->audio_sink_name:%s", _self->audio_sink_name);
			}
			break;
		case PROP_DEV_CARLIFE_SINK_SURFACEID:
			{

				_self->surfaceid	=	g_value_get_uint( value );
				g_message("carlife setup_property->surfaceid:%d", _self->surfaceid);
			}
			break;
		case PROP_DEV_CARLIFE_CAR_INFO:
			{
				g_message("dev_carlife.c->%s-->PROP_DEV_CARLIFE_CAR_INFO", __func__);

				S_HU_INFO_t *_huInfo	=	g_new0(S_HU_INFO_t, 1);

				GVariant * _var, *_var1;

				GVariantIter * _it;

				g_variant_get( g_value_get_variant( value), "v", &_var);

				g_variant_get( _var, "(uv)",& (_huInfo->sdk_int), &_var1);

				g_variant_get( _var1, "as", &_it);

				g_variant_iter_loop( _it, "s", &(_huInfo->os) );
				g_variant_iter_loop( _it, "s", &(_huInfo->board) );
				g_variant_iter_loop( _it, "s", &(_huInfo->bootloader) );
				g_variant_iter_loop( _it, "s", &(_huInfo->brand) );
				g_variant_iter_loop( _it, "s", &(_huInfo->cpu_abi) );
				g_variant_iter_loop( _it, "s", &(_huInfo->cpu_abi2) );
				g_variant_iter_loop( _it, "s", &(_huInfo->device)  );
				g_variant_iter_loop( _it, "s", &(_huInfo->display)  );
				g_variant_iter_loop( _it, "s", &(_huInfo->fingerprint) );
				g_variant_iter_loop( _it, "s", &(_huInfo->hardware) );
				g_variant_iter_loop( _it, "s", &(_huInfo->host) );
				g_variant_iter_loop( _it, "s", &(_huInfo->cid) );
				g_variant_iter_loop( _it, "s", &(_huInfo->manufacturer) );
				g_variant_iter_loop( _it, "s", &(_huInfo->model) );
				g_variant_iter_loop( _it, "s", &(_huInfo->product) );
				g_variant_iter_loop( _it, "s", &(_huInfo->serial) );
				g_variant_iter_loop( _it, "s", &(_huInfo->codename) );
				g_variant_iter_loop( _it, "s", &(_huInfo->incremental) );
				g_variant_iter_loop( _it, "s", &(_huInfo->release) );
				g_variant_iter_loop( _it, "s", &(_huInfo->sdk) );
				g_variant_iter_loop( _it, "s", &(_huInfo->token) );
				g_variant_iter_loop( _it, "s", &(_huInfo->btaddress) );
				g_message("%s->PROP_DEV_CARLIFE_CAR_INFO->btaddress:%s", __func__, _huInfo->btaddress);
				C_cmdHUInfro( _huInfo);
				g_free( _huInfo->os);
				g_free( _huInfo->board);
				g_free( _huInfo->bootloader);
				g_free( _huInfo->brand);
				g_free( _huInfo->cpu_abi);
				g_free( _huInfo->cpu_abi2);
				g_free( _huInfo->device);
				g_free( _huInfo->display);
				g_free( _huInfo->fingerprint);
				g_free( _huInfo->hardware);
				g_free( _huInfo->host);
				g_free( _huInfo->cid);
				g_free( _huInfo->manufacturer);
				g_free( _huInfo->model);
				g_free( _huInfo->product);
				g_free( _huInfo->serial);
				g_free( _huInfo->codename);
				g_free( _huInfo->incremental);
				g_free( _huInfo->release);
				g_free( _huInfo->sdk);
				g_free( _huInfo->token);
				g_free( _huInfo->btaddress);
				g_free( _huInfo);

				g_variant_iter_free (_it);

			}
			break;

		case PROP_DEV_CARLIFE_BT_START_IDENTIFY_REQ:
			{
				S_BT_START_IDENTIFY_REQ_t * _bt_start	=	g_new0(S_BT_START_IDENTIFY_REQ_t, 1);

				GVariant * _var;

				g_variant_get( g_value_get_variant( value), "v", &_var);

				g_variant_get( _var, "s", &(_bt_start->address));

				g_message("dev_carlife.c->%s-->PROP_DEV_CARLIFE_BT_START_IDENTIFY_REQ->address:%s", __func__, _bt_start->address);

				C_cmdBTStartIdentifyReq( _bt_start);

				g_free( _bt_start->address);

				g_free( _bt_start);



			}
			break;
		case PROP_DEV_CARLIFE_HU_BT_PAIR_INFO:
			{
				S_BT_PAIR_INFO_t * _info	=	g_new0(S_BT_PAIR_INFO_t, 1);

				GVariant * _var;

				g_variant_get( g_value_get_variant( value), "v", &_var);

				g_variant_get( _var, "(ssssssu)", &(_info->address), &(_info->passKey), &(_info->hash),
						&(_info->randomizer), &(_info->uuid), &(_info->name), &(_info->status));

				g_message("dev_carlife.c->%s-->PROP_DEV_CARLIFE_HU_BT_PAIR_INFO->address:%s, passKey:%s, hash:%s,\
						randomizer:%s, uuid:%s, name:%s, status:%d", __func__, _info->address, _info->passKey, _info->hash,
						_info->randomizer, _info->uuid, _info->name, _info->status);
				_info->passKey	=	NULL;
				_info->hash	=	NULL;
				_info->randomizer =	 NULL;
				_info->uuid	=	NULL;
			

				C_cmdHUBTPairInfro( _info);

				g_free( _info);



			}
			break;
		case PROP_DEV_CARLIFE_BT_HFP_INDICATION:
			{
				g_message("%s->PROP_DEV_CARLIFE_BT_HFP_INDICATION", __func__);
				GVariant * _var;

				S_BT_HFP_INDICATION_t _indication;

				g_variant_get( g_value_get_variant(value), "v", &_var);

				g_variant_get(_var, "(usss)", &(_indication.state), &(_indication.phoneNum),
						&(_indication.name), &(_indication.address));
				g_message("%s-->indication->state:%d, phoneNum:%s, name:%s, address:%s",__func__,
						_indication.state, _indication.phoneNum, _indication.name, _indication.address);
				C_cmdBtHfpIndication(&_indication);
			}
			break;

		case PROP_DEV_CARLIFE_BT_HFP_CONNECTION:
			{
				g_message("%s->PROP_DEV_CARLIFE_BT_HFP_CONNECTION", __func__);

				GVariant * _var;

				S_BT_HFP_CONNECTION_t _conn;

				g_variant_get( g_value_get_variant(value), "v", &_var);

				g_variant_get(_var, "(uss)", &(_conn.state), &(_conn.address),
						&(_conn.name));
				g_message("%s-->connection->state:%d, address:%s, name:%s",__func__,
						_conn.state, _conn.address, _conn.name);

				C_cmdBtHfpConnection(&_conn);
			}
			break;
		case PROP_DEV_CARLIFE_BT_HFP_RESPONSE:
			{
				g_message("%s->PROP_DEV_CARLIFE_BT_HFP_RESPONSE", __func__);

				GVariant * _var;

				S_BT_HFP_RESPONSE_t _response;

				g_variant_get( g_value_get_variant(value), "v", &_var);

				g_variant_get(_var, "(uuu)", &(_response.status), &(_response.C_cmd),
						&(_response.dtmfCode));
				g_message("%s-->connection->status:%d, C_cmd:%d, dtmfCode:%d",__func__,
						_response.status, _response.C_cmd, _response.dtmfCode);

				C_cmdBTHfpResponse(&_response);
			}
			break;

		default:
			break;
	}
}       /*  -----  end of static function _set_property  ----- */
static gboolean pipeline_quit( gpointer object)
{
	g_message("%s-->in", __func__);
	MHDevCarlife * _self	=	(MHDevCarlife*)object;
	GThread * _thread	=	g_thread_self();
	if( _self->audio_param->pipeline != NULL)
	{
		gst_element_set_state( _self->audio_param->pipeline, GST_STATE_NULL);

		g_message("%s->gst_element_set_state(audio)->GST_STATE_NULL", __func__);

		gst_object_unref( GST_OBJECT( _self->audio_param->pipeline));

		g_main_loop_quit( _self->audio_param->mainloop);

		g_thread_join( _self->audio_param->thread);

		g_main_context_unref( _self->audio_param->context );
//		g_thread_unref( _self->audio_param->thread);

		_self->audio_param->pipeline == 	NULL;
		if( _self->audio_param->client_name != NULL)
		{
			g_free( _self->audio_param->client_name);
		}
		g_free( _self->audio_param);

		_self->audio_param =	NULL;


	}
	if( _self->video_param->pipeline != NULL)
	{
		gst_element_set_state( _self->video_param->pipeline, GST_STATE_NULL);

		g_message("%s->gst_element_set_state(video)->GST_STATE_NULL", __func__);

		gst_object_unref( GST_OBJECT( _self->video_param->pipeline));

		
		g_main_loop_quit( _self->video_param->mainloop);

		g_thread_join( _self->video_param->thread);


		g_main_context_unref( _self->video_param->context );
//		g_thread_unref( _self->video_param->thread);
		_self->video_param->pipeline == 	NULL;

		g_free( _self->video_param);

		_self->video_param	=	NULL;

	}
	if( _self->navi_param->pipeline != NULL)
	{
		gst_element_set_state( _self->navi_param->pipeline, GST_STATE_NULL);

		g_message("%s->gst_element_set_state(navi)->GST_STATE_NULL", __func__);

		gst_object_unref( GST_OBJECT( _self->navi_param->pipeline));

		g_main_loop_quit( _self->navi_param->mainloop);

		g_thread_join( _self->navi_param->thread);

		g_main_context_unref( _self->navi_param->context );

		_self->navi_param->pipeline == 	NULL;
//		g_thread_unref( _self->navi_param->thread);
		if( _self->navi_param->client_name != NULL)
		{
			g_free( _self->navi_param->client_name);
		}


		g_free( _self->navi_param);

		_self->navi_param	=	NULL;


	}
	if( _self->VRtts_param->pipeline != NULL)
	{
		gst_element_set_state( _self->VRtts_param->pipeline, GST_STATE_NULL);

		g_message("%s->gst_element_set_state(VRtts)->GST_STATE_NULL", __func__);

		gst_object_unref( GST_OBJECT( _self->VRtts_param->pipeline));

		g_main_loop_quit( _self->VRtts_param->mainloop);

		g_thread_join( _self->VRtts_param->thread);

		g_main_context_unref( _self->VRtts_param->context );
//		g_thread_unref( _self->VRtts_param->thread);
		_self->VRtts_param->pipeline == 	NULL;

		if( _self->VRtts_param->client_name != NULL)
		{
			g_free( _self->VRtts_param->client_name);
		}


		g_free( _self->VRtts_param);

		_self->VRtts_param	=	NULL;

	}
	if( _self->VRRecord_param != NULL)
	{

		g_message("%s->gst_element_set_state(VRRecord)->GST_STATE_NULL", __func__);

		g_main_loop_quit( _self->VRRecord_param->mainloop);

		g_thread_join( _self->VRRecord_param->thread);

		g_main_context_unref( _self->VRRecord_param->context);
//		g_thread_unref( _self->VRRecord_param->thread);
		g_free( _self->VRRecord_param);

		_self->VRRecord_param	=	NULL;



	}
	g_main_loop_quit( _self->pipe_param->mainloop);
	g_message("%s-->out", __func__);
	return G_SOURCE_REMOVE;
}
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispose
 *  Description:
 * =====================================================================================
 */
static void _dispose( GObject * object )
{
	G_OBJECT_CLASS( mh_dev_carlife_parent_class )->dispose( object );


}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _finalize
 *  Description:
 * =====================================================================================
 */
static void _finalize( GObject * object )
{
	MHDevCarlife * _self	=	MH_DEV_CARLIFE( object );
	MHDev * _dev	=	(MHDev*)_self;
//	C_connection_disconnect();
	g_message("carlife--->_dispose---->%p", _self);
	g_free( _self->android_version);

	g_free( _self->MSlistener);
	if( _self->video_sink_name)
	{
		 g_free( _self->video_sink_name);
	}	
	if( _self->audio_sink_name)
	{
		 g_free( _self->audio_sink_name);
	}
	if( _self->md_bt_address)
	{
		 g_free( _self->md_bt_address);
	}
	if( _self->md_bt_passKey)
	{
		 g_free( _self->md_bt_passKey);
	}
	if( _dev->serial)
	{
		g_free(_dev->serial); 
	}
	
//	g_free( _dev->type);
	if( g_thread_self() != _self->pipe_param->thread)
	{
		g_message("%s---->change thread", __func__);
		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, pipeline_quit, object, NULL);

		g_source_attach( _source, _self->pipe_param->context );

		g_source_unref( _source );

		g_thread_join( _self->pipe_param->thread );
		

	}
	else
	{
		g_message("%s----->not change thread", __func__);
		pipeline_quit( object);
	}

	g_main_context_unref( _carlife->pipe_param->context );

	g_free( _carlife->pipe_param);

//	if( !g_strcmp0( _self->md_os, "android"))
//	{
//		g_thread_try_new("adb_wait", adb_wait_for_device, NULL, NULL);
//	}
	g_free( _self->md_os);

	g_message("dev_carlife.c--->%s->%p", __func__, object);

	//	MHDevCarlife * _self	=	MH_DEV_CARLIFE( object );
	g_message("%s--->_carlife= NULL", __func__);

	_carlife	=	NULL;


	G_OBJECT_CLASS( mh_dev_carlife_parent_class )->finalize( object );

	g_message("%s--->out" , __func__);

}


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _createThread
 *  Description:  
 * =====================================================================================
 */
void *mediaReceiveThread(void *arg){

	MHDevCarlife * _dev	=	(MHDevCarlife *)arg;
	while(1){
		if(-1==C_mediaReceiveOperation()){
			g_message("media channel thread exit!");
			break;
		}
		else if( _dev != _carlife)
		{
			g_message("%s--->%p", __func__, _dev);
			break;
		}
	}
	return NULL;
}
void *videoReceiveThread(void *arg){
	MHDevCarlife * _dev	=	(MHDevCarlife *)arg;

//	C_cmdVideoEncoderInit(&initVideoParam);
	while(1){
		if(-1==C_videoReceiveOperation()){
			g_message("video channel receive thread exit!");
			break;
		}
		else if( _dev != _carlife)
		{
			g_message("%s--->%p", __func__, _dev);
			break;
		}
	}
	return NULL;
}
void *cmdReceiveThread(void *arg){
	MHDevCarlife * _dev	=	(MHDevCarlife *)arg;

	//register call back
	S_HU_PROTOCOL_VERSION_t huProtocolVersion={1,0};
//	C_cmdHUProtoclVersion( &huProtocolVersion );
	C_cmdHUProtoclVersion( &huProtocolVersion );
//	C_cmdHuAuthenRequest(&authenRequest);
	char * _getState;
	Cmd_Ret * _res;

	while(1)
	{
		//receive data from command channel
		if(-1==C_cmdReceiveOperation())
		{
			g_message_dbg("command channel receive thread exit!");
//			char * _cmd	=	g_strdup("adb -d devices");
//			Cmd_Ret * _res	=	 Cmd_With_Result( _cmd);
//			if( _res)
//			{
//				g_message("%s-->%s", __func__, _res->data );
//				int _len = 0;
//				_len	=	strlen( _res->data);
//				g_message("%s-->%d", __func__, _len);
//				if( _len < 28)
//				{
//
//				}
//				else
//				{

				g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_APP_EXIT);

//				}

//			}
			break;
		}
		else if( _dev != _carlife)
		{
			g_message("%s--->%p", __func__, _dev);
			break;
		}
	}
	return NULL;
}
void *ttsReceiveThread(void *arg){
	MHDevCarlife * _dev	=	(MHDevCarlife *)arg;


	while(1){
		if(-1==C_ttsReceiveOperation()){
			g_message("tts channel thread exit!");
			break;
		}
		else if( _dev != _carlife)
		{
			g_message("%s--->%p", __func__, _dev);
			break;
		}

	
	}
	return NULL;
}
void *vrReceiveThread(void *arg){
	MHDevCarlife * _dev	=	(MHDevCarlife *)arg;


	while(1)
	{
		if(-1==C_vrReceiveOperation())
		{
			g_message("vr channel thread exit!");
			break;
		}
		else if( _dev != _carlife)
		{
			g_message("%s--->%p", __func__, _dev);
			break;
		}

	}
	return NULL;
}

static void * _createThread( MHDevCarlife * carlife)
{
	pthread_t _id;
	int _pthreadRes;
	_pthreadRes=pthread_create(&_id, NULL, cmdReceiveThread, carlife);
	if(_pthreadRes!=0)
	{
		g_message("cmdReceiveThread create failed errno:%d", _pthreadRes);
		return NULL;
	}
	else
	{
		carlife->cmd_thread	=	_id;
		g_message("cmdReceiveThread create!");
	}

	_pthreadRes=pthread_create(&_id, NULL, videoReceiveThread, carlife);
	if(_pthreadRes!=0)
	{
		g_message("videoReceivThread create failed errno:%d", _pthreadRes);
	}
	else
	{
		carlife->video_thread	=	_id;
		g_message("videoReceivThread create !");
	}

	_pthreadRes=pthread_create(&_id, NULL, mediaReceiveThread, carlife);
	if(_pthreadRes!=0)
	{
		g_message("mediaReceivThread create failed errno:%d", _pthreadRes);
	}
	else
	{
		carlife->media_thread	=	_id;
		g_message("mediaReceivThread create !");
	}

	_pthreadRes=pthread_create(&_id, NULL, ttsReceiveThread, carlife);
	if(_pthreadRes!=0)
	{
		g_message("ttsReceivThread create failed errno:%d", _pthreadRes);
	}
	else
	{
		carlife->tts_thread	=	_id;
		g_message("ttsReceivThread create !");
	}

	_pthreadRes=pthread_create(&_id, NULL, vrReceiveThread, carlife);
	if(_pthreadRes!=0)
	{
		g_message("vrReceivThread create failed errno:%d", _pthreadRes);
	}
	else
	{
		carlife->vr_thread	=	_id;
		g_message("vrReceivThread create !");
	}

	return NULL;
}		/* -----  end of static function _createThread  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  check_bdsc
 *  Description:  
 * =====================================================================================
 */
static gboolean check_bdsc_exist()
{
	gboolean _res	=	FALSE;
	Cmd_Ret * _result	=	NULL;
	char * _cmd	=	g_strdup_printf("adb -s %s shell ls /data/local/tmp/bdsc", MH_DEV( _carlife)->serial);
	_result	=	Cmd_With_Result( _cmd);
	if( g_strrstr( _result->data,"No") != NULL || _result->len == 0)
	{
		g_message("bdsc is not exist in MD, HU can push bdsc to MD");
	}
	else
	{
		g_message("%s---->%s", __func__, _result->data);
		_res	=	TRUE;
	}
	g_free( _result);
	g_free( _cmd);
	return _res;

}		/* -----  end of static function check_bdsc  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  check_bdsc_exec
 *  Description:  
 * =====================================================================================
 */
static void check_bdsc_exec()
{
	Cmd_Ret * _result	=	NULL;
	int _pid	=	0;	
	char * _checkBdscExec	=	g_strdup_printf("adb -s %s shell ps | grep bdsc | awk '{print $2}'", MH_DEV( _carlife)->serial);
	_result	=	Cmd_With_Result( _checkBdscExec);
	g_message("_checkBdscExec->return len:%d, data:%s", _result->len, _result->data);
	if(  _result != NULL)
	{
		if(	_result->len > 0)
		{
			g_message("\n\n\nbdsc is running\n\n\n");

		}
		else
		{

			char * _cmd	=	g_strdup_printf("adb -s %s shell chmod 777 /data/local/tmp/bdsc", MH_DEV( _carlife)->serial);

			doCmd( _cmd);

			g_free( _cmd );

			_cmd	=	g_strdup_printf("adb -s %s shell /data/local/tmp/bdsc &", MH_DEV( _carlife)->serial);

			doCmd( _cmd);

			sleep(1);
			_result	=	Cmd_With_Result( _checkBdscExec);
			if( _result != NULL)
			{
				g_message("\n\n\n%s return != NULL ", _checkBdscExec);
				if( _result->len != 0)
				{
					g_message("return len !=0 --->%s\n\n\n", _result->data);
				}
				else
				{
					doCmd( _cmd);

					g_message("return len == 0\n\n\n");
				}
			}
			else
			{
				g_message("\n\nreturn == NULL\n\n");
			}

			g_free( _cmd);

		}
		g_free( _result);
	}
	g_free( _checkBdscExec);

}		/* -----  end of static function check_bdsc_exec  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  check_bdsc
 *  Description:  
 * =====================================================================================
 */
static void check_bdsc( MHDevCarlife * carlife)
{
	g_message("android_version:%s", carlife->android_version);
	gboolean _bdscExist;
	Cmd_Ret * _result	=	NULL;
	char * _cmd;
	if( g_strrstr( carlife->android_version, "4.1")	!=	NULL)
	{
		
		g_message("match 4.1");

		_bdscExist	=	check_bdsc_exist();
		if( _bdscExist == FALSE)
		{
			char * _pushBdsc16	=	g_strdup_printf("adb -s %s push /etc/bdsc16 /data/local/tmp/bdsc", MH_DEV( _carlife)->serial);

			doCmd( _pushBdsc16);

			g_free( _pushBdsc16);
		}
	}
	else if( g_strrstr( carlife->android_version, "4.3")	!=	NULL)
	{
		g_message("match 4.3");
		_bdscExist	=	check_bdsc_exist();
		if( _bdscExist == FALSE)
		{
			char * _pushBdsc18	=	g_strdup_printf("adb -s %s push /etc/bdsc18 /data/local/tmp/bdsc", MH_DEV( _carlife)->serial);

			doCmd( _pushBdsc18);

			g_free( _pushBdsc18);
		}

		_cmd	=	g_strdup_printf("adb -s %s shell /data/local/tmp/bdsc &", MH_DEV( _carlife)->serial);

		doCmd( _cmd);

		g_free( _cmd);
	}
	else if( g_strrstr( carlife->android_version, "4.4.2")	!=	NULL)
	{
		g_message("match 4.4.2");
		_bdscExist	=	check_bdsc_exist();
		if( _bdscExist == FALSE)
		{
			char * _pushBdsc19	=	g_strdup_printf("adb -s %s push /etc/bdsc19 /data/local/tmp/bdsc", MH_DEV( _carlife)->serial);

			doCmd( _pushBdsc19);

			g_free( _pushBdsc19);
		}
	}
	else if( g_strrstr( carlife->android_version, "4.4.4")	!=	NULL)
	{
		g_message("match4.4.4");
		_bdscExist	=	check_bdsc_exist();
		if( _bdscExist == FALSE)
		{
			char * _pushBdsc19_01	=	g_strdup_printf("adb -s %s push /etc/bdsc19_01 /data/local/tmp/bdsc", MH_DEV( _carlife)->serial);

			doCmd( _pushBdsc19_01);

			g_free( _pushBdsc19_01);
		}
	}
	else if( g_strrstr( carlife->android_version, "4.2")	!=	NULL)
	{
		g_message("match 4.2");
		_bdscExist	=	check_bdsc_exist();
		if( _bdscExist == FALSE)
		{
			char * _pushBdsc17	=	g_strdup_printf("adb -s %s push /etc/bdsc17 /data/local/tmp/bdsc", MH_DEV( _carlife)->serial);

			doCmd( _pushBdsc17);

			g_free( _pushBdsc17);
		}
	}
	else
	{
		g_message("Android version is 5.0 or higher");
		carlife->versionFlag	=	true;
	}


	if( carlife->versionFlag	==	false)
	{

		char * _checkBdscExec	=	g_strdup_printf("adb -s %s shell ps | grep bdsc | awk '{print $2}'", MH_DEV( _carlife)->serial);
		_result	=	Cmd_With_Result( _checkBdscExec);
		g_message("_checkBdscExec->return len:%d, data:%s", _result->len, _result->data);
		if(  _result != NULL)
		{
			if(	_result->len > 0)
			{
				g_message("\n\n\nbdsc is running\n\n\n");

				_cmd	=	g_strdup_printf("adb -s %s shell kill -9 %s", MH_DEV( _carlife)->serial, _result->data);

				doCmd( _cmd);

				g_free( _cmd);
			}
			else
			{
				char * _chmodBdsc	=	g_strdup_printf("adb -s %s shell chmod 777 /data/local/tmp/bdsc", MH_DEV( _carlife)->serial);

				doCmd( _chmodBdsc);

				g_free( _chmodBdsc);

			}
			g_free( _result);
		}
		g_free( _checkBdscExec);
	}
//			doCmd( ADB_EXE_BDSC);
//			sleep(1);
//			_result	=	Cmd_With_Result( _checkBdscExec);
//			if( _result != NULL)
//			{
//				g_message("\n\n\n%s return != NULL ", _checkBdscExec);
//				if( _result->len != 0)
//				{
//					g_message("return len !=0 --->%s\n\n\n", _result->data);
//				}
//				else
//				{
//					doCmd( ADB_EXE_BDSC);
//
//					g_message("return len == 0\n\n\n");
//				}
//			}
//			else
//			{
//				g_message("\n\nreturn == NULL\n\n");
//			}
//
//			g_free( _result);
//		}




}		/* -----  end of static function check_bdsc  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  setup_bdsc
 *  Description:  
 * =====================================================================================
 */
static void setup_bdsc( MHDevCarlife * carlife)
{

	Cmd_Ret * _result	=	NULL;
	char * _adbExeBdsc;
	if( carlife->versionFlag == FALSE)
	{
		_adbExeBdsc	=	g_strdup_printf("adb -s %s shell /data/local/tmp/bdsc &", MH_DEV( _carlife)->serial);

		doCmd( _adbExeBdsc);


		sleep(1);

		char * _checkBdscExec	=	g_strdup_printf("adb -s %s shell ps | grep bdsc | awk '{print $2}'", MH_DEV( _carlife)->serial);

		_result	=	Cmd_With_Result( _checkBdscExec);

		if( _result != NULL)
		{
			g_message("\n\n\n%s return != NULL ", _checkBdscExec);
			if( _result->len != 0)
			{
				g_message("return len !=0 --->%s\n\n\n", _result->data);
			}
			else
			{
				doCmd( _adbExeBdsc);

				g_message("return len == 0\n\n\n");
			}
			g_free( _result);
		}
		else
		{
			setup_bdsc( carlife );
			g_message("\n\nreturn == NULL\n\n");
		}
		g_free( _checkBdscExec);	
		g_free( _adbExeBdsc);



	}

}		/* -----  end of static function setup_bdsc  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  setup_bdim
 *  Description:  
 * =====================================================================================
 */
static void setup_bdim( MHDevCarlife * carlife)
{
	Cmd_Ret * _res;

	char * _cmd	=	g_strdup_printf("adb -s %s shell ls /data/local/tmp | grep bdim", MH_DEV( _carlife)->serial);

	_res	=	Cmd_With_Result(_cmd);

	g_free( _cmd);
	if( _res !=	NULL)
	{
		if( _res->len == 0)
		{
			_cmd	=	g_strdup_printf("adb -s %s push /etc/bdim /data/local/tmp", MH_DEV( _carlife)->serial);

			doCmd( _cmd);

			g_free( _cmd);

			_cmd	=	g_strdup_printf("adb -s %s shell chmod 777 /data/local/tmp/bdim", MH_DEV( _carlife)->serial);

			doCmd( _cmd);

			g_free( _cmd);

			_cmd	=	g_strdup_printf("adb -s %s push /etc/bdim.jar /data/local/tmp", MH_DEV( _carlife)->serial);

			doCmd( _cmd);

			g_free( _cmd);

			_cmd	=	g_strdup_printf("adb -s %s shell chmod 777 /data/local/tmp/bdim.jar", MH_DEV( _carlife)->serial);

			doCmd( _cmd);

			g_free( _cmd);
		}
		g_free( _res);
	}

	_cmd	=	g_strdup_printf("adb -s %s shell /data/local/tmp/bdim &", MH_DEV( _carlife)->serial);

	doCmd( _cmd);

	g_free( _cmd);
	
	_cmd	=	g_strdup_printf("adb -s %s shell ps | grep app_process", MH_DEV( _carlife)->serial);

	_res	=	Cmd_With_Result( _cmd);

	g_free( _cmd);

	if( _res != NULL)
	{
		if( _res->len == 0)
		{
			g_message("no app_process");

			_cmd	=	g_strdup_printf("adb -s %s shell /data/local/tmp/bdim &", MH_DEV( _carlife)->serial);

			doCmd( _cmd);

			g_free( _cmd);
		}
		else
		{
			g_message("app_process:%s", _res->data);
		}
		g_free( _res);
	}

	g_message("android_version:%s", carlife->android_version);
	gboolean _bdscExist;
	gboolean _verFlag	=	FALSE;



}		/* -----  end of static function setup_bdim  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _init
 *  Description:  
 * =====================================================================================
 */
static gboolean _init( gpointer data)
{
	g_message("carlife.c->%s", __func__);

	MHDevCarlife * _carlife	=	MH_DEV_CARLIFE( data);
	/////////////////audio_param/////////////////////////
	if( _carlife->audio_param != 	NULL)
	{
		_carlife->audio_param->audioSink	=	gst_element_factory_make( _carlife->audio_sink_name ? 
				_carlife->audio_sink_name : "pulsesink", "audiosink");

		g_object_set( G_OBJECT( _carlife->audio_param->audioSink ), "buffer-time", ( uint64_t )500000, 
				"latency-time", (uint64_t)50000, NULL);	

		if( _carlife->audio_param->client_name != NULL)
		{
			g_message("%s->media->client_name:%s", __func__, _carlife->audio_param->client_name);
			g_object_set( _carlife->audio_param->audioSink, "client-name", _carlife->audio_param->client_name, NULL);
		}

		g_object_set( _carlife->audio_param->pipeline, "audio-sink", _carlife->audio_param->audioSink, NULL);
	}


	/////////////////video_param//////////////////////
	if( _carlife->video_param != NULL)
	{
		_carlife->video_param->videoSink	=	gst_element_factory_make( _carlife->video_sink_name ?
				_carlife->video_sink_name : "v4l2sink", "videosink");
		g_message("\n\n\n%s---->videoSink:%s\n\n\n", __func__,_carlife->video_sink_name);
		if( _carlife->surfaceid != 0)
		{
			g_object_set( _carlife->video_param->videoSink, "surfaceid", _carlife->surfaceid, NULL);
			g_message("\n\n\n\n%s---->videoSink:%s----->surfaceid:%d\n\n\n\n", __func__, _carlife->video_sink_name, _carlife->surfaceid);
		}


		g_object_set( _carlife->video_param->pipeline, "video-sink", _carlife->video_param->videoSink, NULL);
	}
	////////////////navi_param/////////////////////////////////// 
	if( _carlife->navi_param  != NULL)
	{
//		_carlife->navi_param->audioSink	=	gst_element_factory_make( _carlife->audio_sink_name ? 
//				_carlife->audio_sink_name : "pulsesink", "audiosink");
		_carlife->navi_param->audioSink	=	gst_element_factory_make("pulsesink", "audiosink");
		g_object_set( G_OBJECT( _carlife->navi_param->audioSink ), "buffer-time", ( uint64_t )500000, 
				"latency-time", (uint64_t)50000, NULL);	

		if( _carlife->navi_param->client_name != NULL)
		{
			g_message("%s->navi_param->client_name:%s", __func__, _carlife->navi_param->client_name);
			g_object_set( _carlife->navi_param->audioSink, "client-name", _carlife->navi_param->client_name, NULL);
		}

		g_object_set( _carlife->navi_param->pipeline, "audio-sink", _carlife->navi_param->audioSink, NULL);
	}
	/////////////////vrtts_param///////////////////
	if( _carlife->VRtts_param != NULL)
	{
		_carlife->VRtts_param->audioSink	=	gst_element_factory_make( _carlife->audio_sink_name ? 
				_carlife->audio_sink_name : "pulsesink", "audiosink");
		g_object_set( G_OBJECT( _carlife->VRtts_param->audioSink ), "buffer-time", ( uint64_t )500000, 
				"latency-time", (uint64_t)50000, NULL);	

		if( _carlife->VRtts_param->client_name != NULL)
		{
			g_message("%s->VRtts_param->client_name:%s", __func__, _carlife->VRtts_param->client_name);
			g_object_set( _carlife->VRtts_param->audioSink, "client-name", _carlife->VRtts_param->client_name, NULL);
		}
		g_object_set( _carlife->VRtts_param->pipeline, "audio-sink", _carlife->VRtts_param->audioSink, NULL);
	}
//
	return G_SOURCE_REMOVE;
}		/* -----  end of static function _init  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  ea_session_stop
 *  Description:  
 * =====================================================================================
 */
static void ea_session_stop( MHDev * dev, guint session_id, gpointer user_data )
{
	g_message("%s", __func__);
}		/* -----  end of static function ea_session_stop  ----- */
static gboolean video_heartbeat( gpointer data)
{
	g_message("\n%s->8-8-8-8-8-8-8-8-8-8-8\n", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)data;
	uint8_t _heartbeat[100];
	int _len 	=	0;

	_heartbeat[0]	=	(uint8_t)((_carlife->session_id >> 8) & 0xff);
	_heartbeat[1]	=	(uint8_t)((_carlife->session_id) & 0xff);

	ios_sendCmdVideoHeartbeat( _heartbeat + 2, &_len, 0);
	mh_dev_write_ea_data( _carlife->iap2Dev, _heartbeat , _len + 2);
		
			

	return TRUE;
}
static gboolean native_video_heartbeat( gpointer data)
{
	g_message("\n%s->8-8-8-8-8-8-8-8-8-8-8\n", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)data;
	uint8_t _heartbeat[100];
	int _len 	=	0;
	int _res;

	ios_sendCmdVideoHeartbeat( _heartbeat, &_len, 0);
	_res	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, _heartbeat , _len);
	if( _res < 0)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}
static gboolean emitAudioBuf( gpointer user_data )
{
	GstFlowReturn _ret;

	GstBuffer * _buf	=	( GstBuffer * )user_data;

	g_signal_emit_by_name( _carlife->audio_param->src, "push-buffer", _buf, &_ret );

	gst_buffer_unref( _buf );

	return G_SOURCE_REMOVE;
}		/* -----  end of static function emitAudioBuf  ----- */

void ios_mediaNormalData(const uint8_t *data, uint32_t len){

//	g_message_dbg("%s--->len:%d", __func__, len);
	GstBuffer * _buf;

	_buf	=	gst_buffer_new_allocate(NULL, len, NULL);

	gst_buffer_fill( _buf, 0, data, len);

	running = ((uint64_t)len)*1000000000 /( 4 * 44100)  + running;

	GST_BUFFER_PTS( _buf )	=	running;

	GSource * _source;

	_source	=	g_idle_source_new();

	g_source_set_callback( _source, emitAudioBuf, _buf, NULL);

	g_source_attach( _source, _carlife->audio_param->context);

	g_source_unref( _source ); 


}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  ea_session_data
 *  Description:  
 * =====================================================================================
 */
static void ea_session_data( MHDev * dev, GVariant * var, gpointer user_data )
{
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	GVariant * _var	=	g_variant_get_variant( var );
	const uint8_t * _buf;
	uint32_t _channelId;
	uint32_t _cmd;
	uint32_t _pbLen32;
	uint32_t _timeStamp;
	uint32_t dataHH	=	0;
	uint32_t dataHL	=	0;
	uint32_t dataLH	=	0;
	uint32_t dataLL	=	0;

	uint16_t _pbLen16;
	uint16_t dataH	=	0;
	uint16_t dataL	=	0;

	gsize _DataLen;
	uint32_t _len	=	0;
	uint8_t * sendPackage	=	_carlife->sendPackage;




	_buf	=	g_variant_get_fixed_array( _var, &_DataLen, sizeof( uint8_t ));
	g_message("md------------------------>hu");
//	DEBUG_HEX_DISPLAY( _buf, _DataLen );

	dataHH = (_buf[2] & 0xff);
	dataHL = (_buf[3] & 0xff);
	dataLH = (_buf[4] & 0xff);
	dataLL = (_buf[5] & 0xff);

	_channelId	 = ((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);
	g_message("%s->_channelId:%d", __func__, _channelId);

	if( _channelId == 1 || _channelId ==6)
	{
		dataH	=	(_buf[10] & 0xff);
		dataL	=	(_buf[11] & 0xff);
		_pbLen16	=	((dataH <<8) & 0xff00) | ((dataL) & 0x00ff);
		g_message("%s->_pbLen16:%d", __func__, _pbLen16);

		dataHH = (_buf[14] & 0xff);
		dataHL = (_buf[15] & 0xff);
		dataLH = (_buf[16] & 0xff);
		dataLL = (_buf[17] & 0xff);

		_cmd = ((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);
	}
	else
	{
		dataHH = (_buf[10] & 0xff);
		dataHL = (_buf[11] & 0xff);
		dataLH = (_buf[12] & 0xff);
		dataLL = (_buf[13] & 0xff);

		_pbLen32	=	((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);

		g_message("%s->_pbLen32:%d", __func__, _pbLen32);

		dataHH = (_buf[14] & 0xff);
		dataHL = (_buf[15] & 0xff);
		dataLH = (_buf[16] & 0xff);
		dataLL = (_buf[17] & 0xff);

		_timeStamp	=	((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);

		g_message("%s->_pbLen32:%d", __func__, _pbLen32);

		dataHH = (_buf[18] & 0xff);
		dataHL = (_buf[19] & 0xff);
		dataLH = (_buf[20] & 0xff);
		dataLL = (_buf[21] & 0xff);

		_cmd = ((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);
	}
	g_message("%s->_cmd:%x", __func__, _cmd);
	
	switch( _cmd){
		case IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS:
		{
			if( _carlife->launch_mode != CARLIFE_LAUNCH_NULL)
			{
				ios_sendCmdLaunchMode( _carlife->launch_mode, sendPackage + 2, &_len);

				mh_dev_write_ea_data( _carlife->iap2Dev, sendPackage, _len);

			}
			g_message("IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS	=	 0x00010002");
			S_PROTOCOL_VERSION_MATCH_SATUS_t * _status;
			_status =	packageDataAnalysis( IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS, _buf + 18, (uint32_t) _pbLen16); 
			g_message("%s->IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS:%d", __func__, _status->matchStatus);
			if( _status->matchStatus == 1)
			{
				GSource * _source;
				_source	=	g_timeout_source_new( 1000);

				g_source_set_callback( _source, video_heartbeat, _carlife, NULL);

				mh_io_dispatch(MH_IO( _carlife), _source);

				g_source_unref( _source);

				ios_sendCmdStatisticInfo(&statisticsInfo, sendPackage +2, &_len);

				gint len	=	mh_dev_write_ea_data( _carlife->iap2Dev, sendPackage , _len);

				g_message("mh_dev_write_ea_data return %d", len);

				S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};

				g_message("initVideoParam->width:%d, height:%d, frameRate:%d", _carlife->width, _carlife->height, _carlife->frameRate);

				ios_sendCmdVideoEncoderInit(&_initVideoParam, sendPackage +2 , &_len);

				len	=	mh_dev_write_ea_data( _carlife->iap2Dev, sendPackage , _len + 2);

				g_message("mh_dev_write_ea_data return %d", len);



			}
			
		}
		break;

		case IOS_CMD_MD_INFO:
		{
			g_message("IOS_CMD_MD_INFO	=	0x00010004");
			S_MD_INFO_t * mdInfro	=	NULL;

			mdInfro 	=	packageDataAnalysis( IOS_CMD_MD_INFO, _buf + 18, (uint32_t) _pbLen16); 

			g_message("cmdMDInfro() is invoked");
			g_message("os: %s",mdInfro->os);
			g_message("board: %s",mdInfro->board);
			g_message("bootloader: %s",mdInfro->bootloader);
			g_message("brand: %s",mdInfro->brand);
			g_message("cpu_abi: %s",mdInfro->cpu_abi);
			g_message("cpu_abi2: %s",mdInfro->cpu_abi2);
			g_message("device: %s",mdInfro->device);
			g_message("display: %s",mdInfro->display);
			g_message("fingerprint: %s",mdInfro->fingerprint);
			g_message("hardware: %s",mdInfro->hardware);
			g_message("host: %s",mdInfro->host);
			g_message("cid: %s",mdInfro->cid);
			g_message("manufacturer: %s",mdInfro->manufacturer);
			g_message("model: %s",mdInfro->model);
			g_message("product: %s",mdInfro->product);
			g_message("serial: %s",mdInfro->serial);
			g_message("codename: %s",mdInfro->codename);
			g_message("incremental: %s",mdInfro->incremental);
			g_message("release: %s",mdInfro->release);
			g_message("sdk: %s",mdInfro->sdk);
			g_message("sdk_int: %d",mdInfro->sdk_int);
			g_message("token:%s", mdInfro->token);
			g_message("btaddress:%s", mdInfro->btaddress);
			_carlife->md_bt_address	=	g_strdup(mdInfro->btaddress);

			S_HU_PROTOCOL_VERSION_t huProtocolVersion={1,0};
		

			ios_sendCmdHUProtoclVersion( &huProtocolVersion, sendPackage + 2, &_len );
		
	g_message("hu***************************************->md--->%x--->IOS_CMD_HU_PROTOCOL_VERSION", IOS_CMD_HU_PROTOCOL_VERSION);
//			DEBUG_HEX_DISPLAY( sendPackage, _len );

			gint len	=	mh_dev_write_ea_data( _carlife->iap2Dev, sendPackage , _len + 2);
		
			g_message("mh_dev_write_ea_data return %d", len);
			



		}
		break;

		case IOS_CMD_VIDEO_ENCODER_INIT_DONE:
		{
			g_message("IOS_CMD_VIDEO_ENCODER_INIT_DONE = 0x00010008");
			S_VIDEO_ENCODER_INIT_DONE_t * _status;
			_status =	packageDataAnalysis( IOS_CMD_VIDEO_ENCODER_INIT_DONE, _buf + 18, (uint32_t) _pbLen16); 
			cmdVideoEncoderInitDone(_status);

		}
		break;
		case IOS_CMD_MODULE_STATUS:
		{
			g_message("IOS_CMD_MODULE_STATUS 	=	0x00010026");
			S_MODULE_STATUS_LIST_MOBILE_t * _mobileList;
			_mobileList	=	packageDataAnalysis( IOS_CMD_MODULE_STATUS, _buf + 18, (uint32_t)_pbLen16);
			int i=0;
			for(i; i < _mobileList->cnt; i++)
			{
				g_message("module[%d]=%d status=%d",i, _mobileList->moduleStatus[i].moduleID, _mobileList->moduleStatus[i].statusID );
			}
			if( _carlife->MSlistener != NULL)
			{
				_carlife->MSlistener->callback( MH_DEV(_carlife), (ModuleStatusList*)_mobileList, _carlife->MSlistener->user_data);
			}

		}
		break;
		case IOS_CMD_FOREGROUND:
		{
			g_message("IOS_CMD_FOREGROUND 	=	0x0001001b");
			cmdForeground();

		}
		break;
		case IOS_CMD_MD_AUTHEN_RESULT:
		{
			g_message("IOS_CMD_MD_AUTHEN_RESULT = 0x0001004b");
			S_MD_AUTHEN_RESULT_t * _result;
			_result	=	packageDataAnalysis( IOS_CMD_MD_AUTHEN_RESULT, _buf + 18, (uint32_t)_pbLen16);
			g_message("IOS_CMD_MD_AUTHEN_RESULT result %d", _result->authenResult);
			if( _result->authenResult == 1)
			{
//
//				S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};
//				g_message("initVideoParam->width:%d, height:%d, frameRate:%d", _carlife->width, _carlife->height, _carlife->frameRate);
////				if( _carlife != NULL && _carlife->launch_mode != CARLIFE_LAUNCH_NULL)
////				{
////					switch( _carlife->launch_mode)
////					{
////						case CARLIFE_LAUNCH_NORMAL:
////							C_cmdLaunchModeNormal();
////							break;
////
////						case CARLIFE_LAUNCH_PHONE:
////							C_cmdLaunchModePhone();
////							break;
////
////						case CARLIFE_LAUNCH_MAP:
////							C_cmdLaunchModeMap();
////							break;
////
////						case CARLIFE_LAUNCH_MUSIC:
////							C_cmdLaunchModeMusic();
////							break;
////
////						default:
////							g_message("carlife launch_mode is %d, mode is error", _carlife->launch_mode);
////							break;
////					}
////				}
//				ios_sendCmdVideoEncoderInit(&_initVideoParam, sendPackage +2 , &_len);
//
//				gint len	=	mh_dev_write_ea_data( _carlife->iap2Dev, sendPackage , _len +2);
//
//				g_message("mh_dev_write_ea_data return %d", len);



			}
		}
		break;

		case IOS_CMD_MD_FEATURE_CONFIG_REQUEST:
		{
			g_message("IOS_CMD_MD_FEATURE_CONFIG_REQUEST = 0x00010051");
			featureConfigRequest();
		}
		break;


		case IOS_VIDEO_DATA:
		{
			ios_videoDataReceive( _buf + 22, _pbLen32);
			
		}
		break;
		
		case IOS_CMD_MEDIA_INFO:
		{
			S_MEDIA_INFO_t * _info;
			_info	=	packageDataAnalysis( IOS_CMD_MEDIA_INFO, _buf + 18, (uint32_t) _pbLen16);
			cmdMediaInfo( _info);
		}
		break;

		case IOS_MEDIA_INIT:
		{
			S_AUDIO_INIT_PARAMETER_t * _param;
			_param	=	packageDataAnalysis( IOS_MEDIA_INIT, _buf + 22, (uint32_t) _pbLen32);
			mediaInit( _param);
		}
		break;
		case IOS_MEDIA_DATA:
		{
			ios_mediaNormalData( _buf + 22, _pbLen32);
		}
		break;

		case IOS_MEDIA_PAUSE:
		{
			mediaPause();
		}
		break;
		case IOS_CMD_MEDIA_PROGRESS_BAR:
		{
			S_MEDIA_PROGRESS_BAR_t * _bar;
			_bar	=	packageDataAnalysis( IOS_CMD_MEDIA_PROGRESS_BAR, _buf + 18, (uint32_t) _pbLen16);
			cmdMediaProgressBar( _bar);

		}
		break;
		case IOS_CMD_BACKGROUND:
		{
			cmdBackground();
		}
		break;

		case IOS_CMD_UI_ACTION_SOUND:
		{
			cmdUIActionSound();
		}
		break;
		
		
	}
			g_message("%s[%d]--->g_variant_unref", __func__, __LINE__);
	g_variant_unref( _var );

}		/* -----  end of static function ea_session_data  ----- */

static void ea_session_start( MHDev * dev, guint protocol_id, guint session_id, gpointer user_data )
{

	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	_carlife->session_id	=	session_id;


	_carlife->sendPackage[0]	=	(uint8_t)((_carlife->session_id >> 8) & 0xff);
	_carlife->sendPackage[1]	=	(uint8_t)((_carlife->session_id) & 0xff);

	g_message("%s", __func__);
}		/* -----  end of static function ea_session_start  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  ea_native_stop
 *  Description:  
 * =====================================================================================
 */
static void ea_native_stop( MHDev * dev, gpointer user_data )
{
	g_message("%s", __func__);
}		/* -----  end of static function ea_native_stop  ----- */
static gboolean emitVideoBuf( gpointer user_data )
{
//	g_message("\n\n\n%s\n\n\n", __func__);
	GstFlowReturn _ret;
	GstBuffer * _buf	=	( GstBuffer * )user_data;
	if( _carlife->video_param->src != NULL)
	{
		g_signal_emit_by_name( _carlife->video_param->src, "push-buffer", _buf, &_ret );
	}

	gst_buffer_unref( _buf );

	return G_SOURCE_REMOVE;
}		/* -----  end of static function emitVideoBuf  ----- */
static int32_t segment_len	=	0;
static uint32_t last_cmd;
static int videoname =	0;
void ios_videoDataReceive( const uint8_t *data, uint32_t len){
//	DEBUG_HEX_DISPLAY( data, len);
	if(0)
	{
		if( videoFp	==	NULL)
		{

			char * _path	=	g_strdup_printf("/tmp/ios-%d", videoname);
			g_message("%s----->videoFp	==	NULL",__func__);
			videoFp		=	fopen( _path, "w+");
			g_message("%s--->fopen:%s", __func__, _path);
			videoname ++;
			g_free( _path );
		}
		static int i=0;
		if( i < 1000)
		{
			g_message("\n\n\n%s---->len=%d---->i=%d\n\n\n", __func__,len, i);
			fwrite( data, len, 1, videoFp);
			i++;

		}
		if( i == 1000)
		{
			i++;
			fclose( videoFp);
		}
		return;
	}

//	g_message_dbg("\tios_videoDataReceive0000000 receive video data: %d",len);
//	if(len < 2048)
//	{
//		return;
//	}
//	g_message("\tios_videoDataReceive1111111 receive video data: %d",len);
	uint64_t _time	=	UpTicks();

//	g_message("%s--->time:%lld", __func__,_time);	
	

//	g_message("%s--->len:%d", __func__, len);
   	GstBuffer * _buf;
	_buf	=	gst_buffer_new_allocate(NULL, len, NULL);
	gst_buffer_fill( _buf, 0, data, len);
	
	GSource * _source;
	_source	=	g_idle_source_new();
	g_source_set_callback(_source, emitVideoBuf, _buf, NULL);
	g_source_attach( _source, _carlife->video_param->context);
	g_source_unref( _source);
}
static gboolean emitNaviBuf( gpointer user_data )
{
	GstFlowReturn _ret;

	GstBuffer * _buf	=	( GstBuffer * )user_data;

	g_signal_emit_by_name( _carlife->navi_param->src, "push-buffer", _buf, &_ret );

	gst_buffer_unref( _buf );

	return G_SOURCE_REMOVE;
}	
void ios_naviNormalData(const uint8_t *data, uint32_t len)
{
	g_message("%s is invoked", __func__);
	g_message("receive navi data: %d bytes",len);

	GstBuffer * _buf;

	_buf	=	gst_buffer_new_allocate( NULL, len, NULL);

	gst_buffer_fill( _buf, 0, data, len);

	GST_BUFFER_PTS( _buf )	=	naviRunning;

	naviRunning	= ((uint64_t)len)*1000000000/_carlife->navi_param->bytes_second + naviRunning;


	GSource * _source;

	_source	=	g_idle_source_new();

	g_source_set_callback( _source, emitNaviBuf, _buf, NULL);

	g_source_attach( _source, _carlife->navi_param->context);

	g_source_unref( _source);

}

void vrInit(S_AUDIO_INIT_PARAMETER_t *initParam){
	g_message("%s------>[%lld]", __func__, UpTicks());
//	if( vr_file == NULL)
//	{
//		static int vrname	=	0;
//		char * path	=	g_strdup_printf("/tmp/vr-audio-%d", vrname++);
//		vr_file	=	fopen(path, "w+");
//		g_free( path);
//
//	}

	g_signal_emit_by_name(MH_DEV( _carlife), "dev_status", CARLIFE_VR_START);
	g_message("vrInit() is invoked");
	g_message("sampleRate: %d",initParam->sampleRate);
	g_message("channelConfig: %d",initParam->channelConfig);
	g_message("sampleFormat: %d",initParam->sampleFormat);
	_carlife->VRtts_param->sampleRate	=	initParam->sampleRate;
	_carlife->VRtts_param->channelConfig	=	initParam->channelConfig;
	_carlife->VRtts_param->sampleFormat	=	initParam->sampleFormat;
	gst_element_set_state( _carlife->VRtts_param->pipeline, GST_STATE_READY);

	_carlife->VRtts_param->bytes_second	=	initParam->sampleRate * initParam->channelConfig * initParam->sampleFormat / 8;
	g_message("%s->bytes_second	=	%d", __func__, _carlife->VRtts_param->bytes_second);
	g_message("%s->gst_element_set_state(vrtts)->GST_STATE_READY", __func__);

	gst_element_set_state( _carlife->VRtts_param->pipeline, GST_STATE_PLAYING);
	_carlife->VRtts_param->state	=	GST_STATE_PLAYING;
	g_message("%s->gst_element_set_state(vrtts)->GST_STATE_PLAYING", __func__);
	VRttsRunning	=	100000000;

}
static gboolean emitVRttsBuf( gpointer user_data )
{
	GstFlowReturn _ret;

	GstBuffer * _buf	=	( GstBuffer * )user_data;

	g_signal_emit_by_name( _carlife->VRtts_param->src, "push-buffer", _buf, &_ret );

	gst_buffer_unref( _buf );

	return G_SOURCE_REMOVE;
}	


void ios_vrNormalData(const uint8_t *data, uint32_t len)
{
	if( _carlife->VRtts_param->state	==	GST_STATE_PAUSED)
	{
		gst_element_set_state( _carlife->VRtts_param->pipeline, GST_STATE_PLAYING);
		_carlife->VRtts_param->state	=	GST_STATE_PLAYING;
	}
//	fwrite( data, len, 1, vr_file);
	g_message("%s->len=%d", __func__, len);
	g_message("%s is invoked", __func__);
	g_message("receive vr data: %d bytes",len);
	GstBuffer * _buf;
	_buf	=	gst_buffer_new_allocate( NULL, len, NULL);
	gst_buffer_fill( _buf, 0, data, len);
	GST_BUFFER_PTS( _buf )	=	VRttsRunning;
	g_message("%s->len=%d--->%lld", __func__, len, VRttsRunning);
	VRttsRunning	= ((uint64_t)len)*1000000000/_carlife->VRtts_param->bytes_second + VRttsRunning;



	GSource * _source;
	_source	=	g_idle_source_new();
	g_source_set_callback( _source, emitVRttsBuf, _buf, NULL);
	g_source_attach( _source, _carlife->VRtts_param->context);
	g_source_unref( _source);


}


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  ea_native_data
 *  Description:  
 * =====================================================================================
 */
static void ea_native_data( MHDev * dev, GVariant * var, gpointer user_data )
{
//	g_message("ea_native_data IN!!!!!");
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	GVariant * _var	=	g_variant_get_variant( var );
	const uint8_t * _buf;
	uint32_t _channelId;
	uint32_t _cmd;
	uint32_t _pbLen32;
	uint32_t _timeStamp;
	uint32_t dataHH	=	0;
	uint32_t dataHL	=	0;
	uint32_t dataLH	=	0;
	uint32_t dataLL	=	0;

	uint16_t _pbLen16;
	uint16_t dataH	=	0;
	uint16_t dataL	=	0;

	uint32_t _DataLen, _DataLen1;
	uint32_t _len	=	0;
	uint8_t * sendPackage	=	_carlife->sendPackage;
	uint32_t _itemLen	=	0;

static FILE * vrfile	=	NULL;
static int vrname=0;



	_buf	=	g_variant_get_fixed_array( _var, &_DataLen1, sizeof( uint8_t ));
//	g_message("ea_native_data [%d][%d]!!!!!", segment_len, _DataLen1);
	_DataLen = _DataLen1;

/*add comment for eap implement start
	if( segment_len > 0)
	{
//		g_message("ea_native_data000000000000000000 [%d][%d]!!!!!", segment_len, _DataLen1);

		g_message_dbg("%s->last_cmd:%x", __func__, last_cmd);

		if( segment_len > _DataLen)
		{
			if( last_cmd == IOS_VIDEO_DATA)
			{
				if(ios_video_long_buf != NULL)
				{
					g_message_dbg("segment_len > _DataLen00000 : segment_len is [%d], _DataLen is [%d]",segment_len, _DataLen);
					memcpy(ios_video_long_buf + len_ios_video_long_buf, _buf, _DataLen);
					len_ios_video_long_buf += _DataLen;
				}
				else
				{
					g_message_dbg("segment_len > _DataLen11111 : segment_len is [%d], _DataLen is [%d]",segment_len, _DataLen);
					ios_videoDataReceive( _buf, _DataLen);
				}
			}
			else
			{
				memcpy( _carlife->buf + _carlife->bufLoc, _buf, _DataLen);

				_carlife->bufLoc	=	_carlife->bufLoc + _DataLen;
			}

			segment_len =	segment_len - _DataLen;
			g_message_dbg("%s[%d]--->g_variant_unref", __func__, __LINE__);
			g_variant_unref( _var);

			return;

		}
		else if( segment_len == _DataLen)
		{
			if( last_cmd == IOS_VIDEO_DATA)
			{
				if(ios_video_long_buf != NULL)
				{
					g_message_dbg("segment_len == _DataLen00000 : segment_len is [%d], _DataLen is [%d]",segment_len, _DataLen);
					memcpy(ios_video_long_buf + len_ios_video_long_buf, _buf, _DataLen);
					len_ios_video_long_buf += _DataLen;
					ios_videoDataReceive( ios_video_long_buf, len_ios_video_long_buf);
					g_free(ios_video_long_buf);
					ios_video_long_buf = NULL;
					len_ios_video_long_buf = 0;
				}
				else
				{
					g_message_dbg("segment_len == _DataLen11111 : segment_len is [%d], _DataLen is [%d]",segment_len, _DataLen);
					ios_videoDataReceive( _buf, _DataLen);

				}
			}
			else if( last_cmd	== 	IOS_MEDIA_DATA)
			{
				memcpy( _carlife->buf  + _carlife->bufLoc, _buf, segment_len);

				ios_mediaNormalData( _carlife->buf , _carlife->bufSize);

				g_free( _carlife->buf);

				_carlife->bufSize	=	0;

				_carlife->bufLoc	=	0;
			}
			else if( last_cmd == IOS_CMD_MEDIA_INFO)
			{
				memcpy( _carlife->buf  + _carlife->bufLoc, _buf, segment_len);

				S_MEDIA_INFO_t * _info;

				_info	=	packageDataAnalysis( IOS_CMD_MEDIA_INFO, _carlife->buf, _carlife->bufSize);

				cmdMediaInfo( _info);

				g_message("%s[%d]--->g_free:%p",__func__,__LINE__, _carlife->buf);

				g_free( _carlife->buf);

				g_free( _info);

				_carlife->bufSize	=	0;

				_carlife->bufLoc	=	0;

			}
			else if( last_cmd == IOS_VR_DATA)
			{
				memcpy( _carlife->buf  + _carlife->bufLoc, _buf, segment_len);

				ios_vrNormalData( _carlife->buf , _carlife->bufSize);

				g_free( _carlife->buf);

				_carlife->bufSize	=	0;

				_carlife->bufLoc	=	0;

			}
			else if( last_cmd == IOS_TTS_DATA)
			{
				memcpy( _carlife->buf  + _carlife->bufLoc, _buf, segment_len);

				ios_naviNormalData( _carlife->buf , _carlife->bufSize);

				g_free( _carlife->buf);

				_carlife->bufSize	=	0;

				_carlife->bufLoc	=	0;

			}

			segment_len = segment_len - _DataLen;
			g_message_dbg("%s[%d]--->g_variant_unref", __func__, __LINE__);
			g_variant_unref( _var);

			return;
			
		}
		else //segment_len < _DataLen
		{
			if( last_cmd	== 	IOS_VIDEO_DATA)
			{
				if(ios_video_long_buf != NULL)
				{
					g_message_dbg("segment_len < _DataLen00000 : segment_len is [%d], _DataLen is [%d]",segment_len, _DataLen);
					memcpy(ios_video_long_buf + len_ios_video_long_buf, _buf, segment_len);
					len_ios_video_long_buf += segment_len;
					ios_videoDataReceive( ios_video_long_buf, len_ios_video_long_buf);
					g_free(ios_video_long_buf);
					ios_video_long_buf = NULL;
					len_ios_video_long_buf = 0;
				}
				else
				{
					g_message_dbg("segment_len < _DataLen11111 : segment_len is [%d], _DataLen is [%d]",segment_len, _DataLen);
					ios_videoDataReceive( _buf, segment_len);
				}

			}
			else if( last_cmd	== 	IOS_MEDIA_DATA)
			{
				memcpy( _carlife->buf  + _carlife->bufLoc, _buf, segment_len);


				ios_mediaNormalData(  _carlife->buf ,  _carlife->bufSize);

				g_message("%s[%d]--->g_free:%p",__func__,__LINE__, _carlife->buf);
				g_free( _carlife->buf);

				_carlife->bufSize	=	0;

				_carlife->bufLoc	=	0;




			}
			else if( last_cmd == IOS_CMD_MEDIA_INFO)
			{
				memcpy( _carlife->buf  + _carlife->bufLoc, _buf, segment_len);

				S_MEDIA_INFO_t * _info;

				_info	=	packageDataAnalysis( IOS_CMD_MEDIA_INFO, _carlife->buf, _carlife->bufSize);

				cmdMediaInfo( _info);

				g_message("%s[%d]--->g_free:%p",__func__,__LINE__, _carlife->buf);

				g_free( _carlife->buf);
				
				g_free( _info);

				_carlife->bufSize	=	0;

				_carlife->bufLoc	=	0;



			}

			else if( last_cmd == IOS_VR_DATA)
			{
				memcpy( _carlife->buf  + _carlife->bufLoc, _buf, segment_len);

				ios_vrNormalData( _carlife->buf , _carlife->bufSize);

				g_free( _carlife->buf);

				_carlife->bufSize	=	0;

				_carlife->bufLoc	=	0;

			}

			else if( last_cmd == IOS_TTS_DATA)
			{
				memcpy( _carlife->buf  + _carlife->bufLoc, _buf, segment_len);

				ios_naviNormalData( _carlife->buf , _carlife->bufSize);

				g_free( _carlife->buf);

				_carlife->bufSize	=	0;

				_carlife->bufLoc	=	0;

			}

			_buf	=	_buf + segment_len;

			_DataLen	=	_DataLen - segment_len;

		}
		
	}
add comment for eap implement end*/

	dataHH = (_buf[0] & 0xff);
	dataHL = (_buf[1] & 0xff);
	dataLH = (_buf[2] & 0xff);
	dataLL = (_buf[3] & 0xff);

	_channelId	 = ((_buf[0] << 24) & 0xff000000) | ((_buf[1] << 16) & 0x00ff0000)
		| ((_buf[2] << 8) & 0x0000ff00) | ((_buf[3]) & 0x000000ff);
//		g_message("%s->_channelId11111111:%d", __func__, _channelId);

	if( _channelId == 1 || _channelId ==6)
	{
		dataH	=	(_buf[8] & 0xff);
		dataL	=	(_buf[9] & 0xff);
		_pbLen16	=	((dataH <<8) & 0xff00) | ((dataL) & 0x00ff);

		dataHH = (_buf[12] & 0xff);
		dataHL = (_buf[13] & 0xff);
		dataLH = (_buf[14] & 0xff);
		dataLL = (_buf[15] & 0xff);

		_cmd = ((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);
		g_message_dbg("_pbLen16:%d, _cmd:%08X", _pbLen16, _cmd);

	}
	else if( _channelId == 2 || _channelId == 3 ||  _channelId == 4 || _channelId == 5)
	{
		dataHH = (_buf[8] & 0xff);
		dataHL = (_buf[9] & 0xff);
		dataLH = (_buf[10] & 0xff);
		dataLL = (_buf[11] & 0xff);

		_pbLen32	=	((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);

		dataHH = (_buf[12] & 0xff);
		dataHL = (_buf[13] & 0xff);
		dataLH = (_buf[14] & 0xff);
		dataLL = (_buf[15] & 0xff);

		dataHH = (_buf[16] & 0xff);
		dataHL = (_buf[17] & 0xff);
		dataLH = (_buf[18] & 0xff);
		dataLL = (_buf[19] & 0xff);

		_cmd = ((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);
//		g_message_dbg("_pbLen32:%d, _cmd:%08X", _pbLen32, _cmd);
	}
	else
	{
		g_message("\n\n\n carlife phone is error\n\n\n\n");
		g_message("%s[%d]--->g_variant_unref", __func__, __LINE__);
		g_variant_unref( _var);
		return;
	}

	switch( _cmd){
		case IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS:
			{
				if( _carlife->launch_mode != CARLIFE_LAUNCH_NULL)
				{
					ios_sendCmdLaunchMode( _carlife->launch_mode, sendPackage, &_len);

					mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage, _len);

				}
//					g_message("IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS	=	 0x00010002");
				S_PROTOCOL_VERSION_MATCH_SATUS_t * _status;
				_status =	packageDataAnalysis( IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS, _buf + 16, (uint32_t) _pbLen16);
//					g_message("%s->IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS:%d", __func__, _status->matchStatus);
				if( _status->matchStatus == 1)
				{
					GSource * _source;
					_source	=	g_timeout_source_new( 1000);

					g_source_set_callback( _source, native_video_heartbeat, _carlife, NULL);

					mh_io_dispatch(MH_IO( _carlife), _source);

					g_source_unref( _source);

					ios_sendCmdStatisticInfo(&statisticsInfo, sendPackage, &_len);

					gint len	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage , _len);

//						g_message("mh_dev_write_ea_native_data return %d", len);

					//						S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};
					//
					//						g_message("initVideoParam->width:%d, height:%d, frameRate:%d", _carlife->width, _carlife->height, _carlife->frameRate);
					//
					//						ios_sendCmdVideoEncoderInit(&_initVideoParam, sendPackage , &_len);
					//
					//						len	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage , _len);
					//
					//						g_message("mh_dev_write_ea_native_data return %d", len);
					//


				}
				g_free( _status);

			}
			break;

		case IOS_CMD_MD_INFO:
			{
				g_message("IOS_CMD_MD_INFO	=	0x00010004");
				S_MD_INFO_t * mdInfro	=	NULL;

				mdInfro 	=	packageDataAnalysis( IOS_CMD_MD_INFO, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t) _pbLen16);

				g_message("cmdMDInfro() is invoked");
				g_message("os: %s",mdInfro->os);
				g_message("board: %s",mdInfro->board);
				g_message("bootloader: %s",mdInfro->bootloader);
				g_message("brand: %s",mdInfro->brand);
				g_message("cpu_abi: %s",mdInfro->cpu_abi);
				g_message("cpu_abi2: %s",mdInfro->cpu_abi2);
				g_message("device: %s",mdInfro->device);
				g_message("display: %s",mdInfro->display);
				g_message("fingerprint: %s",mdInfro->fingerprint);
				g_message("hardware: %s",mdInfro->hardware);
				g_message("host: %s",mdInfro->host);
				g_message("cid: %s",mdInfro->cid);
				g_message("manufacturer: %s",mdInfro->manufacturer);
				g_message("model: %s",mdInfro->model);
				g_message("product: %s",mdInfro->product);
				g_message("serial: %s",mdInfro->serial);
				g_message("codename: %s",mdInfro->codename);
				g_message("incremental: %s",mdInfro->incremental);
				g_message("release: %s",mdInfro->release);
				g_message("sdk: %s",mdInfro->sdk);
				g_message("sdk_int: %d",mdInfro->sdk_int);
				g_message("token:%s", mdInfro->token);
				g_message("btaddress:%s", mdInfro->btaddress);
				_carlife->md_bt_address	=	g_strdup(mdInfro->btaddress);

//					S_HU_PROTOCOL_VERSION_t huProtocolVersion={1,0};
//
//
//					ios_sendCmdHUProtoclVersion( &huProtocolVersion, sendPackage, &_len );
//
//					g_message("hu***************************************->md--->%x--->IOS_CMD_HU_PROTOCOL_VERSION", IOS_CMD_HU_PROTOCOL_VERSION);
//					//			DEBUG_HEX_DISPLAY( sendPackage, _len );
//
//
//
//
//					mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage, _len);
				g_free(mdInfro->os);
				g_free(mdInfro->board);
				g_free(mdInfro->bootloader);
				g_free(mdInfro->brand);
				g_free(mdInfro->cpu_abi);
				g_free(mdInfro->cpu_abi2);
				g_free(mdInfro->device);
				g_free(mdInfro->display);
				g_free(mdInfro->fingerprint);
				g_free(mdInfro->hardware);
				g_free(mdInfro->host);
				g_free(mdInfro->cid);
				g_free(mdInfro->manufacturer);
				g_free(mdInfro->model);
				g_free(mdInfro->product);
				g_free(mdInfro->serial);
				g_free(mdInfro->codename);
				g_free(mdInfro->incremental);
				g_free(mdInfro->release);
				g_free(mdInfro->sdk);
				g_free(mdInfro->token);
				g_free(mdInfro->btaddress);

				g_free( mdInfro);
			}
			break;

		case IOS_CMD_VIDEO_ENCODER_INIT_DONE:
			{
				g_message("IOS_CMD_VIDEO_ENCODER_INIT_DONE = 0x00010008");
				S_VIDEO_ENCODER_INIT_DONE_t * _status;
				_status =	packageDataAnalysis( IOS_CMD_VIDEO_ENCODER_INIT_DONE, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t) _pbLen16);
				cmdVideoEncoderInitDone(_status);

				g_free( _status);

			}
			break;
		case IOS_CMD_MODULE_STATUS:
			{
				g_message("IOS_CMD_MODULE_STATUS 	=	0x00010026");
				S_MODULE_STATUS_LIST_MOBILE_t * _moduleList;
				_moduleList	=	packageDataAnalysis( IOS_CMD_MODULE_STATUS, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t)_pbLen16);
				int i=0;
				for(i; i < _moduleList->cnt; i++)
				{
					g_message("module[%d]=%d status=%d",i, _moduleList->moduleStatus[i].moduleID, _moduleList->moduleStatus[i].statusID );
				}
				if( _carlife->MSlistener != NULL)
				{
					_carlife->MSlistener->callback( MH_DEV(_carlife), (ModuleStatusList*)_moduleList, _carlife->MSlistener->user_data);
				}
				g_free( _moduleList);

			}
			break;
		case IOS_CMD_FOREGROUND:
			{
				g_message("IOS_CMD_FOREGROUND 	=	0x0001001b");
				cmdForeground();

			}
			break;
		case IOS_CMD_MD_AUTHEN_RESULT:
			{
				g_message("IOS_CMD_MD_AUTHEN_RESULT = 0x0001004b");
				S_MD_AUTHEN_RESULT_t * _result;
				_result	=	packageDataAnalysis( IOS_CMD_MD_AUTHEN_RESULT, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t)_pbLen16);
				g_message("IOS_CMD_MD_AUTHEN_RESULT result %d", _result->authenResult);
				if( _result->authenResult == 1)
				{
					//
					//				S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};
					//				g_message("initVideoParam->width:%d, height:%d, frameRate:%d", _carlife->width, _carlife->height, _carlife->frameRate);
					////				if( _carlife != NULL && _carlife->launch_mode != CARLIFE_LAUNCH_NULL)
					////				{
					////					switch( _carlife->launch_mode)
					////					{
					////						case CARLIFE_LAUNCH_NORMAL:
					////							C_cmdLaunchModeNormal();
					////							break;
					////
					////						case CARLIFE_LAUNCH_PHONE:
					////							C_cmdLaunchModePhone();
					////							break;
					////
					////						case CARLIFE_LAUNCH_MAP:
					////							C_cmdLaunchModeMap();
					////							break;
					////
					////						case CARLIFE_LAUNCH_MUSIC:
					////							C_cmdLaunchModeMusic();
					////							break;
					////
					////						default:
					////							g_message("carlife launch_mode is %d, mode is error", _carlife->launch_mode);
					////							break;
					////					}
					////				}
					//				ios_sendCmdVideoEncoderInit(&_initVideoParam, sendPackage , &_len);
					//
					//				gint len	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage , _len);
					//
					//				g_message("mh_dev_write_ea_native_data return %d", len);



					S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};

					g_message("initVideoParam->width:%d, height:%d, frameRate:%d", _carlife->width, _carlife->height, _carlife->frameRate);

					ios_sendCmdVideoEncoderInit(&_initVideoParam, sendPackage , &_len);

					gint len	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage , _len);

					g_message("mh_dev_write_ea_native_data return %d", len);

				}
				g_free( _result);
			}
			break;

		case IOS_CMD_MD_FEATURE_CONFIG_REQUEST:
			{
				g_message("IOS_CMD_MD_FEATURE_CONFIG_REQUEST = 0x00010051");
				featureConfigRequest();
			}
			break;


		case IOS_VIDEO_DATA:
			{
//					g_message(" IOS_VIDEO_DATA	=	0x00020001");
				if(0 == len_ios_video_long_buf)
				{
					ios_videoDataReceive( _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32);
				}

			}
			break;

		case IOS_CMD_MEDIA_INFO:
			{
				S_MEDIA_INFO_t * _info;
				_info	=	packageDataAnalysis( IOS_CMD_MEDIA_INFO, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t) _pbLen16);
//					cmdMediaInfo( _info);
				g_free( _info);
			}
			break;

		case IOS_MEDIA_INIT:
			{
				S_AUDIO_INIT_PARAMETER_t * _param;
				_param	=	packageDataAnalysis( IOS_MEDIA_INIT, _buf + EA_NATIVE_MEDIA_HEAD_LEN, (uint32_t) _pbLen32);
				mediaInit( _param);
				g_free( _param);
			}
			break;
		case IOS_MEDIA_DATA:
			{
				ios_mediaNormalData( _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32);
			}
			break;

		case IOS_MEDIA_PAUSE:
			{
				mediaPause();
			}
			break;
		case IOS_CMD_MEDIA_PROGRESS_BAR:
			{
				S_MEDIA_PROGRESS_BAR_t * _bar;
				_bar	=	packageDataAnalysis( IOS_CMD_MEDIA_PROGRESS_BAR, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t) _pbLen16);
				cmdMediaProgressBar( _bar);
				g_free( _bar);

			}
			break;
		case IOS_CMD_BACKGROUND:
			{
				cmdBackground();
			}
			break;

		case IOS_CMD_UI_ACTION_SOUND:
			{
				cmdUIActionSound();
			}
			break;
		case IOS_VR_INIT:
			{
				g_message("%s--->IOS_VR_INIT---->_pbLen32:%d", __func__, _pbLen32);
//					DEBUG_HEX_DISPLAY( _buf, _pbLen32+EA_NATIVE_MEDIA_HEAD_LEN);
//					if( vrfile == NULL)
//					{
//						char * path	=	g_strdup_printf("/tmp/vr-audio-%d", vrname++);
//						vrfile	=	fopen(path, "w+");
//						g_free( path);
//					}
				S_AUDIO_INIT_PARAMETER_t * _init;
				_init	=	packageDataAnalysis( IOS_VR_INIT, _buf + EA_NATIVE_MEDIA_HEAD_LEN, (uint32_t)_pbLen32);
				vrInit( _init);
				g_free( _init);

			}
			break;
		case IOS_VR_DATA:
			{
g_message("%s--->IOS_VR_DATA---->_pbLen32:%d", __func__, _pbLen32);
//					DEBUG_HEX_DISPLAY( _buf, _pbLen32 + EA_NATIVE_MEDIA_HEAD_LEN);

				g_message("%s--->IOS_VR_DATA", __func__);
				ios_vrNormalData( _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32);
//					fwrite(  _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32, 1, vrfile);

			}
			break;

		case IOS_VR_STOP:
			{
g_message("%s--->IOS_VR_STOP---->_pbLen32:%d", __func__, _pbLen32);
//					DEBUG_HEX_DISPLAY( _buf, _DataLen);

				g_message("%s--->IOS_VR_STOP", __func__);
				vrStop();
//					fclose(vrfile);
//					vrfile 	=	NULL;

			}
			break;
//0x00010024
		case IOS_CMD_MIC_RECORD_RECOG_START:
			{
				g_message("IOS_CMD_MIC_RECORD_RECOG_START");
				cmdMicRecordRecogStart();

			}
			break;
		//0x00010023
		case IOS_CMD_MIC_RECORD_END:
			{
				cmdMicRecordEnd();
			}
			break;
		case IOS_TTS_INIT:
			{
				S_AUDIO_INIT_PARAMETER_t * _init;
				_init	=	packageDataAnalysis( IOS_TTS_INIT, _buf + EA_NATIVE_MEDIA_HEAD_LEN, (uint32_t)_pbLen32);
				naviInit( _init);
				g_free( _init);

			}
			break;
		case IOS_TTS_DATA:
			{
				ios_naviNormalData( _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32);
			}
			break;
		case IOS_TTS_STOP:
			{
				naviStop();

			}
			break;
		case IOS_CMD_MIC_RECORD_WAKEUP_START:
			{
				cmdMicRecordWakeupStart();
			}
			break;
		case IOS_CMD_GO_TO_DESKTOP:
			{
				cmdGoToDeskTop();

			}
			break;


	}

/*add comment for eap implement1 start
	while( _DataLen > 0)
	{
//		g_message("%s->_channelId00000000:%d", __func__, _channelId);

		dataHH = (_buf[0] & 0xff);
		dataHL = (_buf[1] & 0xff);
		dataLH = (_buf[2] & 0xff);
		dataLL = (_buf[3] & 0xff);

		_channelId	 = ((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
			| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);
//		g_message("%s->_channelId11111111:%d", __func__, _channelId);

		if( _channelId == 1 || _channelId ==6)
		{
			dataH	=	(_buf[8] & 0xff);
			dataL	=	(_buf[9] & 0xff);
			_pbLen16	=	((dataH <<8) & 0xff00) | ((dataL) & 0x00ff);
			g_message("%s->_pbLen16:%d", __func__, _pbLen16);

			dataHH = (_buf[12] & 0xff);
			dataHL = (_buf[13] & 0xff);
			dataLH = (_buf[14] & 0xff);
			dataLL = (_buf[15] & 0xff);

			_cmd = ((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
				| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);

			segment_len	=	_pbLen16 + EA_NATIVE_CONTROL_HEAD_LEN - _DataLen;
			if( segment_len > 0)
			{
				_carlife->buf	=	g_new0(char, _pbLen16);
				g_message("%s[%d]-->g_new0->%p", __func__,__LINE__, _carlife->buf);
				g_message("%s-->cmd-->%x", __func__,_cmd);
				memcpy( _carlife->buf, _buf + EA_NATIVE_CONTROL_HEAD_LEN, _DataLen - EA_NATIVE_CONTROL_HEAD_LEN); 
				_carlife->bufLoc	=	_DataLen - EA_NATIVE_CONTROL_HEAD_LEN;
				_carlife->bufSize	=	_pbLen16;
				g_message("%s[%d]--->g_variant_unref", __func__, __LINE__);

				last_cmd	=	_cmd;
				g_variant_unref( _var);

				return ;


			}
			_itemLen	=	EA_NATIVE_CONTROL_HEAD_LEN + _pbLen16;
		

		}
		else if( _channelId == 2 || _channelId == 3 ||  _channelId == 4 || _channelId == 5)
		{
			dataHH = (_buf[8] & 0xff);
			dataHL = (_buf[9] & 0xff);
			dataLH = (_buf[10] & 0xff);
			dataLL = (_buf[11] & 0xff);

			_pbLen32	=	((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
				| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);


			g_message_dbg("%s->_pbLen32:%d", __func__, _pbLen32);

			dataHH = (_buf[12] & 0xff);
			dataHL = (_buf[13] & 0xff);
			dataLH = (_buf[14] & 0xff);
			dataLL = (_buf[15] & 0xff);

			_timeStamp	=	((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
				| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);

			g_message_dbg("%s->_pbLen32:%d", __func__, _pbLen32);

			dataHH = (_buf[16] & 0xff);
			dataHL = (_buf[17] & 0xff);
			dataLH = (_buf[18] & 0xff);
			dataLL = (_buf[19] & 0xff);

			_cmd = ((dataHH << 24) & 0xff000000) | ((dataHL << 16) & 0x00ff0000)
				| ((dataLH << 8) & 0x0000ff00) | ((dataLL) & 0x000000ff);


			segment_len	=	_pbLen32 + EA_NATIVE_MEDIA_HEAD_LEN - _DataLen;
			g_message_dbg("%s[%d]segment_len=%d + %d -%d=%d", __func__, __LINE__, _pbLen32, EA_NATIVE_MEDIA_HEAD_LEN, _DataLen, segment_len);
			if( segment_len > 0 )
			{
				g_message_dbg("%s[%d]segment_len=%d + %d -%d=%d", __func__, __LINE__, _pbLen32, EA_NATIVE_MEDIA_HEAD_LEN, _DataLen, segment_len);

				last_cmd	=	_cmd;
				if( _cmd == IOS_VIDEO_DATA)
				{
					//add for ios carlife map start
					if(ios_video_long_buf != NULL)
					{
						g_free(ios_video_long_buf);
						ios_video_long_buf = NULL;
						len_ios_video_long_buf = 0;
					}
					ios_video_long_buf = g_new0(uint8_t, _pbLen32);
					len_ios_video_long_buf = _DataLen - EA_NATIVE_MEDIA_HEAD_LEN;
					memcpy(ios_video_long_buf, _buf + EA_NATIVE_MEDIA_HEAD_LEN, _DataLen - EA_NATIVE_MEDIA_HEAD_LEN);
							//add for ios carlife map end
					_pbLen32	=	_DataLen - EA_NATIVE_MEDIA_HEAD_LEN;
				}
				else
				{
					g_message("segment_len > 0 the last data is");
//					DEBUG_HEX_DISPLAY( _buf, _DataLen);
					_carlife->buf	=	g_new0( char , _pbLen32);
					memcpy( _carlife->buf, _buf + EA_NATIVE_MEDIA_HEAD_LEN, _DataLen -  EA_NATIVE_MEDIA_HEAD_LEN);

					_carlife->bufLoc	=	_DataLen - EA_NATIVE_MEDIA_HEAD_LEN;
					_carlife->bufSize	=	_pbLen32;
					g_message("%s[%d]--->g_variant_unref", __func__, __LINE__);

					g_variant_unref( _var);

					return ;


				}

			}
			_itemLen	=	EA_NATIVE_MEDIA_HEAD_LEN + _pbLen32;


		}
		else
		{
			g_message("\n\n\n carlife phone is error\n\n\n\n");
			g_message("%s[%d]--->g_variant_unref", __func__, __LINE__);
			g_variant_unref( _var);
			return;
		}

		g_message_dbg("%s->_cmd:%x", __func__, _cmd);

		switch( _cmd){
			case IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS:
				{
					if( _carlife->launch_mode != CARLIFE_LAUNCH_NULL)
					{
						ios_sendCmdLaunchMode( _carlife->launch_mode, sendPackage, &_len);

						mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage, _len);

					}
//					g_message("IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS	=	 0x00010002");
					S_PROTOCOL_VERSION_MATCH_SATUS_t * _status;
					_status =	packageDataAnalysis( IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS, _buf + 16, (uint32_t) _pbLen16); 
//					g_message("%s->IOS_CMD_PROTOCOL_VERSION_MATCH_STATUS:%d", __func__, _status->matchStatus);
					if( _status->matchStatus == 1)
					{
						GSource * _source;
						_source	=	g_timeout_source_new( 1000);

						g_source_set_callback( _source, native_video_heartbeat, _carlife, NULL);

						mh_io_dispatch(MH_IO( _carlife), _source);

						g_source_unref( _source);

						ios_sendCmdStatisticInfo(&statisticsInfo, sendPackage, &_len);

						gint len	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage , _len);

//						g_message("mh_dev_write_ea_native_data return %d", len);

						//						S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};
						//
						//						g_message("initVideoParam->width:%d, height:%d, frameRate:%d", _carlife->width, _carlife->height, _carlife->frameRate);
						//
						//						ios_sendCmdVideoEncoderInit(&_initVideoParam, sendPackage , &_len);
						//
						//						len	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage , _len);
						//
						//						g_message("mh_dev_write_ea_native_data return %d", len);
						//


					}
					g_free( _status);

				}
				break;

			case IOS_CMD_MD_INFO:
				{
					g_message("IOS_CMD_MD_INFO	=	0x00010004");
					S_MD_INFO_t * mdInfro	=	NULL;

					mdInfro 	=	packageDataAnalysis( IOS_CMD_MD_INFO, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t) _pbLen16); 

					g_message("cmdMDInfro() is invoked");
					g_message("os: %s",mdInfro->os);
					g_message("board: %s",mdInfro->board);
					g_message("bootloader: %s",mdInfro->bootloader);
					g_message("brand: %s",mdInfro->brand);
					g_message("cpu_abi: %s",mdInfro->cpu_abi);
					g_message("cpu_abi2: %s",mdInfro->cpu_abi2);
					g_message("device: %s",mdInfro->device);
					g_message("display: %s",mdInfro->display);
					g_message("fingerprint: %s",mdInfro->fingerprint);
					g_message("hardware: %s",mdInfro->hardware);
					g_message("host: %s",mdInfro->host);
					g_message("cid: %s",mdInfro->cid);
					g_message("manufacturer: %s",mdInfro->manufacturer);
					g_message("model: %s",mdInfro->model);
					g_message("product: %s",mdInfro->product);
					g_message("serial: %s",mdInfro->serial);
					g_message("codename: %s",mdInfro->codename);
					g_message("incremental: %s",mdInfro->incremental);
					g_message("release: %s",mdInfro->release);
					g_message("sdk: %s",mdInfro->sdk);
					g_message("sdk_int: %d",mdInfro->sdk_int);
					g_message("token:%s", mdInfro->token);
					g_message("btaddress:%s", mdInfro->btaddress);
					_carlife->md_bt_address	=	g_strdup(mdInfro->btaddress);

//					S_HU_PROTOCOL_VERSION_t huProtocolVersion={1,0};
//
//
//					ios_sendCmdHUProtoclVersion( &huProtocolVersion, sendPackage, &_len );
//
//					g_message("hu***************************************->md--->%x--->IOS_CMD_HU_PROTOCOL_VERSION", IOS_CMD_HU_PROTOCOL_VERSION);
//					//			DEBUG_HEX_DISPLAY( sendPackage, _len );
//
//
//
//
//					mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage, _len);
					g_free(mdInfro->os);
					g_free(mdInfro->board);
					g_free(mdInfro->bootloader);
					g_free(mdInfro->brand);
					g_free(mdInfro->cpu_abi);
					g_free(mdInfro->cpu_abi2);
					g_free(mdInfro->device);
					g_free(mdInfro->display);
					g_free(mdInfro->fingerprint);
					g_free(mdInfro->hardware);
					g_free(mdInfro->host);
					g_free(mdInfro->cid);
					g_free(mdInfro->manufacturer);
					g_free(mdInfro->model);
					g_free(mdInfro->product);
					g_free(mdInfro->serial);
					g_free(mdInfro->codename);
					g_free(mdInfro->incremental);
					g_free(mdInfro->release);
					g_free(mdInfro->sdk);
					g_free(mdInfro->token);
					g_free(mdInfro->btaddress);

					g_free( mdInfro);
				}
				break;

			case IOS_CMD_VIDEO_ENCODER_INIT_DONE:
				{
					g_message("IOS_CMD_VIDEO_ENCODER_INIT_DONE = 0x00010008");
					S_VIDEO_ENCODER_INIT_DONE_t * _status;
					_status =	packageDataAnalysis( IOS_CMD_VIDEO_ENCODER_INIT_DONE, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t) _pbLen16); 
					cmdVideoEncoderInitDone(_status);

					g_free( _status);

				}
				break;
			case IOS_CMD_MODULE_STATUS:
				{
					g_message("IOS_CMD_MODULE_STATUS 	=	0x00010026");
					S_MODULE_STATUS_LIST_MOBILE_t * _moduleList;
					_moduleList	=	packageDataAnalysis( IOS_CMD_MODULE_STATUS, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t)_pbLen16);
					int i=0;
					for(i; i < _moduleList->cnt; i++)
					{
						g_message("module[%d]=%d status=%d",i, _moduleList->moduleStatus[i].moduleID, _moduleList->moduleStatus[i].statusID );
					}
					if( _carlife->MSlistener != NULL)
					{
						_carlife->MSlistener->callback( MH_DEV(_carlife), (ModuleStatusList*)_moduleList, _carlife->MSlistener->user_data);
					}
					g_free( _moduleList);

				}
				break;
			case IOS_CMD_FOREGROUND:
				{
					g_message("IOS_CMD_FOREGROUND 	=	0x0001001b");
					cmdForeground();

				}
				break;
			case IOS_CMD_MD_AUTHEN_RESULT:
				{
					g_message("IOS_CMD_MD_AUTHEN_RESULT = 0x0001004b");
					S_MD_AUTHEN_RESULT_t * _result;
					_result	=	packageDataAnalysis( IOS_CMD_MD_AUTHEN_RESULT, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t)_pbLen16);
					g_message("IOS_CMD_MD_AUTHEN_RESULT result %d", _result->authenResult);
					if( _result->authenResult == 1)
					{
						//
						//				S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};
						//				g_message("initVideoParam->width:%d, height:%d, frameRate:%d", _carlife->width, _carlife->height, _carlife->frameRate);
						////				if( _carlife != NULL && _carlife->launch_mode != CARLIFE_LAUNCH_NULL)
						////				{
						////					switch( _carlife->launch_mode)
						////					{
						////						case CARLIFE_LAUNCH_NORMAL:
						////							C_cmdLaunchModeNormal();
						////							break;
						////
						////						case CARLIFE_LAUNCH_PHONE:
						////							C_cmdLaunchModePhone();
						////							break;
						////
						////						case CARLIFE_LAUNCH_MAP:
						////							C_cmdLaunchModeMap();
						////							break;
						////
						////						case CARLIFE_LAUNCH_MUSIC:
						////							C_cmdLaunchModeMusic();
						////							break;
						////
						////						default:
						////							g_message("carlife launch_mode is %d, mode is error", _carlife->launch_mode);
						////							break;
						////					}
						////				}
						//				ios_sendCmdVideoEncoderInit(&_initVideoParam, sendPackage , &_len);
						//
						//				gint len	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage , _len);
						//
						//				g_message("mh_dev_write_ea_native_data return %d", len);



						S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};

						g_message("initVideoParam->width:%d, height:%d, frameRate:%d", _carlife->width, _carlife->height, _carlife->frameRate);

						ios_sendCmdVideoEncoderInit(&_initVideoParam, sendPackage , &_len);

						gint len	=	mh_dev_write_ea_native_data( _carlife->iap2Dev, sendPackage , _len);

						g_message("mh_dev_write_ea_native_data return %d", len);

					}
					g_free( _result);
				}
				break;

			case IOS_CMD_MD_FEATURE_CONFIG_REQUEST:
				{
					g_message("IOS_CMD_MD_FEATURE_CONFIG_REQUEST = 0x00010051");
					featureConfigRequest();
				}
				break;


			case IOS_VIDEO_DATA:
				{
//					g_message(" IOS_VIDEO_DATA	=	0x00020001");
					if(0 == len_ios_video_long_buf)
					{
						ios_videoDataReceive( _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32);
					}

				}
				break;

			case IOS_CMD_MEDIA_INFO:
				{
					S_MEDIA_INFO_t * _info;
					_info	=	packageDataAnalysis( IOS_CMD_MEDIA_INFO, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t) _pbLen16);
//					cmdMediaInfo( _info);
					g_free( _info);
				}
				break;

			case IOS_MEDIA_INIT:
				{
					S_AUDIO_INIT_PARAMETER_t * _param;
					_param	=	packageDataAnalysis( IOS_MEDIA_INIT, _buf + EA_NATIVE_MEDIA_HEAD_LEN, (uint32_t) _pbLen32);
					mediaInit( _param);
					g_free( _param);
				}
				break;
			case IOS_MEDIA_DATA:
				{
					ios_mediaNormalData( _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32);
				}
				break;

			case IOS_MEDIA_PAUSE:
				{
					mediaPause();
				}
				break;
			case IOS_CMD_MEDIA_PROGRESS_BAR:
				{
					S_MEDIA_PROGRESS_BAR_t * _bar;
					_bar	=	packageDataAnalysis( IOS_CMD_MEDIA_PROGRESS_BAR, _buf + EA_NATIVE_CONTROL_HEAD_LEN, (uint32_t) _pbLen16);
					cmdMediaProgressBar( _bar);
					g_free( _bar);

				}
				break;
			case IOS_CMD_BACKGROUND:
				{
					cmdBackground();
				}
				break;

			case IOS_CMD_UI_ACTION_SOUND:
				{
					cmdUIActionSound();
				}
				break;
			case IOS_VR_INIT:
				{
					g_message("%s--->IOS_VR_INIT---->_pbLen32:%d", __func__, _pbLen32);
//					DEBUG_HEX_DISPLAY( _buf, _pbLen32+EA_NATIVE_MEDIA_HEAD_LEN);
//					if( vrfile == NULL)
//					{
//						char * path	=	g_strdup_printf("/tmp/vr-audio-%d", vrname++);
//						vrfile	=	fopen(path, "w+");
//						g_free( path);
//					}
					S_AUDIO_INIT_PARAMETER_t * _init;
					_init	=	packageDataAnalysis( IOS_VR_INIT, _buf + EA_NATIVE_MEDIA_HEAD_LEN, (uint32_t)_pbLen32);
					vrInit( _init);
					g_free( _init);
					
				}
				break;
			case IOS_VR_DATA:
				{
	g_message("%s--->IOS_VR_DATA---->_pbLen32:%d", __func__, _pbLen32);
//					DEBUG_HEX_DISPLAY( _buf, _pbLen32 + EA_NATIVE_MEDIA_HEAD_LEN);

					g_message("%s--->IOS_VR_DATA", __func__);
					ios_vrNormalData( _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32);
//					fwrite(  _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32, 1, vrfile);
					
				}
				break;

			case IOS_VR_STOP:
				{
	g_message("%s--->IOS_VR_STOP---->_pbLen32:%d", __func__, _pbLen32);
//					DEBUG_HEX_DISPLAY( _buf, _DataLen);

					g_message("%s--->IOS_VR_STOP", __func__);
					vrStop();
//					fclose(vrfile);
//					vrfile 	=	NULL;

				}
				break;
//0x00010024
			case IOS_CMD_MIC_RECORD_RECOG_START:
				{
					g_message("IOS_CMD_MIC_RECORD_RECOG_START");
					cmdMicRecordRecogStart();

				}
				break;
			//0x00010023
			case IOS_CMD_MIC_RECORD_END:
				{
					cmdMicRecordEnd();
				}
				break;
			case IOS_TTS_INIT:
				{
					S_AUDIO_INIT_PARAMETER_t * _init;
					_init	=	packageDataAnalysis( IOS_TTS_INIT, _buf + EA_NATIVE_MEDIA_HEAD_LEN, (uint32_t)_pbLen32);
					naviInit( _init);
					g_free( _init);

				}
				break;
			case IOS_TTS_DATA:
				{
					ios_naviNormalData( _buf + EA_NATIVE_MEDIA_HEAD_LEN, _pbLen32);
				}
				break;
			case IOS_TTS_STOP:
				{
					naviStop();

				}
				break;
			case IOS_CMD_MIC_RECORD_WAKEUP_START:
				{
					cmdMicRecordWakeupStart();
				}
				break;
			case IOS_CMD_GO_TO_DESKTOP:
				{
					cmdGoToDeskTop();

				}
				break;


		}
		_DataLen	=	_DataLen - _itemLen;
		_buf	=	_buf + _itemLen;
	}
	add comment for eap implement1 end*/
//			g_message("%s[%d]--->g_variant_unref", __func__, __LINE__);
	g_variant_unref( _var );

}		/* -----  end of static function ea_native_data  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mit_connect_success
 *  Description:  
 * =====================================================================================
 */
static gboolean emit_connect_success( gpointer user_data)
{
	g_message("%s", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_DEVICE_OPEN);

	_carlife->status	=	CARLIFE_DEVICE_OPEN;
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_CONNECT_SUCCESS);

	_carlife->status	=	CARLIFE_CONNECT_SUCCESS;
	return FALSE;
}		/* -----  end of static function mit_connect_success  ----- */

static void ea_native_start(MHDev * dev, gpointer user_data )
{


	g_message("ea_native_start");
	segment_len	=	0;

	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	GSource * _source	=	g_idle_source_new();
	g_source_set_callback( _source, emit_connect_success, _carlife, NULL);
	mh_io_dispatch(MH_IO( _carlife), _source);

	g_source_unref( _source);

	uint8_t * sendPackage	=	_carlife->sendPackage;
	uint32_t _len	=	0;

	S_HU_PROTOCOL_VERSION_t huProtocolVersion={1,0};


	ios_sendCmdHUProtoclVersion( &huProtocolVersion, sendPackage, &_len );

	g_message("hu***************************************->md--->%x--->IOS_CMD_HU_PROTOCOL_VERSION", IOS_CMD_HU_PROTOCOL_VERSION);
	//			DEBUG_HEX_DISPLAY( sendPackage, _len );




	mh_dev_write_ea_native_data( dev, sendPackage, _len);


	g_message("%s", __func__);
}		/* -----  end of static function ea_native_start  ----- */

static gboolean carlife_start( gpointer user_data )
{	

	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	g_message("carlife_start---->_carlife:%p", _carlife);
	Cmd_Ret * _res	=	NULL;

	GSource * _source	=	g_idle_source_new();
	g_source_set_callback( _source, _init, (gpointer)_carlife, NULL);
	g_source_attach( _source, _carlife->pipe_param->context);
	g_source_unref( _source);
//	g_thread_new("carlife_init", _init, user_data);

	if(!g_strcmp0(_carlife->md_os, "android") &&  _carlife->exist	==	true)
	{
	
//		char * _cmd	=	g_strdup_printf("adb -s %s -d shell getprop ro.build.version.release", MH_DEV( _carlife)->serial);
//
//		_res	=	Cmd_With_Result( _cmd);
//
//		g_free( _cmd);
//		if( _res 	!=	NULL)
//		{
//			_carlife->android_version	=	g_strdup( _res->data );
//			g_message("android_version--->%s", _carlife->android_version);
//			g_message("g_signal_emit_by_name:%p", _carlife);
//			g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_GET_MD_VERSION);
//			g_free( _res);
//		}
//
//		_cmd	=	g_strdup_printf("adb -s %s shell mkdir /data/local/tmp/dalvik-cache", MH_DEV( _carlife)->serial);
//
//		doCmd( _cmd);
//
//		g_free( _cmd);
//
//		setup_bdim( _carlife );

		g_signal_emit_by_name(MH_DEV( _carlife), "dev_status", CARLIFE_RUN_BDIM);
//		check_bdsc( _carlife );
//
//		_cmd	=	g_strdup_printf("adb -s %s shell am start -n com.baidu.carlife/.CarlifeActivity", MH_DEV( _carlife)->serial);
//
//		_res	=	Cmd_With_Result(_cmd);
//
//		g_free( _cmd);

		g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_LAUNCH_APP);	
//
//		check_bdsc( _carlife );
//
//		if( g_strrstr( _res->data, "not") == NULL)
//		{
//			g_message("return :%s", _res->data);
//			g_message("sleep 3333333333333333333");
//			sleep(3);
//
//		}
//		else
//		{
//			g_message("return :%s", _res->data);
//			g_message("sleep 11111111111111111");
//			sleep(1);
//		}
//		g_free( _res);
//		setup_bdsc( _carlife);

		_carlife_init();


		g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_CONNECT_SUCCESS);
		_createThread( _carlife ); 


	}
	else if( ! g_strcmp0( _carlife->md_os, "ios"))
	{
		//		const char * _eaProName =       getenv("MH_EA_PROTOCOL_NAME");		
		char * _eaProName	=	g_strdup("com.baidu.lbs.CarLife");
//		g_signal_connect( _carlife->iap2Dev, "ea_session_start", (void *)ea_session_start, _carlife);
//		g_signal_connect( _carlife->iap2Dev, "ea_session_data", (void *)ea_session_data, _carlife);
//		g_signal_connect( _carlife->iap2Dev, "ea_session_stop", (void *)ea_session_stop, _carlife);

		bool _flag;
		mh_object_get_properties( (MHObject*)_carlife->iap2Dev, "ea_native_flag", &_flag, NULL);
		if( _flag	==	true)
		{
			g_message("ea native flag is true---->can start ea_native_start");
			ea_native_start(_carlife->iap2Dev, _carlife);
		}
		g_signal_connect( _carlife->iap2Dev, "ea_native_start", (void *)ea_native_start, _carlife);
		g_signal_connect( _carlife->iap2Dev, "ea_native_data", (void *)ea_native_data, _carlife);
		g_signal_connect( _carlife->iap2Dev, "ea_native_stop", (void *)ea_native_stop, _carlife);

		mh_dev_request_app_launch( _carlife->iap2Dev, _eaProName);
			g_free( _eaProName);

	}
	return	FALSE;
}		/* -----  end of static function carlife_start  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _send_signal_touch
 *  Description:  
 * =====================================================================================
 */
static void _send_signal_touch( MHDev * dev, MHTouchType press, guint x0, guint y0)
{
//	g_message_dbg("%s->carlife received touch signal=(%d, %d, %d)",__func__, press, x0, y0);
	MHDevCarlife * _carlife	=	MH_DEV_CARLIFE( dev);

	uint32_t x1, y1, x2, y2;
	uint32_t w0, h0, w1, h1, w2, h2;
	w1	=	_carlife->video_param->width;
	h1	=	_carlife->video_param->height;
	w0	=	_carlife->width;
	h0	=	_carlife->height;
	
	x1	=	(x0 * w1)/w0;
	y1	=	(y0 * h1)/h0;
//	x2	=	(x0 * 1920)/_carlife->width;
//	y2	=	(y0 * 1080)/_carlife->height;
	if( !g_strcmp0( _carlife->md_os, "ios"))
	{

		g_message_dbg("ios->x:%d, y:%d");
		uint32_t _len	=	0;
		ios_sendTouch( press, x1, y1, _carlife->sendPackage, &_len);
//		g_message("ios _send_signal_touch start output hex");
//		DEBUG_HEX_DISPLAY( _carlife->sendPackage, _len);
//		g_message("ios _send_signal_touch end output hex");
		
		mh_dev_write_ea_native_data(_carlife->iap2Dev, _carlife->sendPackage, _len);
	}
	else
	{

		switch( press)
		{
			case TOUCH_DOWN:
				{
					S_TOUCH_ACTION_DOWN_t * _touchDown	=	g_new0( S_TOUCH_ACTION_DOWN_t, 1);
					_touchDown->x	=	x1;
					_touchDown->y	=	y1;
					C_ctrlTouchActionDown( _touchDown );
					g_free( _touchDown);
				}
				break;
			case TOUCH_UP:
				{
					S_TOUCH_ACTION_UP_t * _touchUp	=	g_new0( S_TOUCH_ACTION_UP_t, 1);
					_touchUp->x	=	x1;
					_touchUp->y	=	y1;
					C_ctrlTouchActionUp( _touchUp );
					g_free( _touchUp);
				}
				break;
			case TOUCH_MOVE:
				{
					S_TOUCH_ACTION_MOVE_t * _touchMove	=	g_new0( S_TOUCH_ACTION_MOVE_t, 1);
					_touchMove->x	=	x1;
					_touchMove->y	=	y1;
					C_ctrlTouchActionMove( _touchMove );
					g_free( _touchMove);
				}
				break;
			case TOUCH_SIGNAL_CLICK:
				{
					S_TOUCH_SIGNAL_CLICK_t * _touchSignalClick	=	g_new0( S_TOUCH_SIGNAL_CLICK_t, 1);
					_touchSignalClick->x	=	x1;
					_touchSignalClick->y	=	y1;
					C_ctrlTouchSigleClick( _touchSignalClick );
					g_free( _touchSignalClick);
				}
				break;
			case TOUCH_DOUBLE_CLICK:
				{
					S_TOUCH_DOUBLE_CLICK_t * _touchDoubleClick	=	g_new0( S_TOUCH_DOUBLE_CLICK_t, 1);
					_touchDoubleClick->x	=	x1;
					_touchDoubleClick->y	=	y1;
					C_ctrlTouchDoubleClick( _touchDoubleClick );
					g_free( _touchDoubleClick);
				}
				break;
			case TOUCH_LONG_PRESS:
				{
					S_TOUCH_LONG_PRESS_t * _touchLongPress	=	g_new0( S_TOUCH_LONG_PRESS_t, 1);
					_touchLongPress->x	=	x1;
					_touchLongPress->y	=	y1;
					C_ctrlTouchLongPress( _touchLongPress );
					g_free( _touchLongPress);
				}
				break;
			default:
				g_message("invalid press type :%d", press);
				break;
		}
	}
}		/* -----  end of static function _send_signal_touch  ----- */
 /* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _start
 *  Description:  
 * =====================================================================================
 */
static void _start( MHDev * dev)
{
	g_message("%s->carlife received ",__func__);

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, carlife_start,(gpointer) dev, NULL );

	mh_io_dispatch( MH_IO( dev ), _source);

	g_source_unref( _source );

}		/* -----  end of static function _start  ----- */

Cmd_Ret * Cmd_With_Result( const char * cmd)
{
	g_message("%s--->%s", __func__, cmd);
	Cmd_Ret	* _res	=	NULL;
	if( cmd == NULL)
	{
		g_message("%s cmd == NULL", __func__);
		return _res;
	}
	FILE * _fp	=	popen( cmd, "r");
	if(	_fp	==	NULL)
	{
		g_message("Cmd_With_Result popen failed-->errno:%d ", errno);
		return _res;
	}
	_res	=	g_new0( Cmd_Ret, 1 );

	_res->len	=	fread( _res->data, sizeof( char ), MAX_CMD_RET_LENGTH-1, _fp );

	_res->ret	=	(pclose(_fp)==0);
	g_message("%s----->out", __func__);
	return _res;

}
gboolean doCmd( const char * cmd)
{
	g_message("%s-->%s", __func__, cmd);
	FILE * _fp;
	gboolean _res	=	FALSE;
	if(cmd == NULL)
	{
		g_message("doCmd cmd == NULL");
	}
	else if( NULL == (_fp	=	popen( cmd, "r")))
	{
		perror("doCmd popen() excute failed!");

	}
	else if( pclose( _fp) 	!= 0 )
	{
		perror("doCmd pclose() excute failed!");
	}
	else
	{
		_res	=	TRUE;
	}
	g_message("%s------------>out", __func__);
	return _res;

}
static void audio_need_data( GstAppSrc * src, guint arg1, gpointer user_data )
{
//	g_message( "\n   %s %d\n", __func__,arg1 );
}		/* -----  end of static function audio_enough_data  ----- */
static void audio_enough_data( GstElement * src, gpointer user_data )
{
	g_message( "\n\n\n%s\n\n\n", __func__ );
}
static void audio_setupSrc( GstElement * object, GstElement * element, gpointer user_data )
{
	g_message("\n\n\n\n------------------------->%s\n\n\n", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;

	_carlife->audio_param->src	=	element;

	GstCaps * _caps;

	g_object_set( element, "stream-type", 0, "is-live", TRUE,
			"block",TRUE, "format",GST_FORMAT_TIME,NULL);
//
	g_object_set( element, "do-timestamp", TRUE, NULL );

	g_object_set( element, "min-latency",(gint64)0, NULL );

	g_object_set( element, "max-latency", (gint64)0, NULL );


	_caps	=	gst_caps_new_simple("audio/x-raw",
			"format", G_TYPE_STRING, "S16LE",
			"endianness", G_TYPE_INT, 1234,
			"signed", G_TYPE_BOOLEAN, TRUE,
			"width", G_TYPE_INT, 16,
			"depth", G_TYPE_INT, 16,
			"layout", G_TYPE_STRING,"interleaved",
			"channels", G_TYPE_INT, _carlife->audio_param->channelConfig,
			"rate", G_TYPE_INT, _carlife->audio_param->sampleRate, 
			NULL);

	g_object_set( element, "caps", _caps, NULL);
	
	gst_caps_unref( _caps );
	
	g_signal_connect( element, "need-data", G_CALLBACK( audio_need_data ), NULL );
	g_signal_connect( element, "enough-data", G_CALLBACK( audio_enough_data ), element );

}		/* -----  end of static function audio_setupSrc  ----- */
static void video_need_data( GstAppSrc * src, guint arg1, gpointer user_data )
{
//	g_message( "\n   %s %d\n", __func__,arg1 );
}		/* -----  end of static function audio_enough_data  ----- */
static void video_enough_data( GstElement * src, gpointer user_data )
{
//	g_message( "%s", __func__ );
}

static void video_setupSrc( GstElement * object, GstElement * element, gpointer user_data )
{
	g_message("\n\n\n\n\n\n\n%s\n\n\n\n\n\n\n", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	_carlife->video_param->src	=	element;

	GstCaps * _caps;


	g_object_set( element, "stream-type", GST_APP_STREAM_TYPE_STREAM,  
			"is-live", TRUE, "block", TRUE,
			"format", GST_FORMAT_TIME, "max-bytes", (gint64)500000, NULL);
	g_object_set( element, "do-timestamp", TRUE, "min-latency", (gint64)0,"max-latency", (gint64)0, NULL);
	
	_caps 	=	gst_caps_new_simple ("video/x-h264",
			"stream-format", G_TYPE_STRING, "byte-stream",
//			"stream-format", G_TYPE_STRING, "avc",
			"alignment", G_TYPE_STRING,"au",
			"profile", G_TYPE_STRING, "baseline",
			"width", G_TYPE_INT, _carlife->video_param->width,
			"height", G_TYPE_INT, _carlife->video_param->height,
			"framerate", GST_TYPE_FRACTION, _carlife->video_param->frameRate, 1,
			NULL);

	g_object_set( element, "caps", _caps, NULL);

	g_object_set( element, "do-timestamp", TRUE, NULL );

	g_object_set( element, "min-latency",(gint64)0, NULL );

	g_object_set( element, "max-latency", (gint64)0, NULL );

	gst_caps_unref( _caps );

	g_signal_connect( _carlife->video_param->src, "need-data", G_CALLBACK( video_need_data ), NULL );
	g_signal_connect( _carlife->video_param->src, "enough-data", G_CALLBACK( video_enough_data ),NULL );

}		/* -----  end of static function video_setupSrc  ----- */
static void navi_need_data( GstAppSrc * src, guint arg1, gpointer user_data )
{
	g_message( "\n   %s %d\n", __func__,arg1 );
}		
static void navi_enough_data( GstElement * src, gpointer user_data )
{
	g_message( "%s", __func__ );
}


static void navi_setupSrc( GstElement * object, GstElement * element, gpointer user_data )
{
	g_message("\n\n\n\n------------------------->%s\n\n\n", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;

	_carlife->navi_param->src	=	element;

	GstCaps * _caps;

	g_object_set( element, "stream-type", 0, "is-live", TRUE,
			"block",TRUE, "format",GST_FORMAT_TIME,NULL);
//
	g_object_set( element, "do-timestamp", TRUE, NULL );

	g_object_set( element, "min-latency",(gint64)0, NULL );

	g_object_set( element, "max-latency", (gint64)0, NULL );


	_caps	=	gst_caps_new_simple("audio/x-raw",
			"format", G_TYPE_STRING, "S16LE",
			"endianness", G_TYPE_INT, 1234,
			"signed", G_TYPE_BOOLEAN, TRUE,
			"width", G_TYPE_INT, 16,
			"depth", G_TYPE_INT, 16,
			"layout", G_TYPE_STRING,"interleaved",
			"channels", G_TYPE_INT, _carlife->navi_param->channelConfig,
			"rate", G_TYPE_INT, _carlife->navi_param->sampleRate, 
			NULL);

	g_object_set( element, "caps", _caps, NULL);
	
	gst_caps_unref( _caps );
	
	g_signal_connect( element, "need-data", G_CALLBACK( navi_need_data ), NULL );
	g_signal_connect( element, "enough-data", G_CALLBACK( navi_enough_data ), element );

}		/* -----  end of static function navi_setupSrc  ----- */

static gpointer media_output( gpointer user_data )
{
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;

	g_main_loop_run( _carlife->audio_param->mainloop );

	g_main_loop_unref( _carlife->audio_param->mainloop );
	g_message("%s--->self->audio_param->context:%p", __func__, _carlife->audio_param->context);


	return NULL;
}		/* -----  end of static function media_output  ----- */
static gboolean busCallback (GstBus *bus,GstMessage *message,gpointer data)
{
	gboolean _res;
	char * _name	=	gst_element_get_name( message->src);
	if( strncmp( _name, "vpudec", 6 ) == 0 )
	{
		g_object_set( message->src, "low-latency", TRUE, "dis-reorder", TRUE,
				"frame-plus", 2,
				NULL );
		
		_res	=	G_SOURCE_REMOVE;
	}
	else
	{
		_res	=	G_SOURCE_CONTINUE;
	}
	if( _name != NULL)
	{
		g_free( _name );
	}
	return _res;
}

static gpointer video_output( gpointer user_data )
{
	g_message("\n\n\n%s\n\n\n", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;

	GstBus * _bus;
	guint _busWatch = 0;

//	g_main_context_push_thread_default( _carlife->video_param->context );

	_bus	=	gst_pipeline_get_bus( GST_PIPELINE( _carlife->video_param->pipeline ) );

	_busWatch	=	gst_bus_add_watch( _bus, busCallback, NULL );

	gst_object_unref( _bus );

	g_main_loop_run( _carlife->video_param->mainloop );

	g_main_loop_unref( _carlife->video_param->mainloop );

	g_source_remove( _busWatch);
	g_message("%s--->self->video_param->context:%p", __func__, _carlife->video_param->context);

	return NULL;
}	

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  navi_output
 *  Description:  
 * =====================================================================================
 */
static gpointer  navi_output( gpointer user_data)
{
	g_message("\n\n\n%s\n\n\n", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;

	g_main_loop_run( _carlife->navi_param->mainloop );

	g_main_loop_unref( _carlife->navi_param->mainloop );
	g_message("%s--->self->navi_param->context:%p", __func__, _carlife->navi_param->context);

	return NULL;
}		/* -----  end of static function navi_output  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_module_status
 *  Description:  
 * =====================================================================================
 */
static MHResult _register_module_status( MHDev * self, ModuleStatusListener * listener )
{
	g_message("dev_carlife.c:%s----->_carlife->MSlistener:%p", __func__, listener);
	MHDevCarlife *_carlife	=	MH_DEV_CARLIFE( self);	
	_carlife->MSlistener->callback =	listener->callback;
	_carlife->MSlistener->user_data	=	listener->user_data;
	return MH_OK;
}		/* -----  end of static function _register_module_status  ----- */
static void vrtts_need_data( GstAppSrc * src, guint arg1, gpointer user_data )
{
	g_message( "\n   %s %d\n", __func__,arg1 );
}		
static void vrtts_enough_data( GstElement * src, gpointer user_data )
{
	g_message( "%s", __func__ );
}

static void vrtts_setupSrc( GstElement * object, GstElement * element, gpointer user_data )
{
	g_message("\n\n\n\n------------------------->%s\n\n\n", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;

	_carlife->VRtts_param->src	=	element;

	GstCaps * _caps;

	g_object_set( element, "stream-type", 0, "is-live", TRUE,
			"block",TRUE, "format",GST_FORMAT_TIME,NULL);
//
	g_object_set( element, "do-timestamp", TRUE, NULL );

	g_object_set( element, "min-latency",(gint64)0, NULL );

	g_object_set( element, "max-latency", (gint64)0, NULL );


	_caps	=	gst_caps_new_simple("audio/x-raw",
			"format", G_TYPE_STRING, "S16LE",
			"endianness", G_TYPE_INT, 1234,
			"signed", G_TYPE_BOOLEAN, TRUE,
			"width", G_TYPE_INT, 16,
			"depth", G_TYPE_INT, 16,
			"layout", G_TYPE_STRING,"interleaved",
			"channels", G_TYPE_INT, 1,
			"rate", G_TYPE_INT, 16000, 
			NULL);

	g_object_set( element, "caps", _caps, NULL);
	
	gst_caps_unref( _caps );
	
	g_signal_connect( element, "need-data", G_CALLBACK( vrtts_need_data ), NULL );
	g_signal_connect( element, "enough-data", G_CALLBACK( vrtts_enough_data ), element );

}		/* -----  end of static function vrtts_setupSrc  ----- */
static gboolean _vrbus( GstBus * bus, GstMessage * message, gpointer user_data )
{
	g_message("[%lld]%s->%d",UpTicks(), __func__, GST_MESSAGE_TYPE( message));
	switch( GST_MESSAGE_TYPE( message ))
	{
	case GST_MESSAGE_EOS:
		g_signal_emit_by_name(_carlife, "dev_status", CARLIFE_VR_STOP);
		g_message("GST_MESSAGE_EOS");
		break;
	default:
		break;
	}
	return TRUE;
}		/* -----  end of static function _vrbus  ----- */

static gpointer vrtts_output( gpointer user_data )
{
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	GstBus	* _bus;
	guint _busWatch	=	0;
	_bus	=	gst_pipeline_get_bus( GST_PIPELINE( _carlife->VRtts_param->pipeline));
	_busWatch	=	gst_bus_add_watch( _bus, _vrbus, NULL);

	g_object_unref(_bus);

	g_main_loop_run( _carlife->VRtts_param->mainloop );

	g_main_loop_unref( _carlife->VRtts_param->mainloop );

	g_source_remove( _busWatch);

	g_message("%s--->self->VRtts_param->context:%p", __func__, _carlife->VRtts_param->context);

	return NULL;
}		/* -----  end of static function vrtts_output  ----- */
static gpointer vr_record( gpointer user_data )
{
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;

	g_main_loop_run( _carlife->VRRecord_param->mainloop );

	g_main_loop_unref( _carlife->VRRecord_param->mainloop );



	return NULL;
}		/* -----  end of static function vrtts_output  ----- */
static gpointer pipe_thread(const gpointer user_data)
{
	g_message("%s--->in", __func__);
	MHDevCarlife * self	=	(MHDevCarlife *)user_data;

	g_main_loop_run( self->pipe_param->mainloop );

	if(g_main_loop_is_running(self->pipe_param->mainloop))
	{
		g_main_loop_unref( self->pipe_param->mainloop );
	}

	self->pipe_param->mainloop	=	NULL;

	g_message("%s--->out", __func__);


	return NULL;
}
void cmdProtocolVersionMatchStatus(S_PROTOCOL_VERSION_MATCH_SATUS_t* status){
	g_message("cmdProtocolVersionMatchStatus() is invoked");

g_message("***********************%s--->width:%d, height:%d", __func__, _carlife->width, _carlife->height);
	g_message("protocol version match status: %d,  width:%d, height:%d",status->matchStatus, _carlife->width, _carlife->height);
	S_VIDEO_ENCODER_INIT_t _initVideoParam	=	{_carlife->width,_carlife->height,  _carlife->frameRate};
	if( _carlife != NULL && _carlife->launch_mode != CARLIFE_LAUNCH_NULL)
	{
		switch( _carlife->launch_mode)
		{
			case CARLIFE_LAUNCH_NORMAL:
				C_cmdLaunchModeNormal();
				break;

			case CARLIFE_LAUNCH_PHONE:
				C_cmdLaunchModePhone();
				break;

			case CARLIFE_LAUNCH_MAP:
				C_cmdLaunchModeMap();
				break;

			case CARLIFE_LAUNCH_MUSIC:
				C_cmdLaunchModeMusic();
				break;

			default:
				g_message("carlife launch_mode is %d, mode is error", _carlife->launch_mode);
				break;
		}
	}
	C_cmdStatisticInfo( &statisticsInfo);
	C_cmdVideoEncoderInit(&_initVideoParam);
}
void cmdMdAuthenResult( S_MD_AUTHEN_RESULT_t * result)
{
	g_message("md authenResult :%d", result->authenResult);
}
void cmdMDInfro(S_MD_INFO_t* mdInfro){
	g_message("cmdMDInfro() is invoked");
	g_message("os: %s",mdInfro->os);
	g_message("board: %s",mdInfro->board);
	g_message("bootloader: %s",mdInfro->bootloader);
	g_message("brand: %s",mdInfro->brand);
	g_message("cpu_abi: %s",mdInfro->cpu_abi);
	g_message("cpu_abi2: %s",mdInfro->cpu_abi2);
	g_message("device: %s",mdInfro->device);
	g_message("display: %s",mdInfro->display);
	g_message("fingerprint: %s",mdInfro->fingerprint);
	g_message("hardware: %s",mdInfro->hardware);
	g_message("host: %s",mdInfro->host);
	g_message("cid: %s",mdInfro->cid);
	g_message("manufacturer: %s",mdInfro->manufacturer);
	g_message("model: %s",mdInfro->model);
	g_message("product: %s",mdInfro->product);
	g_message("serial: %s",mdInfro->serial);
	g_message("codename: %s",mdInfro->codename);
	g_message("incremental: %s",mdInfro->incremental);
	g_message("release: %s",mdInfro->release);
	g_message("sdk: %s",mdInfro->sdk);
	g_message("sdk_int: %d",mdInfro->sdk_int);
	g_message("token:%s", mdInfro->token);
	g_message("btaddress:%s", mdInfro->btaddress);
	if( _carlife->md_bt_address != NULL)
	{
		g_free( _carlife->md_bt_address);
	}
	_carlife->md_bt_address	=	g_strdup(mdInfro->btaddress);

	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_RECV_MD_INFO);

	
}
//MD->HU 10006
void cmdMDBTPairInfro(S_BT_PAIR_INFO_t* info){
	g_message("\n\n\n\n\n\ncmdMDBTPairInfro() is invoked");
	g_message("/taddress: %s",info->address);
	g_message("/tpassKey: %s",info->passKey);
	g_message("/thash: %s",info->hash);
	g_message("/trandomizer: %s",info->randomizer);
	g_message("/tuuid: %s",info->uuid);
	g_message("/tname: %s",info->name);
	g_message("/tstatus: %d\n\n\n\n\n\n",info->status);
	if( g_strcmp0( info->address, _carlife->md_bt_address) != 0)
	{
		if( _carlife->md_bt_address != NULL)
		{
			g_free( _carlife->md_bt_address);
			_carlife->md_bt_address	=	g_strdup( info->address);
		}
	}
	_carlife->md_bt_passKey	=	g_strdup( info->passKey );

	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_BT_RECV_MD_INFO);
}
void cmdVideoEncoderInitDone(S_VIDEO_ENCODER_INIT_DONE_t* videoEncoderInitDone){
	g_message("cmdVideoEncoderInitDone() is invoked");
	g_message("***********************%s--->width:%d, height:%d, frameRate:%d", __func__,
			videoEncoderInitDone->width, videoEncoderInitDone->height, videoEncoderInitDone->frameRate);

	gint _pixel_n	=	videoEncoderInitDone->width * _carlife->height;
	gint _pixel_d	=	videoEncoderInitDone->height *  _carlife->width;

	g_message("_pixel_n:%d, _pixel_d:%d", _pixel_n, _pixel_d);

	g_object_set( G_OBJECT(_carlife->video_param->videoSink), "pixel-aspect-ratio", _pixel_n, _pixel_d, NULL );

	_carlife->video_param->width	=	videoEncoderInitDone->width;
	_carlife->video_param->height	=	videoEncoderInitDone->height;
	_carlife->video_param->frameRate	=	videoEncoderInitDone->frameRate;
	
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_VIDEO_INIT_DONE);

//	gst_element_set_state( _carlife->video_param->pipeline, GST_STATE_PLAYING );
//	g_message("%s->gst_element_set_state(video)->GST_STATE_PLAYING", __func__);
//	_carlife->video_param->startticks	=	UpTicks();
//	C_cmdVideoEncoderStart();
}

void cmdVideoEncoderFrameRateChangeDone(S_VIDEO_ENCODER_FRAME_RATE_CHANGE_DONE_t* videoEncoderFrameRateChangeDone){
	g_message("cmdVideoEncoderFrameRateChangeDone() is invoked");
	g_message("\tframeRate: %d",videoEncoderFrameRateChangeDone->frameRate);
;}

void cmdTelStateChangeIncoming(){
	g_message("cmdTelStateChangeIncoming() is invoked");
}

void cmdTelStateChangeOutGoing(){
	g_message("cmdTelStateChangeOutGoing() is invoked");
}

void cmdTelStateChangeIdle(){
	g_message("cmdTelStateChangeIdle() is invoked");
}
void cmdTelStateChangeInCalling(){
	g_message("cmdTelStateChangeInCalling() is invoked");
}

void cmdScreenOn(){
	g_message("cmdScreenOn() is invoked");
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_SCREEN_ON);
}
void cmdScreenOff(){
	g_message("cmdScreenOff() is invoked");
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_SCREEN_OFF);
}
void cmdScreenUserPresent(){
	g_message("cmdScreenUserPresent() is invoked");
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_USER_PRESENT);

}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  wakeup_input
 *  Description:  
 * =====================================================================================
 */
static gboolean wakeup_input( gpointer user_data)
{
	if(vrEndFlag)
	{
		g_message("%s----> vr record end----->Mic_flag=%d", __func__, _carlife->VRRecord_param->Mic_flag);
		return FALSE;
	}
	MHDevCarlife * _carlife	=	(MHDevCarlife *)user_data;
	_carlife->VRRecord_param->Mic_flag++;
	g_message("%s---->Mic_flag=%d", __func__, _carlife->VRRecord_param->Mic_flag);

	/////record/////
	FILE * _fp	=	NULL;
	static int _count =	0;

	char * _path	=	g_strdup_printf("/tmp/wake%d", _count);
	g_message("\n\nvr path:%s\n\n", _path);
	_fp	=	fopen( _path, "w+");
	free( _path);
	_count ++;
	////////record/////
	void * _device	=	NULL;
	uint32_t _timeStamp	=	0;

	_device	=	mh_dev_carlife_open_pcm_device(CARLIFE_SAMPLE_S16LE, 16000, 1);
	if( _device == 	NULL)

	{
		g_warning( "mh_dev_carlife_open_pcm_device return NULL" );
		return FALSE;

	}
	if( g_strcmp0( _carlife->md_os, "ios") == 0)
	{
		for(;;)
		{

			uint32_t _headLen;
			_headLen	=	ios_sendVRRecordData( _carlife->sendPackage, 1024, _timeStamp);

			int ret = mh_dev_carlife_read_pcm_data( _device, _carlife->sendPackage + _headLen, 1024);
//			if(ret <= 0)
//			{
//				g_warning( "ios-----mh_dev_carlife_read_pcm_data return <= 0[%d]!!!!!\n", ret);
//				goto FINISH;
//			}

			if( _carlife->VRRecord_param->Mic_flag	<= 1 )
			{
				g_message("%s---->ios vr send end", __func__, _carlife->VRRecord_param->Mic_flag);
				vrEndFlag = 1;
				goto FINISH;
			}
			
			if(mh_dev_write_ea_native_data( _carlife->iap2Dev, _carlife->sendPackage, 1044) < 0)
				goto FINISH;
			_timeStamp	=	_timeStamp + 32;

		}

	}
	else
	{
		for(;;)
		{
			guint8 _buf[1024];
			memset(_buf, 0, sizeof(_buf));

			int ret = mh_dev_carlife_read_pcm_data( _device, _buf, 1024);
			int _len = strlen(_buf);
			fwrite( _buf, 1024,1, _fp);

//			DEBUG_HEX_DISPLAY(_buf , 1024)
//			if(_len <= 0)
//			{
//				g_warning( "android-----mh_dev_carlife_read_pcm_data _buf length <= 0[%d]!!!!!\n", _len);
//				goto FINISH;
//			}

			if( _carlife->VRRecord_param->Mic_flag	<= 1 )
				goto FINISH;
			if(C_sendVRRecordData( _buf, 1024, _timeStamp) < 0)
			{
				g_message("%s---->android vr send end", __func__, _carlife->VRRecord_param->Mic_flag);
				vrEndFlag = 1;
				goto FINISH;
			}
			_timeStamp	=	_timeStamp + 32;

		}
	}
FINISH:
	if ( _device )
	{	
		g_message("\n\n%s--->FINISH\n\n\n", __func__);
		mh_dev_carlife_close_pcm_device( _device );
		fclose( _fp);
	}
		


	return FALSE;
}		/* -----  end of static function wakeup_input  ----- */

void cmdMicRecordWakeupStart(){
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_MIC_RECORD_WAKEUP_START);
	
	g_message("cmdMicRecordWakeupStart() is invoked");
	
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, wakeup_input, _carlife, NULL);

	g_source_attach( _source, _carlife->VRRecord_param->context);
			
	g_source_unref( _source);
	
}
void cmdMicRecordEnd(){
	vrEndFlag = 1;
	g_message("cmdMicRecordEnd() is invoked");

	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_MIC_RECORD_END);

	if( _carlife->VRRecord_param->Mic_flag <= 1)
	{

	}
	else
	{
		_carlife->VRRecord_param->Mic_flag--;
	}
	g_message("%s---->Mic_flag=%d", __func__, _carlife->VRRecord_param->Mic_flag);
}

void cmdMicRecordRecogStart(){
	vrEndFlag = 0;
	gst_element_set_state( _carlife->VRtts_param->pipeline, GST_STATE_PAUSED);

	_carlife->VRtts_param->state	=	GST_STATE_PAUSED;

	g_signal_emit_by_name(MH_DEV( _carlife), "dev_status", CARLIFE_MIC_RECORD_RECOG_START);
//	_carlife->VRRecord_param->Mic_flag++;
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, wakeup_input, _carlife, NULL);

	g_source_attach( _source, _carlife->VRRecord_param->context);
			
	g_source_unref( _source);


	g_message("%s---->Mic_flag=%d", __func__, _carlife->VRRecord_param->Mic_flag);
	g_message("cmdMicRecordRecogStart() is invoked");
}

//0x00010026
void cmdModuleStatus(S_MODULE_STATUS_LIST_MOBILE_t* data)
{
	g_message("[%lld]carlife.c->%s is invoked-->cnt:%d", UpTicks(),__func__, data->cnt);
	int i=0;
	for(i; i < data->cnt; i++)
	{
		g_message("module[%d]=%d status=%d",i, data->moduleStatus[i].moduleID, data->moduleStatus[i].statusID );
	}
	if( _carlife->MSlistener->callback != NULL)
	{
		_carlife->MSlistener->callback( MH_DEV(_carlife), (ModuleStatusList*)data, _carlife->MSlistener->user_data);
	}
}

//0x00010030
void cmdNaviNextTurnInfo(S_NAVI_NEXT_TURN_INFO_t* data){
	g_message("cmdNaviNextTurnInfo is invoked");
}

//0x00010031
void cmdCarDataSubscribe(S_VEHICLE_INFO_LIST_t* data){
	g_message("cmdCarDataSubscribe is invoked");
}

//0x00010033
void cmdCarDataSubscribeStart(S_VEHICLE_INFO_LIST_t* data){	
	g_message("cmdCarDataSubscribeStart is invoked");
}

//0x00010034
void cmdCarDataSubscribeStop(S_VEHICLE_INFO_LIST_t* data){
	g_message("cmdCarDataSubscribeStop is invoked");
}

//0x00010035
void cmdMediaInfo(S_MEDIA_INFO_t* info){
	g_message("cmdMediaInfo is invoked");
	
	g_message("source= %s",info->source);
	g_message("song= %s",info->song);
	g_message("artist= %s",info->artist);
	g_message("album= %s",info->album);
//	g_message("albumArt= ",info->albumArt);
	g_message("duration= %d",info->duration);
	g_message("playlistNum= %d",info->playlistNum);
	g_message("songId= %s",info->songId);
	g_message("mode= %d",info->mode);
	
	
}

//0x00010036
void cmdMediaProgressBar(S_MEDIA_PROGRESS_BAR_t* data){
	g_message("cmdMediaProgressBar %d", data->progressBar);
}

//0x00010037
void cmdRegisterConnectException(S_CONNECTION_EXCEPTION_t* data){
	g_message("cmdRegisterConnectException is invoked");
}

//0x00010038
void cmdRegisterRequestGoToForeground(void){
	g_message("cmdRegisterRequestGoToForeground is invoked");
}

//0x00010039
void cmdUIActionSound(void){
	g_message("cmdUIActionSound is invoked");

	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_UI_ACTION_SOUND);

}

//0x00010049
void cmdRegisterMdAuthenResponse(S_AUTHEN_RESPONSE_t* response){
	g_message("cmdRegisterMdAuthenResponse is invoked");
	g_message("encryptValue= %s",response->encryptValue);
}


void cmdForeground(){
	
	return ;
	g_message("cmdForeground() is invoked");
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_FOREGROUND);
	gst_element_set_state( _carlife->video_param->pipeline, GST_STATE_PLAYING);
	g_message("%s->gst_element_set_state(video)->GST_STATE_PLAYING", __func__);

}

void cmdBackground(){
	g_message("cmdBackground() is invoked");
	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_BACKGROUND);
//	gst_element_set_state( _carlife->video_param->pipeline, GST_STATE_NULL);
//	g_message("%s->gst_element_set_state(video)->GST_STATE_NULL", __func__);
//
//	gst_element_set_state( _carlife->video_param->pipeline, GST_STATE_READY);
//	g_message("%s->gst_element_set_state(video)->GST_STATE_READY", __func__);



}

void cmdGoToDeskTop(){
	g_message("cmdGoToDeskTop() is invoked");
	g_signal_emit_by_name(MH_DEV( _carlife), "dev_status", CARLIFE_GOTO_DESKTOP);
	C_cmdVideoEncoderPause();
}

void MdExit_cb()
{
	g_message("%s", __func__);

	g_signal_emit_by_name(MH_DEV(_carlife), "dev_status", CARLIFE_APP_EXIT);
}

void videoDataReceive( uint8_t *data, uint32_t len){
//	DEBUG_HEX_DISPLAY( data, len);
//#ifdef DUP_CARLIFE_DATA
//
//	g_message("%s--->DUP_CARLIFE_DATA", __func__);
//	if( videoFp	==	NULL)
//	{
//
//		char * _path	=	g_strdup_printf("/tmp/android-%d", videoname);
//		g_message("%s----->videoFp	==	NULL",__func__);
//		videoFp		=	fopen( _path, "w+");
//		g_message("%s--->fopen:%s", __func__, _path);
//		videoname ++;
//		g_free( _path );
//	}
//	fwrite( data, len, 1, videoFp);
//#endif
//	g_message("\treceive video data: %d",len);
	uint64_t _time	=	UpTicks();

//	g_message("%s--->time:%lld", __func__,_time);	
//	g_message("%s--->len:%d", __func__, len);

   	GstBuffer * _buf;
	_buf	=	gst_buffer_new_allocate(NULL, len, NULL);
	gst_buffer_fill( _buf, 0, data, len);
	
	GSource * _source;
	_source	=	g_idle_source_new();
	g_source_set_callback(_source, emitVideoBuf, _buf, NULL);
	g_source_attach( _source, _carlife->video_param->context);
	g_source_unref( _source);
}
void mediaNormalData(uint8_t *data, uint32_t len){
#ifdef DUP_CARLIFE_MEDIA_DATA
	static FILE * _fp	=	NULL;
	static int _count	=	0;
	static int _name	=	0;
	g_message("%s--->DUP_CARLIFE_DATA", __func__);
	if( _fp	==	NULL)
	{

		char * _path	=	g_strdup_printf("/tmp/carlife-media-%d", _name++);
		g_message("save carlife media :%s",_path);
		_fp		=	fopen( _path, "w+");
		g_free( _path );
	}
	if( _count < 10000)
	{
		_count ++;
		g_message("%s---->%d", __func__, _count);
		fwrite( data, len, 1, _fp);
	}
	else
	{
		fwrite( data, len, 1, _fp);

		char * _path	=	g_strdup_printf("/tmp/carlife-media-%d", _name++);
		fclose( _fp);
		g_message("save carlife media :%s",_path);
		_fp	=	fopen(_path, "w+");
		_count	=	0;
		g_free( _path);

	}
#endif

	g_message_dbg("%s--->len:%d", __func__, len);
	GstBuffer * _buf;

	_buf	=	gst_buffer_new_allocate(NULL, len, NULL);

	gst_buffer_fill( _buf, 0, data, len);

	running = ((uint64_t)len)*1000000000 /( 4 * _carlife->audio_param->sampleRate)  + running;

	GST_BUFFER_PTS( _buf )	=	running;

	GSource * _source;

	_source	=	g_idle_source_new();

	g_source_set_callback( _source, emitAudioBuf, _buf, NULL);

	g_source_attach( _source, _carlife->audio_param->context);

	g_source_unref( _source ); 


}

void mediaPause(){
	g_message("mediaPause() is invoked");
	g_message("media pause status received!");
	gst_element_set_state(_carlife->audio_param->pipeline, GST_STATE_PAUSED);
	g_message("%s->gst_element_set_state(audio)->GST_STATE_PAUSED", __func__);

}

void mediaResume(){
	g_message("mediaResume() is invoked");
	g_message("media resume status received!");
	gst_element_set_state(_carlife->audio_param->pipeline, GST_STATE_PLAYING);
	g_message("%s->gst_element_set_state(audio)->GST_STATE_PLAYING", __func__);
}


void naviInit(S_AUDIO_INIT_PARAMETER_t *initParam){
	g_message("%s is invoked", __func__);
	g_message("sampleRate: %d", initParam->sampleRate);
	g_message("channelConfig: %d", initParam->channelConfig);
	g_message("sampleFormat: %d",initParam->sampleFormat);

	_carlife->navi_param->sampleRate	=	initParam->sampleRate;
	_carlife->navi_param->channelConfig	=	initParam->channelConfig;
	_carlife->navi_param->sampleFormat	=	initParam->sampleFormat;

	g_signal_emit_by_name(MH_DEV( _carlife), "dev_status", CARLIFE_NAVI_TTS_START);

	_carlife->navi_param->bytes_second	=	initParam->sampleRate * initParam->channelConfig * initParam->sampleFormat / 8;
	gst_element_set_state( _carlife->navi_param->pipeline, GST_STATE_READY);
	g_message("%s->gst_element_set_state(navi)->GST_STATE_READY", __func__);
	gst_element_set_state( _carlife->navi_param->pipeline, GST_STATE_PLAYING);
	g_message("%s->gst_element_set_state(navi)->GST_STATE_PLAYING", __func__);
	naviRunning	=	100000000;

}
void naviNormalData(uint8_t *data, uint32_t len){
	g_message("%s is invoked", __func__);
	g_message("receive navi data: %d bytes",len);
	GstBuffer * _buf;

	_buf	=	gst_buffer_new_allocate( NULL, len, NULL);

	gst_buffer_fill( _buf, 0, data, len);

	GST_BUFFER_PTS( _buf )	=	naviRunning;

	naviRunning	= ((uint64_t)len)*1000000000/_carlife->navi_param->bytes_second + naviRunning;


	GSource * _source;

	_source	=	g_idle_source_new();

	g_source_set_callback( _source, emitNaviBuf, _buf, NULL);

	g_source_attach( _source, _carlife->navi_param->context);

	g_source_unref( _source);
/*	
	for(int i=0;i<len;i++){
		cout<<data[i]<<" ";
	}

	cout);
*/
}

void naviStop(){
	g_message("%s is invoked", __func__);
	g_message("navi tts stop status received!");
	g_signal_emit_by_name(MH_DEV( _carlife), "dev_status", CARLIFE_NAVI_TTS_STOP);
//	gst_element_set_state( _carlife->navi_param->pipeline, GST_STATE_READY);
}

void vrStop(){
//	fclose( Fp); 
//	Fp	=	NULL;
	g_message("[%lld]vrStop() is invoked", UpTicks());
//	fclose( vr_file);
//	vr_file	=	NULL;

	g_message("%s---->[%lld]", __func__, UpTicks());
	 GstFlowReturn ret;
	g_signal_emit_by_name( _carlife->VRtts_param->src, "end-of-stream", &ret);

//	if( GST_FLOW_OK ==	gst_app_src_end_of_stream ((GstAppSrc *)(_carlife->VRtts_param->src)))
//	{
//	g_message("%s---->[%lld]------>GST_FLOW_OK", __func__, UpTicks());
		g_signal_emit_by_name(MH_DEV( _carlife), "dev_status", CARLIFE_VR_STOP);
//
//	}
//	else
//	{
//	g_message("%s---->[%lld]------>GST_FLOW_FLUSHING", __func__, UpTicks());
//	}
//
}

void vrNormalData(uint8_t *data, uint32_t len){
//	g_message("%s--->DUP_CARLIFE_DATA", __func__);
//	if( Fp	==	NULL)
//	{
//		static int count	=	0;
//		char * _path	=	g_strdup_printf("/tmp/vr-%d", count);
//		count ++;
//		g_message("%s----->Fp	==	NULL",__func__);
//		Fp		=	fopen( _path, "w+");
//		g_message("%s--->fopen:%s", __func__, _path);
//		g_free( _path );
//	}
//	fwrite( data, len, 1, Fp);
//return;

	g_message("%s------>[%lld]", __func__, UpTicks());
	if( _carlife->VRtts_param->state	==	GST_STATE_PAUSED)
	{
		gst_element_set_state( _carlife->VRtts_param->pipeline, GST_STATE_PLAYING);
		_carlife->VRtts_param->state	=	GST_STATE_PLAYING;
	}

	g_message("%s->len=%d", __func__, len);
	g_message("%s is invoked", __func__);
	g_message("receive vr data: %d bytes",len);
	GstBuffer * _buf;

	_buf	=	gst_buffer_new_allocate( NULL, len, NULL);

	gst_buffer_fill( _buf, 0, data, len);

	GST_BUFFER_PTS( _buf )	=	VRttsRunning;

	VRttsRunning	= ((uint64_t)len)*1000000000/_carlife->VRtts_param->bytes_second  + VRttsRunning;

	g_message("%s--->VRttsRunning=%lld", __func__, VRttsRunning);
	GSource * _source;

	_source	=	g_idle_source_new();

	g_source_set_callback( _source, emitVRttsBuf, _buf, NULL);

	g_source_attach( _source, _carlife->VRtts_param->context);

	g_source_unref( _source);

/*	
	for(int i=0;i<len;i++){
		cout<<data[i]<<" ";
	}

	cout);
*/
}
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  btAutoPairRequest
 *  Description:  
 * =====================================================================================
 */
//0x0001004d
void btAutoPairRequest( S_BT_START_PAIR_REQ_t * req)
{
	g_message("\n\n\n\n************************%s is invoked osType:%d, address:%s\n\n\n", __func__, req->osType, req->address);
//	S_BT_PAIR_INFO_t * _info	=	g_new0( S_BT_PAIR_INFO_t, 1);
//	_info->address	=	g_strdup_printf("%2X:%2X:%2X:%2X:%2X:%2X", 0xDD, 0x87, 0x17, 0x1D, 0xD4, 0x67);
//	_info->passKey	=	NULL;
//	_info->hash	=	NULL;
//	_info->randomizer	=	NULL;
//	_info->uuid	=	NULL;
//	_info->name	=	g_strdup("TestName");
//	_info->status	=	1;
//	C_cmdHUBTPairInfro( _info);
	

	if( _carlife->versionFlag == true)
	{
		g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_START_BT_AUTOPAIR);

	}
//	



}		/* -----  end of static function btAutoPairRequest  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  featureConfigRequest
 *  Description:  
 * =====================================================================================
 */
void featureConfigRequest()
{
	g_message("\n\n\n\n\n%s\n\n\n\n\n", __func__);

	int _value;
	char * _env_value =	NULL;

	S_FEATURE_CONFIG_LIST_t * _list	=	g_new0(S_FEATURE_CONFIG_LIST_t, 1);

	S_FEATURE_CONFIG_t * _configure	=	NULL;

	S_FEATURE_CONFIG_t * _last	=	NULL, *_next = NULL;

	_list->cnt	=	0;

	char * _env[7];
	_env[0]	=	"MH_DEV_CARLIFE_VOICE_MIC";
	_env[1]	=	"MH_DEV_CARLIFE_VOICE_WAKEUP";
	_env[2]	=	"MH_DEV_CARLIFE_BLUETOOTH_AUTO_PAIR";
	_env[3]	=	"MH_DEV_CARLIFE_BLUETOOTH_INTERNAL_UI";
	_env[4]	=	"MH_DEV_CARLIFE_FOCUS_UI";
	_env[5]	=	"MH_DEV_CARLIFE_MEDIA_SAMPLE_RATE";
	_env[6]	=	"MH_DEV_CARLIFE_AUDIO_TRANSMISSION_MODE";
	char * _key[7];
	_key[0]	=	"VOICE_MIC";
	_key[1]	=	"VOICE_WAKEUP";
	_key[2]	=	"BLUETOOTH_AUTO_PAIR";
	_key[3]	=	"BLUETOOTH_INTERNAL_UI";
	_key[4]	=	"FOCUS_UI";
	_key[5]	=	"MEDIA_SAMPLE_RATE";
	_key[6]	=	"AUDIO_TRANSMISSION_MODE";

	int i = 0;
	for( i	=	0; i < 7; i++)
	{
		_env_value	=	NULL;

		_env_value	=	getenv(_env[i]);

		if( _env_value != NULL)
		{
			_configure	=	g_new0( S_FEATURE_CONFIG_t, 1);

			_configure->key	=	g_strdup(_key[i]);
			_configure->value	=	atoi( _env_value);

			if( _last	== 	NULL)
			{
				_list->pFeatureConfig	=	_configure;
			}
			else
			{
				_last->pNext	=	_configure;
			}
			_last	=	_configure;

			_list->cnt++;

		}
	}



	g_message("%s->cnt:%d\n",__func__, _list->cnt);

	S_FEATURE_CONFIG_t * _print	=	_list->pFeatureConfig;

	for(i = 0; i < _list->cnt; i++)
	{
		g_message("configure[%d]:key->%s, value->%d", i,_print->key, _print->value);

		_print	=	_print->pNext;
	}



	if( !g_strcmp0(_carlife->md_os, "android") )
	{
		C_cmdFeatureConfigResponse( _list );
		S_BT_HFP_CONNECTION_t _conn;
		_conn.state	=	0;
		_conn.address	=	g_strdup( _carlife->md_bt_address );
		_conn.name	=	NULL;

		C_cmdBtHfpConnection( &_conn );

		g_free(_conn.address);

	}
	else
	{
		int _len 	=	0;
		ios_sendCmdFeatureConfigResponse( _list, _carlife->sendPackage, &_len);

		gint len	=	mh_dev_write_ea_data( _carlife->iap2Dev, _carlife->sendPackage , _len);

		g_message("mh_dev_write_ea_data return %d", len);


	}

	g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_FEATURE_CONFIG_DONE);

	_next	=	_list->pFeatureConfig;
	while( _next != NULL)
	{
		_last	=	_next;

		_next	=	_next->pNext;
		g_free( _last->key);
		g_free( _last);
	}
	g_free( _list);
	/////need free///
	
}		/* -----  end of function featureConfigRequest  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  btIdentifyResultInd
 *  Description:  
 * =====================================================================================
 */
void btIdentifyResultInd( S_BT_INDENTIFY_RESULT_IND_t * bt_res)
{
	g_message("\n\n%s->status:%d, address:%s", __func__, bt_res->status, bt_res->address);
	if( bt_res->status	== 1)
	{
		g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_BT_IDENTIFY_SUCCESS);

	}
	else if( bt_res->status	== 0)
	{
		g_signal_emit_by_name( MH_DEV( _carlife), "dev_status", CARLIFE_BT_IDENTIFY_FAILED);

	}


}		/* -----  end of function btIdentifyResultInd  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  BtHfpRequest_cb
 *  Description:  
 * =====================================================================================
 */
void BtHfpRequest_cb( S_BT_HFP_REQUEST_t * request)
{
	g_message("\n\n\n\n\n\n\n%s->command:%d, phoneNum:%s, dtmfCode:%d\n\n\n\n\n", __func__, request->command, request->phoneNum, request->dtmfCode);
	g_signal_emit_by_name( _carlife, "carlife_bt_hfp_request", request->command, request->phoneNum, request->dtmfCode);

}		/* -----  end of function BtHfpRequest_cb  ----- */

void mediaInit(S_AUDIO_INIT_PARAMETER_t *initParam){
	g_message("mediaInit() is invoked sampleRate:%d, channelConfig:%d, sampleFormat:%d", 
			initParam->sampleRate, initParam->channelConfig, initParam->sampleFormat);
	
	_carlife->audio_param->sampleRate	=	initParam->sampleRate;
	_carlife->audio_param->channelConfig	=	initParam->channelConfig;
	_carlife->audio_param->sampleFormat	=	initParam->sampleFormat;
	
	gst_element_set_state( _carlife->audio_param->pipeline, GST_STATE_READY);
		g_message("%s->gst_element_set_state(audio)->GST_STATE_READY", __func__);
	running	=	100000000;

	gst_element_set_state( _carlife->audio_param->pipeline, GST_STATE_PLAYING);
		g_message("%s->gst_element_set_state(audio)->GST_STATE_PLAYING", __func__);
}

static void _carlife_init()
{
	C_connection_disconnect();
	C_connectionSetup();
	C_cmdRegisterProtocolVersionMatchStatus(cmdProtocolVersionMatchStatus);
	C_cmdRegisterMDInfro(cmdMDInfro);
	C_cmdRegisterMDBTPairInfro(cmdMDBTPairInfro);
	C_cmdRegisterVideoEncoderInitDone(cmdVideoEncoderInitDone);
	C_cmdRegisterVideoEncoderFrameRateChangeDone(cmdVideoEncoderFrameRateChangeDone);
	C_cmdRegisterTelStateChangeIncoming(cmdTelStateChangeIncoming);
	C_cmdRegisterTelStateChangeOutGoing(cmdTelStateChangeOutGoing);
	C_cmdRegisterTelStateChangeIdle(cmdTelStateChangeIdle);
	C_cmdRegisterTelStateChangeInCalling(cmdTelStateChangeInCalling);
	C_cmdRegisterScreenOn(cmdScreenOn);
	C_cmdRegisterScreenOff(cmdScreenOff);
	C_cmdRegisterScreenUserPresent(cmdScreenUserPresent);
	C_cmdRegisterForeground(cmdForeground);
	C_cmdRegisterBackground(cmdBackground);
	C_cmdRegisterGoToDeskTop(cmdGoToDeskTop);
	C_cmdRegisterMicRecordWakeupStart(cmdMicRecordWakeupStart);
	//0x00010023
	C_cmdRegisterMicRecordEnd(cmdMicRecordEnd);
	//0x00010024
	C_cmdRegisterMicRecordRecogStart(cmdMicRecordRecogStart);
	//0x00010026
	C_cmdRegisterModuleStatus(cmdModuleStatus);
	//0x00010030
	C_cmdRegisterNaviNextTurnInfo(cmdNaviNextTurnInfo);
	//0x00010031
	C_cmdRegisterCarDataSubscribe(cmdCarDataSubscribe);	
	//0x00010033
	C_cmdRegisterCarDataSubscribeStart(cmdCarDataSubscribeStart);
	//0x00010034
	C_cmdRegisterCarDataSubscribeStop(cmdCarDataSubscribeStop);
	//0x00010035
	C_cmdRegisterMediaInfo(cmdMediaInfo);
	//0x00010036
	C_cmdRegisterMediaProgressBar(cmdMediaProgressBar);
	//0x00010037
	C_cmdRegisterConnectException(cmdRegisterConnectException);
	//0x00010038
	C_cmdRegisterRequestGoToForeground(cmdRegisterRequestGoToForeground);
	//0x00010039
	C_cmdRegisterUIActionSound(cmdUIActionSound);
	C_cmdRegisterMdAuthenResponse(cmdRegisterMdAuthenResponse);

	C_cmdRegisterMdAuthenResult( cmdMdAuthenResult);
	//0x00010059	
	C_cmdRegisterMdExit( MdExit_cb );

	C_videoRegisterDataReceive(videoDataReceive);
//	C_videoRegisterHeartBeat(videoHeartBeat);

	C_mediaRegisterInit(mediaInit);
	C_mediaRegisterNormalData(mediaNormalData);
//	C_mediaRegisterStop(mediaStop);//carlife drop 
	C_mediaRegisterPause(mediaPause);
	C_mediaRegisterResume(mediaResume);
//	C_mediaRegisterSeek(mediaSeek);  //carlife drop

	C_ttsRegisterInit(naviInit);
	C_ttsRegisterNormalData(naviNormalData);
	C_ttsRegisterStop(naviStop);

	C_vrRegisterInit(vrInit);
	C_vrRegisterNormalData(vrNormalData);
	C_vrRegisterStop(vrStop);
	/////bt////
	C_cmdRegisterStartBtAutoPairRequest( btAutoPairRequest);	
 	C_cmdRegisterFeatureConfigRequest( featureConfigRequest);
	C_cmdRegisterBTIdentifyResultInd( btIdentifyResultInd);
	C_cmdRegisterBtHfpRequest( BtHfpRequest_cb);

}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_carlife_init
 *  Description:
 * =====================================================================================
 */
static void mh_dev_carlife_init( MHDevCarlife * self )
{
	g_message("\n\n\n\nmh_dev_carlife_init--->%p\n\n\n\n", self);
	MHDevCarlifePrivate * _priv	=	mh_dev_carlife_get_instance_private( self );
	MHDev * _dev	=	MH_DEV( self );
	GError *_error = NULL;
	g_message("%s self = %p",__func__,self);
	_dev->type	=	"carlife";
	_dev->serial	=	NULL;
	self->cmd_thread	=	0;
	self->video_thread	=	0;
	self->media_thread	=	0;
	self->tts_thread	=	0;
	self->vr_thread		=	0;
	self->exist	=	false;
	self->width	=	0;
	self->height 	=	0;
	self->frameRate 	=	0;
	self->versionFlag	=	false;
	self->launch_mode	=	CARLIFE_LAUNCH_NULL;
	self->video_sink_name	=	NULL;
	self->audio_sink_name	=	NULL;
	self->surfaceid	=	0;
	self->md_bt_address	=	NULL;
	self->md_bt_passKey	=	NULL;
	self->md_os	=	NULL;
	self->buf	=	NULL;
	self->bufSize	=	0;
	self->bufLoc	=	0;
	self->status	=	CARLIFE_ROLE_SWITCH;
	self->detachFlag	=	false;
	self->MSlistener	=	g_new0( ModuleStatusListener, 1);

///////////////////init audio ////////////
	self->audio_param	=	(audioParam_t *)g_new0( audioParam_t, 1);

	self->audio_param->pipeline	=	gst_element_factory_make("playbin", "media");
	g_object_set( self->audio_param->pipeline, "uri", "appsrc://", NULL);
	g_signal_connect( self->audio_param->pipeline, "source-setup", G_CALLBACK(audio_setupSrc), self);

	self->audio_param->context	=	g_main_context_new();

	g_message("%s--->self->audio_param->context:%p", __func__, self->audio_param->context);
	self->audio_param->mainloop	=	g_main_loop_new( self->audio_param->context, FALSE);
//	g_thread_unref(g_thread_new("media_output", media_output, self));
	self->audio_param->thread 	=	g_thread_try_new("media_output", media_output, self, &_error);
	gst_element_set_state( self->audio_param->pipeline, GST_STATE_READY);
	g_message("%s->gst_element_set_state(audio)->GST_STATE_READY", __func__);

////////////////////init video//////////////////////////
	self->video_param	=	(videoParam_t *)g_new0( videoParam_t, 1);

	self->video_param->pipeline	=	gst_element_factory_make("playbin", "video");
	g_object_set( self->video_param->pipeline, "uri", "appsrc://", NULL);
	g_signal_connect( self->video_param->pipeline, "source-setup", G_CALLBACK(video_setupSrc), self);

	self->video_param->context	=	g_main_context_new();
	g_message("%s--->self->video_param->context:%p", __func__, self->video_param->context);
	self->video_param->mainloop	=	g_main_loop_new( self->video_param->context, FALSE);

//	g_thread_unref(g_thread_new("video_output", video_output, self));
	self->video_param->thread 	=	g_thread_try_new("video_output", video_output, self, &_error);
	gst_element_set_state( self->video_param->pipeline, GST_STATE_READY);
	g_message("%s->gst_element_set_state(video)->GST_STATE_READY", __func__);

//////////////////////navi tts////////////////////////////
	self->navi_param	=	(naviParam_t*)g_new0( naviParam_t, 1);

	self->navi_param->pipeline	=	gst_element_factory_make("playbin", "navi");
	g_object_set( self->navi_param->pipeline, "uri", "appsrc://", NULL);
	g_signal_connect( self->navi_param->pipeline, "source-setup", G_CALLBACK( navi_setupSrc), self);
	self->navi_param->context	=	g_main_context_new();
	g_message("%s--->self->navi_param->context:%p", __func__, self->navi_param->context);
	self->navi_param->mainloop	=	g_main_loop_new( self->navi_param->context, FALSE);
//	g_thread_unref( g_thread_new("navi_output", navi_output, self));
	self->navi_param->thread 	=	g_thread_try_new("navi_output", navi_output, self, &_error);
	gst_element_set_state( self->navi_param->pipeline, GST_STATE_READY);
	g_message("%s->gst_element_set_state(navi)->GST_STATE_READY", __func__);

//////////////////////////////////VR tts/////////////////////////////////
	self->VRtts_param	=	(VRttsParam_t*)g_new0( VRttsParam_t, 1);

	self->VRtts_param->pipeline	=	gst_element_factory_make("playbin", "vrtts");
	
	g_object_set( self->VRtts_param->pipeline, "uri", "appsrc://", NULL);

	g_signal_connect( self->VRtts_param->pipeline, "source-setup", G_CALLBACK( vrtts_setupSrc), self);

	self->VRtts_param->context	=	g_main_context_new();
	g_message("%s--->self->VRtts_param->context:%p", __func__, self->VRtts_param->context);

	self->VRtts_param->mainloop	=	g_main_loop_new( self->VRtts_param->context, FALSE);

//	g_thread_unref( g_thread_new("vr_output", vrtts_output, self));
	self->VRtts_param->thread 	=	g_thread_try_new("vr_output", vrtts_output, self, &_error);
	gst_element_set_state( self->VRtts_param->pipeline, GST_STATE_READY);
	g_message("%s->gst_element_set_state(vrtts)->GST_STATE_READY", __func__);
	self->VRtts_param->state	=	GST_STATE_READY;

	/////////////////////VR mic///////////////////////////
	self->VRRecord_param	=	(VRRecordParam_t *)g_new0( VRRecordParam_t, 1);
	self->VRRecord_param->Mic_flag	=	1;

	self->VRRecord_param->context	=	g_main_context_new();
	g_message("%s--->self->VRRecord_param->context:%p", __func__, self->VRRecord_param->context);
	self->VRRecord_param->mainloop	=	g_main_loop_new( self->VRRecord_param->context, FALSE);
//

	self->VRRecord_param->thread 	=	g_thread_try_new("vr_record", vr_record, self, &_error);


	///pipeline thread

	self->pipe_param	=	(PipelineParam_t *)g_new0( PipelineParam_t, 1);
	self->pipe_param->context	=	g_main_context_new();
	self->pipe_param->mainloop	=	g_main_loop_new( self->pipe_param->context, FALSE);
	self->pipe_param->thread	=	g_thread_try_new("pipeline_thread", pipe_thread, self, &_error); 

}       /* -----  end of static function mh_dev_carlife_init  ----- */


	//0x00010049 
static gboolean register_status_listener( gpointer user_data)
{
	g_message("%s", __func__);
	gpointer * _user_data	=	(gpointer*)user_data;

	MHDev * _dev	=	(MHDev *)_user_data[0];
	MHDevStatusListener * _listener	=	(MHDevStatusListener *)_user_data[1];

	MHDevCarlife * _carlife	=	MH_DEV_CARLIFE( _dev);
	if( !g_strcmp0(_carlife->md_os, "ios"))
	{

		switch( _carlife->status)
		{
			case CARLIFE_ROLE_SWITCH:
				_listener->callback(_dev, CARLIFE_ROLE_SWITCH, _listener->user_data);
				break;
			case CARLIFE_IAP_AUTH:
				_listener->callback(_dev, CARLIFE_ROLE_SWITCH, _listener->user_data);
				_listener->callback(_dev, CARLIFE_IAP_AUTH, _listener->user_data);
				break;
			case CARLIFE_IAP_AUTH_SUCCESS:
				_listener->callback(_dev, CARLIFE_ROLE_SWITCH, _listener->user_data);
				_listener->callback(_dev, CARLIFE_IAP_AUTH, _listener->user_data);
				_listener->callback(_dev, CARLIFE_IAP_AUTH_SUCCESS, _listener->user_data);
				break;
			case CARLIFE_DEVICE_OPEN:
				_listener->callback(_dev, CARLIFE_ROLE_SWITCH, _listener->user_data);
				_listener->callback(_dev, CARLIFE_IAP_AUTH, _listener->user_data);
				_listener->callback(_dev, CARLIFE_IAP_AUTH_SUCCESS, _listener->user_data);
				_listener->callback(_dev, CARLIFE_DEVICE_OPEN, _listener->user_data);
				break;
			case CARLIFE_CONNECT_SUCCESS:
				_listener->callback(_dev, CARLIFE_ROLE_SWITCH, _listener->user_data);
				_listener->callback(_dev, CARLIFE_IAP_AUTH, _listener->user_data);
				_listener->callback(_dev, CARLIFE_IAP_AUTH_SUCCESS, _listener->user_data);
				_listener->callback(_dev, CARLIFE_DEVICE_OPEN, _listener->user_data);
				_listener->callback(_dev, CARLIFE_CONNECT_SUCCESS, _listener->user_data);
				break;
		}
	}
	g_signal_connect( _dev, "dev_status", G_CALLBACK( _listener->callback), _listener->user_data);

	g_free( _listener);
	
	g_free( _user_data);

	return FALSE;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_status_listener
 *  Description:  
 * =====================================================================================
 */
static void _register_status_listener(MHDev * self, MHDevStatusListener * listener )
{
	g_message("%s", __func__);
	GSource * _source	=	g_idle_source_new();

	gpointer * user_data	=	g_malloc0(sizeof(gpointer)*2);
	MHDevStatusListener * _listener	=	g_new0( MHDevStatusListener, 1);
	_listener->callback	=	listener->callback;
	_listener->user_data	=	listener->user_data;

	user_data[0]	=	(gpointer)self;
	user_data[1]	=	(gpointer)_listener;
	g_source_set_callback( _source, register_status_listener, user_data, NULL);

	mh_io_dispatch(MH_IO( _carlife), _source);

	g_source_unref( _source);

}		/* -----  end of static function _register_status_listener  ----- */
static gboolean register_detach_listener( gpointer user_data)
{
	g_message("%s--->in", __func__);
	gpointer * _user_data	=	(gpointer*)user_data;

	MHDev * _dev	=	(MHDev *)_user_data[0];
	MHDevDetachListener * _listener	=	(MHDevDetachListener *)_user_data[1];
	MHDevCarlife * _carlife	=	(MHDevCarlife *)_dev;
	if( _carlife->detachFlag	==	true)
	{
		_listener->callback( _dev, _listener->user_data);
	}
	else
	{
		g_signal_connect(_dev,"dev_detach",G_CALLBACK(_listener->callback),_listener->user_data);	
	}
	g_message("%s--->out", __func__);
	return G_SOURCE_REMOVE;

}
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_detach_listener
 *  Description:  
 * =====================================================================================
 */
static uint32_t  _register_detach_listener(MHDev * self,MHDevDetachListener * listener )
{
	g_message("%s--->in", __func__);
	MHDevCarlife * _carlife	=	(MHDevCarlife *)self;
	if( _carlife->detachFlag	==	true)
	{
		g_message("%s----->call call back of detach", __func__);
		listener->callback( self, listener->user_data);
	}
	else
	{
		g_message("%s--->g_signal_connect", __func__);
		g_signal_connect(self,"dev_detach",G_CALLBACK(listener->callback),listener->user_data);	
	}
	g_message("%s--->out", __func__);

//	g_message("%s--->in", __func__);
//	GSource * _source	=	g_idle_source_new();
//	
//	gpointer * user_data	=	g_malloc0( sizeof(gpointer)*2);
//
//	MHDevCarlife	* _carlife	=	(MHDevCarlife *)self;
//
//	user_data[0]	=	(gpointer)self;
//	user_data[1]	=	(gpointer)listener;
//
//	g_source_set_callback(_source, register_detach_listener, user_data, NULL);
//	guint _id	=	0;	
//	_id	=	g_source_attach( _source, _carlife->pipe_param->context);
//	g_message("%s--->g_source_attach return %d", __func__, _id);
//	g_source_unref( _source);
//
//	g_message("%s---->out", __func__);

	return 0;
}		/* -----  end of static function _register_detach_listener  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_carlife_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_dev_carlife_class_init( MHDevCarlifeClass * klass )
{
	MHDevClass * _parentClass	=	MH_DEV_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	_dispose;
	_gobjectClass->finalize	=	_finalize;
	_gobjectClass->set_property =   _set_property;
	_gobjectClass->get_property =   _get_property;
	_parentClass->send_signal_touch	=	 _send_signal_touch;
	_parentClass->start	=	_start;
	_parentClass->register_module_status	=	_register_module_status;
	_parentClass->register_status_listener	=   _register_status_listener;	
	_parentClass->register_detach_listener	=	_register_detach_listener;
//	_parentClass->start_scan	=	_start_scan;
	/* assemble ios of mh_dev_carlife class */

	/* assemble methods of mh_dev_carlife class */

	/* Properties of mh_dev_carlife class */

	devCarlifeProperties[PROP_DEV_CARLIFE_EXIST]	=	
		g_param_spec_uint("exist","MHDevCarlife property", "carlife exist or not",
				0, G_MAXUINT, 0, G_PARAM_READABLE);
	devCarlifeProperties[PROP_DEV_CARLIFE_WIDTH]	=	
		g_param_spec_uint("width","MHDevCarlife property", "width of carlife",
				0, G_MAXUINT, 0, G_PARAM_READWRITE);
	devCarlifeProperties[PROP_DEV_CARLIFE_HEIGHT]	=	
		g_param_spec_uint("height","MHDevCarlife property", "height of carlife",
				0, G_MAXUINT, 0, G_PARAM_READWRITE);
	devCarlifeProperties[PROP_DEV_CARLIFE_FRAMERATE]	=	
		g_param_spec_uint("framerate","MHDevCarlife property", "frameRate of carlife",
				0, G_MAXUINT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_MEDIA_CLIENT_NAME]	=	
		g_param_spec_string("carlife_media_client_name","MHDevCarlife property", "media client name",
				"", G_PARAM_READWRITE);
	devCarlifeProperties[PROP_DEV_CARLIFE_NAVI_CLIENT_NAME]	=	
		g_param_spec_string("carlife_navi_client_name","MHDevCarlife property", "navi client name",
				"", G_PARAM_READWRITE);
	devCarlifeProperties[PROP_DEV_CARLIFE_VRTTS_CLIENT_NAME]	=	
		g_param_spec_string("carlife_vrtts_client_name","MHDevCarlife property", "vr tts client name",
				"", G_PARAM_READWRITE);

	devCarlifeProperties[ PROP_DEV_CARLIFE_VIDEO_SINK ]	=	
		g_param_spec_string( "carlife_video_sink", "MHDevCarlife property", "video sink name",
				"", G_PARAM_READWRITE );

	devCarlifeProperties[ PROP_DEV_CARLIFE_AUDIO_SINK ]	=	
		g_param_spec_string( "carlife_audio_sink", "MHDevCarlife property", "audio sink name",
				"", G_PARAM_READWRITE );

	devCarlifeProperties[ PROP_DEV_CARLIFE_SINK_SURFACEID ]	=	
		g_param_spec_uint( "carlife_surfaceid", "MHDevCarlife property", "video sink  property StreamID",
				0, G_MAXUINT, 0, G_PARAM_WRITABLE );

	devCarlifeProperties[PROP_DEV_CARLIFE_VRRECORD_CLIENT_NAME]	=	
		g_param_spec_string("carlife_vrrecord_client_name","MHDevCarlife property", "vr record client name",
				"", G_PARAM_READWRITE);
	devCarlifeProperties[PROP_DEV_CARLIFE_MODULE_CONTROL]	=	
		g_param_spec_string("module_control","MHDevCarlife property", "module control",
				"", G_PARAM_READWRITE);
	devCarlifeProperties[PROP_DEV_CARLIFE_HARDKEY]	=	
		g_param_spec_uint("send_hardkey","MHDevCarlife property", "hardkey of carlife",
				0, G_MAXUINT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_VIDEO_STATUS]	=	
		g_param_spec_uint("video_status","MHDevCarlife property", "video status of carlife",
				0, G_MAXUINT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_CAR_VELOCITY]	=	
		g_param_spec_uint("car_velocity","MHDevCarlife property", "car velocity of carlife",
				0, G_MAXUINT, 0, G_PARAM_READWRITE);
	devCarlifeProperties[PROP_DEV_CARLIFE_CAR_GPS]	=	
		g_param_spec_variant("car_gps", "MHDevCarlife property", "car gps of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_CAR_GYROSCOPE]	=	
		g_param_spec_variant("car_gyroscope", "MHDevCarlife property", "car gyroscope of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_CAR_ACCELERATION]	=	
		g_param_spec_variant("car_acceleration", "MHDevCarlife property", "car acceleration of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_CAR_OIL]	=	
		g_param_spec_variant("car_oil", "MHDevCarlife property", "car oil of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_LAUNCH_MODE]	=	
		g_param_spec_uint("launch_mode", "MHDevCarlife property", "launch mode of carlife",
				0, G_MAXUINT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_CAR_INFO]	=	
		g_param_spec_variant("car_info", "MHDevCarlife property", "car info of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_BT_START_IDENTIFY_REQ] =	
		g_param_spec_variant("bt_start_identify", "MHDevCarlife property", "car bt address of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_HU_BT_PAIR_INFO] =	
		g_param_spec_variant("hu_bt_pair_info", "MHDevCarlife property", "car bt pair info of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_MD_BT_ADDRESS] =	
		g_param_spec_string("md_bt_address", "MHDevCarlife property", "md bt address of carlife",
				"", G_PARAM_READABLE);

	devCarlifeProperties[PROP_DEV_CARLIFE_MD_BT_PASSKEY] =	
		g_param_spec_string("md_bt_passkey", "MHDevCarlife property", "md bt passkey of carlife",
				"", G_PARAM_READABLE);

	devCarlifeProperties[PROP_DEV_CARLIFE_BT_HFP_INDICATION] =	
		g_param_spec_variant("bt_hfp_indication", "MHDevCarlife property", "bt hfp indication of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_BT_HFP_CONNECTION] =	
		g_param_spec_variant("bt_hfp_connection", "MHDevCarlife property", "bt hfp connection of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_BT_HFP_RESPONSE] =	
		g_param_spec_variant("bt_hfp_response", "MHDevCarlife property", "bt hfp response of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

	devCarlifeProperties[PROP_DEV_CARLIFE_BT_HFP_RESPONSE] =	
		g_param_spec_variant("bt_hfp_response", "MHDevCarlife property", "bt hfp response of carlife",
				G_VARIANT_TYPE_VARIANT, 0, G_PARAM_READWRITE);

		devCarlifeProperties[PROP_DEV_CARLIFE_MD_OS] =	
		g_param_spec_string("md_os", "MHDevCarlife property", "md os of carlife",
				"", G_PARAM_READABLE);


	signals[ SIGNAL_DEV_CARLIFE_BT_HFP_REQUEST]	=	
		g_signal_new("carlife_bt_hfp_request",
				G_TYPE_FROM_CLASS(klass),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				3,
				G_TYPE_UINT, G_TYPE_STRING, G_TYPE_INT);
	g_object_class_install_properties( _gobjectClass, N_PROPERTIES, devCarlifeProperties );

	/* Ios */

	/* Signals */



}       /* -----  end of static function mh_dev_carlife_class_init  ----- */

