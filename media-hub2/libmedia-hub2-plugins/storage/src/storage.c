/*
 * Generated by object-codegen.
 */
#include <stdio.h>
#include <glib.h>
#include <mh_core.h>

#include <sys/poll.h>
#include <libudev.h>
#include <sys/mount.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <blkid/blkid.h>
#include "dev_storage.h"
#include <ctype.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/types.h>  
#include <sys/socket.h>  
#include <sys/un.h> 
#include <netinet/in.h>
static struct udev * udevCtx;
static GPollFD udevFd;
static struct udev_monitor * udevMonitor;
static char * partition_name = NULL; 
//typedef struct _StorageInfo 
//{
//	uint32_t partition_count;
//	MHDevStorage * storage;
//} StorageInfo;				/* ----------  end of struct StorageInfo  ---------- */
//
GList * storage_list;
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  check_storage_by_devname
 *  Description:  
 * =====================================================================================
 */
static MHDevStorage * check_storage_by_devname( const char * devname)
{
	g_message("%s---->devname:%s", __func__, devname);
	GList * _list	=	g_list_first( storage_list );
	MHDevStorage * _res	=	NULL;
	MHDevStorage * _storage;
	while( _list != NULL)
	{
		_storage	=	(MHDevStorage *)(_list->data);

		if(g_strcmp0(_storage->dev_path, devname) == 0)
		{
			_res	=	_storage;
			break;
		}
		else
		{
			_list	=	g_list_next( _list );
		}
	}

	return _res;
}		/* -----  end of static function check_storage  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  check_storage
 *  Description:  
 * =====================================================================================
 */
static MHDevStorage * check_storage( const char * serial)
{
	GList * _list	=	g_list_first( storage_list );
	MHDevStorage * _res	=	NULL;
	MHDevStorage * _storage;
	MHDev * _dev;
	while( _list != NULL)
	{
		_storage	=	(MHDevStorage *)(_list->data);

		 _dev	=	MH_DEV(_storage);
		if(g_strcmp0(_dev->serial, serial) == 0)
		{
			_res	=	_storage;
			break;
		}
		else
		{
			_list	=	g_list_next( _list );
		}
	}

	return _res;
}		/* -----  end of static function check_storage  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _is_emmc
 *  Description:  
 * =====================================================================================
 */
static gboolean  _is_emmc( struct udev_list_entry * properties)
{
	g_message("%s", __func__);
	struct udev_list_entry * _model;
	const char * _value;
	gboolean _res	=	FALSE;
//	_model	=	udev_list_entry_get_by_name( properties, "ID_NAME");
//	_value	=	udev_list_entry_get_value( _model );
//
//	g_message("%s-->ID_NAME:%s", __func__, _value);
//	if( _value && g_str_has_prefix( _value, "MMC") )
//	{
		_model	=	udev_list_entry_get_by_name( properties, "ID_FS_USAGE");
		_value	=	udev_list_entry_get_value( _model);
		if( _value && g_strcmp0( _value,"filesystem") ==0)
		{
			_res	=	TRUE;
		}
//	}
	return _res;

}		/* -----  end of static function _is_emmc  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _is_storage
 *  Description:  
 * =====================================================================================
 */
static MHDevStorage * _is_storage( struct udev_list_entry * properties)
{
	struct udev_list_entry  * _model;
	char * _path = NULL, *_path_tmp1, *_path_tmp2, *_sys_path = NULL;
	_model	=	udev_list_entry_get_by_name( properties, "ID_BUS" );
	const char * _value 	=	udev_list_entry_get_value( _model );
	const char * _serial;
	const char * vendorId, * productId;

	if( g_strcmp0( _value, "usb" ) != 0 )
	{
		return NULL;
	}	

	_model	=	udev_list_entry_get_by_name( properties, "SUBSYSTEM" );
	_value 	=	udev_list_entry_get_value( _model );
	if( g_strcmp0( _value, "block" ) != 0 )
	{
		return NULL;
	}

	MHDevStorage * _storage, * _res;
	_model	=	udev_list_entry_get_by_name( properties, "ID_SERIAL_SHORT");
	if( _model == NULL)
	{
		if((_model	=	udev_list_entry_get_by_name( properties, "ID_SERIAL"))!= NULL)
		{
			_serial	=	udev_list_entry_get_value( _model );
		}
		else
		{
//			g_warning("no ID_SERIAL_SHORT and no ID_SERIAL");
			return NULL;
		}

	}
	else	
	{
		_serial	=	udev_list_entry_get_value( _model );
	}
	
	_model	=	udev_list_entry_get_by_name( properties, "ID_VENDOR_ID" );
	vendorId	=	udev_list_entry_get_value( _model );
	
	_model	=	udev_list_entry_get_by_name( properties, "ID_MODEL_ID" );
	productId	=	udev_list_entry_get_value( _model );
	
	_storage	=	check_storage( _serial );
	if( _storage == NULL)
	{
		const gchar * _tmp	=	getenv( "MH_MOUNT_POINT" );
		_res = g_object_new( MH_TYPE_DEV_STORAGE, "io-name", "storage", NULL );
		MH_DEV(_res)->type	=	g_strdup("storage");
		MH_DEV( _res)->serial	=	g_strdup( _serial );
		MH_DEV( _res)->vid	=	g_strdup( vendorId );
		MH_DEV( _res)->pid	=	g_strdup( productId );
		MH_DEV( _res)->entry	=	g_strdup_printf( "%s/%s", _tmp ? _tmp : g_get_tmp_dir(), _serial );
		if( (_model = udev_list_entry_get_by_name(properties, "DEVPATH")) != NULL)
		{
			_path	=	g_strdup( udev_list_entry_get_value( _model ) );
			_sys_path	=	g_strdup_printf("/sys%s",_path);
			MH_DEV( _res)->devPath	=	g_strdup( _path );
		}
		
		g_message("vendorId = %s productId = %s devPath = %s", MH_DEV( _res)->vid, MH_DEV( _res)->pid, MH_DEV( _res)->devPath);

		_path_tmp2	=	_path;	
		if((_path_tmp1 = g_strrstr( _path_tmp2,"host")) != NULL)
		{
			*(_path_tmp1 -1)='\0';
			if( _path_tmp1	=	g_strrstr( _path_tmp2, "/"))
			{	
				_res->bus	=	g_strdup( _path_tmp1 + 1);

			}
		}


		free( _path);

		storage_list = g_list_prepend( storage_list, (gpointer)_res);
		if( mkdir( MH_DEV(_res)->entry, 0666) != 0)
		{
			g_warning("%s", strerror( errno));
		}

	}
	else
	{
		_res	=	_storage;
	}

	_model	=	udev_list_entry_get_by_name( properties, "DEVTYPE");
	_value	=	udev_list_entry_get_value( _model );

	if( _model == 	NULL )
	{
		return NULL;
	}
	else if(g_strcmp0( _value, "partition") !=0 || _storage == 	NULL)
	{// fast plugin in and out the udev return value may be wrong, if serial is wrong, _storage is NULL
		DIR * _dir;
		struct dirent * _dirent;
		int _len;
		char * _name;
		const gchar * _major, * _minor;

		if (_sys_path == NULL)
		{
			g_message("MH_DEV( _res)->devPath == NULL");
			return NULL;
		}
		if( _res->dev_path == NULL)
		{
			_model	=	udev_list_entry_get_by_name( properties, "DEVNAME");
			_value	=	udev_list_entry_get_value( _model );
			_res->dev_path	=	g_strdup( _value );

		}
		_name	=	g_strdup( strrchr( _value, '/') + 1);
		
		_model	=	udev_list_entry_get_by_name( properties, "MAJOR" );
		_major	=	udev_list_entry_get_value( _model );

		_model	=	udev_list_entry_get_by_name( properties, "MINOR" );
		_minor	=	udev_list_entry_get_value( _model );

		if( _dir = opendir( _sys_path))
		{
			_len	=	strlen( _name );
			
			while( (_dirent = readdir( _dir ))!= NULL)
			{
				if( strlen( _dirent->d_name ) <= _len)
				{
					continue;
				}
				else
				{
					if( strncmp( _name, _dirent->d_name, _len)==0 
							&& ((*(_dirent->d_name + _len)=='p' && isdigit( *(_dirent->d_name + _len +1)))
								||isdigit(*(_dirent->d_name +  _len))))
					{
							_res->partition_count++;		
					}
				}
			}
			g_message("\npartition_count:%d\n", _res->partition_count);
			if( _res->partition_count == 0)
			{
				_res->partitionFlag	= false;
			}
			closedir( _dir);

		}
		g_free(_name);
		g_free( _sys_path);
		
		_model	=	udev_list_entry_get_by_name( properties, "ID_FS_USAGE" );
		_value	=	udev_list_entry_get_value( _model );
		
		if( _model != NULL && g_strcmp0( _value,"filesystem") ==0 && _res->partition_count == 0)
		{//if there is no partition and sda can mount ,so mount sda
			_res->partition_count ++;
		}
		else	
		{	// sda can't mount return NULL
			_res	=	NULL;

		}
		

	}
	else
	{
		if( _res->partitionFlag == false)
		{
			_res->partition_count ++;
		}
	}
	return _res;
//	_model	=	udev_list_entry_get_by_name( properties, "ID_FS_USAGE" );
//	_value	=	udev_list_entry_get_value( _model );
////	g_message("%d->ID_FS_USAGE:%s", __LINE__, _value);
//
//	if( _model == NULL || g_strcmp0( _value, "filesystem" ) != 0 ||ã€€)
//	{
//		_model	=	udev_list_entry_get_by_name( properties, "DEVTYPE");
//		_value	=	udev_list_entry_get_value( _model );
////		g_message("%d->DEVTYPE:%s", __LINE__, _value);
//		if(_model == NULL || g_strcmp0(_value,"partition") != 0 )
//		{//like sda can get partition count
//		
//			blkid_probe _pr	=	NULL;
//			blkid_partlist _pl = NULL;
//
//			_model	=	udev_list_entry_get_by_name( properties, "DEVNAME");
//			_value	=	udev_list_entry_get_value( _model );
//			_storage->devPath	=	g_strdup( _value );
//			_pr	=	blkid_new_probe_from_filename( _value );	
//			if( _pr != NULL)
//			{
//				_pl	=	blkid_probe_get_partitions( _pr);
//			}
//			else
//			{
//				g_message("_pr == NULL");
//			}
//			if( _pl != NULL )
//			{
//				_storage->partition_count	=	blkid_partlist_numof_partitions( _pl );	
//				g_message("%d:partition_count:%d", __LINE__, _storage->partition_count);
//			}
//			else
//			{
//				g_message("_pl == NULL");
//
//			}
//			blkid_free_probe( _pr );
//		}
//		else
//		{//is partition but can't mount
//			_storage->partition_count --;	
////			_storage->umount_count --;
//			g_message("%d:partition_count:%d", __LINE__, _storage->partition_count);
//
//		}
//		return NULL;
//	}
//
//	_model	=	udev_list_entry_get_by_name( properties, "DEVTYPE");
//	_value	=	udev_list_entry_get_value( _model);
//	if(_model == NULL || g_strcmp0(_value,"partition") != 0 )
//	{//is usb, filesystem and not partition 
//		_model	=	udev_list_entry_get_by_name( properties, "DEVNAME");
//		_value	=	udev_list_entry_get_value( _model );
//
//		_storage->devPath = g_strdup(_value );
//	}
//	return _storage;
}		/* -----  end of static function _is_storage  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _mount_emmc
 *  Description:  
 * =====================================================================================
 */
static MHDevStorage * _mount_emmc(  struct udev_list_entry * properties )
{
	MHDevStorage * _res	=	NULL;
	struct udev_list_entry * _model;
	const gchar * _major, * _minor, * _devNode, * _serial, *_fsType, * entryNum, *_devPath;
	gchar * _entryNum;
	dev_t	_devId;
	gchar * _mountPath;
	const gchar * _mountPoint;
	gboolean _mountFlag	=	FALSE;
	struct stat _state;
//	const gchar * _data	=	"iocharset=utf8";

	_model	=	udev_list_entry_get_by_name( properties, "MAJOR");
	_major	=	udev_list_entry_get_value( _model);

	_model	=	udev_list_entry_get_by_name( properties, "MINOR");
	_minor	=	udev_list_entry_get_value( _model );

	_devId  =   makedev( atoi( _major ), atoi( _minor ));

	_model	=	udev_list_entry_get_by_name( properties, "DEVNAME" );
	_devNode	=	udev_list_entry_get_value( _model );

	_model	=	udev_list_entry_get_by_name( properties, "ID_SERIAL" );
	_serial	=	udev_list_entry_get_value( _model);

	_model	=	udev_list_entry_get_by_name( properties, "ID_PART_ENTRY_NUMBER");
	entryNum	=	udev_list_entry_get_value( _model);

	if( entryNum == NULL)
	{
		_entryNum	=	g_strdup("0");

	}
	else
	{
		_entryNum	=	g_strdup( entryNum);
	}

	_model	=	udev_list_entry_get_by_name( properties, "ID_FS_TYPE");
	_fsType	=	udev_list_entry_get_value( _model );

	_model = udev_list_entry_get_by_name(properties, "DEVPATH");
	_devPath=	udev_list_entry_get_value( _model );

	_mountPoint	=	getenv( "MH_MOUNT_POINT" );
	_mountPath	=	g_strdup_printf("%s/%s-%s", _mountPoint ? _mountPoint : g_get_tmp_dir(), _serial, _entryNum ? _entryNum : "0");
	g_message("_mountPath:%s", _mountPath);	
	if( stat( _mountPath, &_state ) != 0)
	{
		switch( errno )
		{
			case ENOENT:
				if( mkdir( _mountPath, 0666) != 0)
				{
					g_warning("%s", strerror( errno ));
				}
				break;
			default:
				g_warning("%s", strerror( errno ));
				break;
		}
	}
	else if( _devId == _state.st_dev )
	{
		_mountFlag	=	TRUE;
	}
	if( _mountFlag == FALSE )
	{
		if( mount( _devNode, _mountPath, _fsType, 0 , NULL) != 0 )
		{
			g_warning( "Can't mount this device [ %s ]->_fsType:%s->_mountPath:%s", _devNode,_fsType, _mountPath );
			g_warning( "%d,%s", errno,strerror( errno ));

		}
		else
		{	
			g_message("mount this device [%s]->_fsType:%s->_mountPath:%s",_devNode, _fsType, _mountPath);
			_mountFlag	=	TRUE;
		}
		
	}
	if( _mountFlag == TRUE)
	{
		_res	=	g_object_new( MH_TYPE_DEV_STORAGE, "io-name", "storage", NULL);
		MH_DEV(_res)->type	=	g_strdup("emmc");
		MH_DEV(_res)->serial	=	g_strdup_printf("%s-%s", _serial, _entryNum);
		MH_DEV(_res)->entry	=	g_strdup( _mountPath);
		_res->entry_number	=	atoi(_entryNum);
		MH_DEV(_res)->devPath = g_strdup( _devPath);
		g_message("_mount_emmc _res->entry_number:%d", _res->entry_number);
	}

	g_free( _entryNum);
	return _res;

	
}		/* -----  end of static function _mount_emmc  ----- */

static int _mount(const gchar * devNode, gchar* mountPath, const gchar * type, unsigned long mountState, gchar* data )
{
	int result = 0;
	g_message("%s ===> mountState = %lu data = %s",__func__,mountState, data);
	if( mount( devNode, mountPath, type, mountState, data ) != 0 )
	{
		g_warning( "Can't mount this device [ %s ]:%s", devNode, mountPath );
		
		g_message("EROFS = %d, EACCES= %d", EROFS, EACCES);
		if ((errno == EROFS)||(errno == EACCES))
		{
			g_message("%s ===>mount readonly",__func__);
			if ( mount( devNode, mountPath, type, MS_RDONLY , data ) != 0 )
			{
				g_warning( "Can't mount this device [ %s ]:%s", devNode, mountPath );
				g_warning( "%d,%s", errno,strerror( errno ));
			}
			else
			{
				result = 1;
			}
		}
		
		g_warning( "%d,%s", errno,strerror( errno ));
	}
	else
	{	
		result = 1;
	}
	return result; 
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _mount_storage
 *  Description:  
 * =====================================================================================
 */
static MHDevStorage * _mount_storage(MHDevStorage * storage,  struct udev_list_entry * properties )
{
	MHDevStorage * _ret	=	NULL;
	struct udev_list_entry * _model;
	const gchar * _devNode, * _serial, * _type;
	char *_label=NULL;
	const gchar * _partitionNum	=	NULL;
	const gchar * _major, * _minor;
	//const gchar * _data	=	"iocharset=utf8";
	gchar _data[]	=	"iocharset=utf8";

	gchar * _mount_path =	NULL;
	pid_t _pid;
	int _status, _retStat;
	struct stat _state;
	dev_t _devId;
	gboolean _mounted	=	FALSE;
	MHDev * _dev	=	MH_DEV( storage);
	devPartInfo * _parInfo;
	unsigned long _mount_state = 0;

	_model	=	udev_list_entry_get_by_name( properties, "MAJOR" );
	_major	=	udev_list_entry_get_value( _model );

	_model	=	udev_list_entry_get_by_name( properties, "MINOR" );
	_minor	=	udev_list_entry_get_value( _model );

	_devId	=	makedev( atoi( _major ), atoi( _minor ));

	_model	=	udev_list_entry_get_by_name( properties, "DEVNAME" );
	_devNode	=	udev_list_entry_get_value( _model );

//some usb don't have ID_PART_ENTRY_NUMBER so not use ID_PART_ENTRY_NUMBER
//	if( storage->devPath == NULL)
//	{
//		_model	=	udev_list_entry_get_by_name( properties, "ID_SERIAL_SHORT");
//		_serial	=	udev_list_entry_get_value( _model );
//		g_message("--------------->%d->serial:%s", __LINE__, _serial);
//		_storage	=	check_storage( _serial);
//		if( _storage != NULL)
//		{
//			g_object_unref( storage);
//			storage	=	_storage;
//		}
//		else
//		{
//
//		}
//		
//	}

	const char * _p	=	_devNode + strlen( storage->dev_path);
	if( isdigit(*_p))
	{
		_partitionNum	=	_p;
		g_message("_partitionNum:%s", _partitionNum);
	}
	if( storage->partition_count != 0)
	{

		if( partition_name == NULL)
		{
			const char * _str	=	getenv("MH_DEV_PARTITION_NAME");
			partition_name = g_strdup( _str ? _str : "volume");

		}
	
		blkid_cache _cache;
		gchar * _str;
		blkid_get_cache( &_cache, "/dev/null" );
		_str = blkid_get_tag_value(_cache, "LABEL", _devNode); 
		blkid_put_cache(_cache); 
		if (NULL != _str)
		{
			_label  =   g_convert(_str, -1, "UTF-8", "GB2312", NULL, NULL, NULL);
			g_message("%s _label = %s",__func__,_label);
			if( NULL == _label)
			{
				_label  =   g_strdup( _str);
				g_message("%s _label = %s",__func__,_label);
			}

			g_free( _str );
		}
		if( _label != NULL)
		{
			if (g_utf8_validate(_label, -1, NULL))
			{
				_mount_path =   g_strdup_printf("%s/%s%s", _dev->entry, _label , _partitionNum ? _partitionNum : "1" );
			}
			else{
				_mount_path =   g_strdup_printf("%s/%s%s", _dev->entry, partition_name, _partitionNum ? _partitionNum : "1" );
			}
			g_free( _label);
		}
		else
		{
			_mount_path	=	g_strdup_printf("%s/%s%s", _dev->entry, _label ? _label : partition_name, _partitionNum ? _partitionNum : "1" );
		}
		
		
	}
	else
	{
		_mount_path	=	g_strdup(_dev->entry);
	}

	_model	=	udev_list_entry_get_by_name( properties, "ID_FS_TYPE" );

	if( _model != NULL )
		_type	=	udev_list_entry_get_value( _model );
	else
	{
		g_warning( "Can't detect the filesystem type of this device: [ %s ]", _devNode );
		_type	=	g_strdup("vfat");
	}
//	g_message("mount_path:%s", _mount_path);
	/* 0 means directory exists */
	if( stat( _mount_path, &_state ) != 0 )
	{
		switch( errno )
		{
		case ENOENT:
		{
			if( mkdir( _mount_path, 0666) != 0)
			{
				g_warning("%s", strerror( errno));
			}
		}
			break;
		default:
			g_warning( "%s", strerror( errno ));
			break;
		}
	}
	else
	{
		if( _devId == _state.st_dev )
		{
			_mounted	=	TRUE;
		}
	}

	if( !_mounted )
	{
		g_message("%s ===> _type = %s",__func__,_type);
		if (g_strcmp0( _type, "ntfs" ) == 0)
		{
			const char * _ntfs_state = getenv("MH_DEV_NTFS_STATE");
			_ntfs_state = _ntfs_state ? _ntfs_state : "0" ;
			guint _ntfs_state_int = (guint)atoi(_ntfs_state);
			g_message("%s ===> _ntfs_state_int = %d",__func__,_ntfs_state_int);
			if (0 == _ntfs_state_int)
			{
				_mount_state = 0;
			}
			else
			{
				_mount_state = 1;
			}
			memset(_data, 0, sizeof(_data));
			strcpy(_data, "nls=utf8");
			if( _mount( _devNode, _mount_path, _type, _mount_state, _data ) != 0 )
			{
				_mounted	=	TRUE;
			}
		}
		else if (g_strcmp0( _type, "exfat" ) == 0)
		{
			const char * _exfat_type = getenv("MH_DEV_EXFAT_TYPE");
			_exfat_type = _exfat_type ? _exfat_type : "exfat" ;
			g_message("%s ===> _exfat_type = %s",__func__,_exfat_type);
			if( _mount( _devNode, _mount_path, _exfat_type, _mount_state, _data ) != 0 )
			{
				_mounted	=	TRUE;
			}
		}
		else
		{
			if( _mount( _devNode, _mount_path, _type, _mount_state, _data ) != 0 )
			{
				_mounted	=	TRUE;
			}
		}

	}
	if( _mounted )
	{
//		struct statfs _diskInfo;
//		guint64 _bsize;
//		guint64 _blocks;
//		guint64 _bfree;
//
//		statfs(_mount_path,&_diskInfo);

//		_bsize	=	(guint64)_diskInfo.f_bsize;
//		_blocks	=	(guint64)_diskInfo.f_blocks;
//		_bfree	=	(guint64)_diskInfo.f_bfree;
//		
//		storage->total	+=	_bsize * _blocks;
//		storage->free		+=	_bsize * _bfree;
		_parInfo	=	(devPartInfo *)g_malloc0( sizeof( devPartInfo ));
		_parInfo->mountPath	=	_mount_path;
		_parInfo->devNode	=	g_strdup(_devNode);
		storage->mountList	=	g_list_append( storage->mountList, _parInfo);
		storage->mount_count ++;
//		g_message("%d[%s]->mount_count:%d", __LINE__, _devNode, storage->mount_count);
		if( storage->fs_type == NULL)
		{
			storage->fs_type = g_strdup( _type );
		}

		_ret	=	storage;
	}
	else
	{
		storage->partition_count--;
//		g_message("%d:partition_count:%d", __LINE__, storage->partition_count);
	
	}
//	g_free( _mount_path );
	return _ret;
}		/* -----  end of static function _mount_storage  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _serial_compare
 *  Description:  
 * =====================================================================================
 */
static gint _serial_compare( gconstpointer a, gconstpointer b )
{
	return g_strcmp0( MH_DEV(a)->serial, b );
}		/* -----  end of static function _serial_compare  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _umount_storage
 *  Description:  
 * =====================================================================================
 */
static gboolean _umount_storage( const char * path )
{
	g_message("umount_path:%s",path);
	gboolean _ret	=	TRUE;
	pid_t _pid;
	int _status;
	int _retry	=	0;
	while( umount2( path, MNT_DETACH ) != 0 )
	{
		_retry	++;

		if( _retry == 2 )
		{
			_ret	=	FALSE;
			break;
		}

		g_warning( "umount failed: still trying ... " );
		sleep( 1 );
	}
//	if( umount2( MH_DEV( storage )->entry, MNT_DETACH ) != 0 )
//	{
//		perror( "umount2" );
//		g_assert( 0 );
//	}
//	else
//	{
//		_ret	=	TRUE;
//	}
//	_pid	=	fork();
//
//	if( _pid == 0 )
//	{
//		execlp( "umount", "umount", "-l", MH_DEV( storage )->entry, NULL );
//
//		/* execlp returns only if an error occurs */
//		exit( 1 );
//	}
//	else
//	{
//		waitpid( _pid, &_status, 0 );
//
//		if( !WEXITSTATUS( _status ) )
//		{
//			_ret	=	TRUE;
//		}
//		else
//		{
//			raise( SIGTRAP );
//		}
//	}
	return _ret;
}		/* -----  end of static function _umount_storage  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _parse_events
 *  Description:  
 * =====================================================================================
 */
static gboolean _parse_events( gpointer user_data )
{
	struct udev_device * _udevDev;
	struct udev_list_entry * _properties, * _model;
	MHDevStorage * _storage;
	gchar * _umount_path	=	NULL;
	const gchar  *_partition, * _serial, * _label, *_devNode;

	_udevDev	=	udev_monitor_receive_device( udevMonitor );
	if( _udevDev )
	{
		const gchar * _udevAction;

		_udevAction	=	udev_device_get_action( _udevDev );

		_properties	=	udev_device_get_properties_list_entry( _udevDev );

			
		if( g_strcmp0( _udevAction, "add" ) == 0 )
		{
			g_message("usb add");
			_model	=	udev_list_entry_get_by_name( _properties, "DEVNAME" );
			_devNode	=	udev_list_entry_get_value( _model );
			_model	=	udev_list_entry_get_by_name( _properties, "ID_SERIAL_SHORT");
			if( _model != NULL)
			{
		
				_serial	=	udev_list_entry_get_value( _model );
				
			}
			else if( (_model	= udev_list_entry_get_by_name( _properties,"ID_SERIAL")) != NULL)
			{
				_serial	=	udev_list_entry_get_value( _model);
			}
			else
			{
				g_warning("no ID_SERIAL_SHORT and no ID_SERIAL");

				udev_device_unref( _udevDev );

				return G_SOURCE_CONTINUE;
			}
			MHDevStorage * _dev;
			_dev	=	MH_DEV_STORAGE(mh_core_find_dev_custom( _serial, _serial_compare) );

			if( _dev != NULL)
			{
				udev_device_unref( _udevDev );

				return G_SOURCE_CONTINUE;
			}

			_storage	=	_is_storage( _properties);		

			if( _storage != NULL)
			{
				_mount_storage( _storage, _properties );
				if( _storage->partition_count == 0 )
				{
					if( _storage->mount_count == 1)
					{
						mh_core_attach_dev( MH_DEV( _storage));
						_storage->attachFlag = true;
					}
					else
					{
						g_message("_storage->partition_count:%d, _storage->mount_count:%d",_storage->partition_count, _storage->mount_count );
					}
				}
				else if( _storage->partition_count ==	_storage->mount_count )
				{
					mh_core_attach_dev( MH_DEV( _storage));
					_storage->attachFlag = true;
				}

			}
		
		}
		else if( g_strcmp0( _udevAction, "remove" ) == 0 )
		{
			g_message("usb remove");
			_model	=	udev_list_entry_get_by_name( _properties, "DEVNAME" );
			_devNode	=	udev_list_entry_get_value( _model );
			if( _model == NULL || _devNode == 	NULL)
			{
				udev_device_unref( _udevDev );
				return G_SOURCE_CONTINUE;
			}

			_model	=	udev_list_entry_get_by_name( _properties, "ID_SERIAL_SHORT");
			if( _model != NULL)
			{
			_serial	=	udev_list_entry_get_value( _model);
				_storage	=	check_storage( _serial );
				
			}
			else 
			{
				_model	=	udev_list_entry_get_by_name( _properties, "ID_SERIAL");
				if( _model	!= NULL)
				{
					_serial = udev_list_entry_get_value( _model );
					_storage	=	check_storage( _serial );

				}
				else
				{
					_storage	=	check_storage_by_devname( _devNode);

				}
			}
					
			
			if(  _storage != NULL)
			{
				_model	=	udev_list_entry_get_by_name( _properties, "DEVNAME" );
				_devNode	=	udev_list_entry_get_value( _model );
				GList * _list;
				devPartInfo * _parInfo;
				if(_storage->attachFlag == true && _storage->detachFlag == false)
				{

					MH_DEV( _storage)->dev_status	=	false;
					mh_core_detach_dev( MH_DEV( _storage));
					_storage->detachFlag = true;

				}
				else
				{
//					g_message("%p->attachFlag=%d && %p->detachFlag = %d", _storage, _storage->attachFlag, _storage, _storage->detachFlag);
				}
				_list	=	g_list_first( _storage->mountList );

				while( _list != NULL)
				{
					_parInfo	=	(devPartInfo *)(_list->data);
					if( g_strcmp0( _parInfo->devNode, _devNode) == 0)
					{
						_umount_path	=	_parInfo->mountPath;
						break;
					}
					else
					{
						_list	=	_list->next;
					}
				}

				if( _umount_path!= NULL )
				{
					_umount_storage( _umount_path );

					/* we don't think rmdir failed is an error */
					if( rmdir( _umount_path ) != 0 )
					{
						g_warning( "rmdir %s failed: %s",_umount_path, strerror( errno ) );
					}
				}
				if( g_strcmp0( _storage->dev_path,_devNode)==0  )
				{
					if( rmdir( MH_DEV(_storage)->entry ) != 0 )
					{
						g_warning( "rmdir %s failed: %s",MH_DEV(_storage)->entry, strerror( errno ) );
					}
					storage_list	=	g_list_remove( storage_list, _storage);

					g_object_unref( _storage);

				}
				else
				{
//					g_message("%d:_storage->dev_path=%s, _devNode:%s", __LINE__, _storage->dev_path, _devNode);
				}
			}
			else
			{
				g_message("_storage == NULL");
			}
		}
		else
		{
			g_warning( "Unknown udev action( %s ) received", _udevAction );
		}
		udev_device_unref( _udevDev );
	}

	return G_SOURCE_CONTINUE;
}		/* -----  end of static function _parse_events  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _prepare
 *  Description:  
 * =====================================================================================
 */
static gboolean _prepare( GSource * source, gint * timeout )
{
	* timeout	=	-1;
	
	return FALSE;
}		/* -----  end of static function _prepare  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _check
 *  Description:  
 * =====================================================================================
 */
static gboolean _check( GSource * source )
{
	gboolean _ret	=	FALSE;

	if( udevFd.revents != 0 )
	{
		_ret	=	TRUE;
	}

	return _ret;
}		/* -----  end of static function _check  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispatch
 *  Description:  
 * =====================================================================================
 */
static gboolean _dispatch( GSource * source, GSourceFunc callback, gpointer user_data )
{
	return callback( user_data );
}		/* -----  end of static function _dispatch  ----- */

static GSourceFuncs _funcs	=	
{
	.prepare	=	_prepare,
	.check		=	_check,
	.dispatch	=	_dispatch
};


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _scan_storage
 *  Description:  
 * =====================================================================================
 */
static gboolean _scan_storage()
{

	struct udev_enumerate * _enum;
	struct udev_list_entry * _storage, * _entry, * _properties;
	struct udev_device * _udevDev;
	uint32_t _partition_count; 
	blkid_probe _pr;
	blkid_partlist _pl;
	GList * _partition_list;
	_enum	=	udev_enumerate_new( udevCtx );

	if( _enum == NULL )
	{
		g_warning( "udev_enumerate_new failed" );

		return FALSE;
	}

	/* NOTE: In the first stage, we only support the block storage in mh_storage */
//	udev_enumerate_add_match_subsystem( _enum, "usb" );
	udev_enumerate_add_match_subsystem( _enum, "block" );

	udev_enumerate_scan_devices( _enum );

	_storage	=	udev_enumerate_get_list_entry( _enum );

	udev_list_entry_foreach( _entry, _storage )
	{
		const gchar * _path	=	udev_list_entry_get_name( _entry );

		struct udev_list_entry * _model;
		struct udev_list_entry * _model2;

		_udevDev	=	udev_device_new_from_syspath( udevCtx, _path );

		_properties	=	udev_device_get_properties_list_entry( _udevDev );
		MHDevStorage * _storage	=	_is_storage( _properties);	
		if( _storage  != NULL )
		{
			_mount_storage(_storage , _properties ); 	

			if( _storage->partition_count == 0 )
			{
				if( _storage->mount_count == 1)
				{
					mh_core_attach_dev( MH_DEV( _storage));
					_storage->attachFlag = true;
				}
				else
				{
					g_message("_storage->partition_count:%d, _storage->mount_count:%d",_storage->partition_count, _storage->mount_count );
	
				}
			}
			else if( _storage->partition_count == _storage->mount_count )
			{
				mh_core_attach_dev( MH_DEV( _storage));

				_storage->attachFlag = true;

			}

		}
		else if(  getenv("MH_DEV_SUPPORT_EMMC") && _is_emmc( _properties ))
		{
			_storage 	=	_mount_emmc( _properties );
			if( _storage != NULL)
			{
				mh_core_attach_dev( MH_DEV( _storage));
			}
		}

		udev_device_unref( _udevDev );
	}

	udev_enumerate_unref( _enum );

	return TRUE;
}		/* -----  end of static function _scan_storage  ----- */
gpointer _listener( gpointer data)
{
	g_message("%s",__func__);
	unlink("device_socket");
	int _fd;

	struct sockaddr_un _addr;  

	char _data[1024];

	int _dataLen;

	int _clientFd;

	MHDevStorage *	_storage;

	char * _devData	=	NULL;

	char * _p	=	NULL;

	struct sockaddr_un	_clientAddr;	
	int _len;

	_fd	= socket(AF_UNIX, SOCK_STREAM, 0);


	if( _fd	> 0)
	{
		_addr.sun_family = AF_UNIX;  

		strcpy(_addr.sun_path, "/tmp/device_socket");  

		if(0 != bind(_fd, (struct sockaddr *)&_addr, sizeof(_addr)))
		{
			g_message("storage.c->%s->bind failed errno=%d", __func__, errno);

			return NULL;
		}

		if( -1 	==	listen( _fd, 5)	)
		{
			g_message("%s->listen error", __func__);
			
			return NULL;
		}
		
		g_signal_emit_by_name(mh_core_instance(), "core_events", MH_CORE_PLUGIN_LOAD_SUCCESS, "folder");

		while( (_clientFd	=	accept( _fd, (struct sockaddr*)&_clientAddr, &_len)) != -1)
		{
			g_message("\n\naccept --->recv\n\n");
			_dataLen	=	recv( _clientFd, _data, 1024, 0);	

			if( _dataLen > 0)
			{
				_storage	=	g_object_new( MH_TYPE_DEV_STORAGE, "io-name", "storage", NULL);

				_devData	=	g_strdup( _data );

				g_message("%s->%s", __func__, _devData);

				memset( _data, 0, sizeof( _data));

				_p	=	_devData;

				_p	=	g_strrstr( _devData, ";");

				if( _p	!= 	NULL);
				{
					MH_DEV(_storage)->entry	=	g_strdup( _p + 1);

					* _p =	'\0';

					_p	=	g_strrstr(_devData, ";");

					if( _p != 	NULL)
					{
						MH_DEV( _storage)->serial	=	g_strdup( _p + 1);

						*_p	=	'\0';
					}

					MH_DEV( _storage)->type	=	g_strdup( _devData);
				}

				g_message("entry:%s, serial:%s, type:%s", MH_DEV( _storage)->entry,
						MH_DEV(_storage)->serial, MH_DEV( _storage)->type);

				mh_core_attach_dev( MH_DEV( _storage));

				g_free( _devData);


			}
			else
			{
				//
			}
			close( _clientFd );

			unlink( _clientAddr.sun_path);
		}

		close( _fd );
		
	}
	else
	{
		g_warning("socket failed");
	}
	return NULL;
	//		g_message("\n\n\nlisten\n\n\n");

}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_monitor
 *  Description:  
 * =====================================================================================
 */
static gboolean _register_monitor()
{
	GSource * _source	=	NULL;
	udevMonitor	=	udev_monitor_new_from_netlink( udevCtx, "udev" );


	if( udevMonitor == NULL )
	{
		g_warning( "udev_monitor_new_from_netlink failed" );

		goto NEED_FREE_CTX;
	}

	/* NOTE: in first stage, we only support the block storage in mh_storage */
	if( udev_monitor_filter_add_match_subsystem_devtype( udevMonitor, "block", 0 ) < 0 )
	{
		g_warning( "udev_monitor_filter_add_match_subsystem_devtype failed" );

		goto NEED_FREE_MONITOR;
	}
	if( udev_monitor_filter_add_match_subsystem_devtype( udevMonitor, "usb", 0 ) < 0 )
	{
		g_warning( "udev_monitor_filter_add_match_subsystem_devtype failed" );

		goto NEED_FREE_MONITOR;
	}


	if ( udev_monitor_enable_receiving( udevMonitor ) < 0 )
	{
		g_warning( "udev_monitor_enable_receiving failed" );

		goto NEED_FREE_MONITOR;
	}

	udevFd.fd	=	udev_monitor_get_fd( udevMonitor );

	if( udevFd.fd > 0 )
	{
		udevFd.events	=	POLLIN;

		_source	=	g_source_new( &_funcs, sizeof( GSource ));

		g_source_add_poll( _source, &udevFd );

		g_source_set_callback( _source, _parse_events, mh_core_instance(), NULL );

		mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

		g_source_unref( _source );
	}
	else
	{
		g_warning( "udev_monitor_get_fd faild" );

		goto NEED_FREE_MONITOR;
	}

	g_thread_new("device_listener", _listener, NULL);

	return TRUE;

NEED_FREE_MONITOR:
	udev_monitor_unref( udevMonitor );
NEED_FREE_CTX:
	udev_unref( udevCtx );

	return FALSE;
}		/* -----  end of static function _register_monitor  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _init
 *  Description:  
 * =====================================================================================
 */
static gboolean _init( gpointer user_data )
{
	udevCtx	=	udev_new();

	if( udevCtx == NULL)
	{
		g_warning( "udev_new failed" );

		goto RETURN; 
	}
	/* Scanning the connected storage */
	if( !_scan_storage())
	{
		g_warning( "_scan_storage failed" );

		goto RETURN; 
	}

	/* Registering udev event monitor */
	if( !_register_monitor())
	{
		g_warning( "_register_monitor failed" );

		goto RETURN; 
	}

RETURN:
	g_signal_emit_by_name(mh_core_instance(), "core_events", MH_CORE_PLUGIN_LOAD_SUCCESS, "storage");
	return G_SOURCE_REMOVE;
}		/* -----  end of static function _init  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_plugin_instance
 *  Description:  
 * =====================================================================================
 */
gboolean mh_plugin_instance()
{
	_init( NULL);

	return TRUE;
//	GSource * _source	=	g_idle_source_new();
//
//	g_source_set_callback( _source, _init, NULL, NULL );
//
//	mh_io_dispatch( MH_IO( mh_core_instance() ), _source );
//
//	g_source_unref( _source );
//
//	return TRUE;
}		/* -----  end of function mh_plugin_instance  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_plugin_find_dev
 *  Description:  
 * =====================================================================================
 */
gboolean mh_plugin_find_dev()
{	
	return TRUE;
}		/* -----  end of function mh_plugin_find_dev  ----- */

