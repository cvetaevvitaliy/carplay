/*
 * Generated by object-codegen.
 */
#include <stdio.h>
#include <glib.h>
#include "dev_storage.h"
#include <mh_core.h>
#include <string.h>
#include <mh_item.h>
#include <mh_folder.h>
#include <mh_player.h>
#include <mh_api.h>
#include <mh_playlist.h>
#include <mh_contents.h>
#include <mh_music.h>
#include <mh_filter.h>
#include <tag_c.h>
#include <mh_pb.h>
#include <string.h>
#include <stdlib.h>
#include <mh_dev.h>
#include <gst/gst.h>
#include <sys/stat.h>
#include <unistd.h>

#include <sys/vfs.h>
/////////////////////////////////////////////////////
#include <sys/time.h>
#include <assert.h>
#include <execinfo.h>
#include <iconv.h>
#define DEBUG_TIME_BEGIN() \
{ \
	struct timeval _start = {0, 0}, _current = {0, 0}, _result = {0, 0}; \
	float _max = 0, _min = 10000, _avg = 0; \
	int count = 0; \
	float _tmp; \
	printf("**********TIME MEASURING BEGIN**********\n");

#define DEBUG_TIME_DUR_BEGIN() \
	gettimeofday(&_start, NULL);

#define DEBUG_TIME_DUR_END() \
	gettimeofday(&_current, NULL); \
	timersub(&_current, &_start, &_result); \
	{ \
		_tmp    =   _result.tv_sec + (float)_result.tv_usec / 1000000; \
		if(_tmp > _max) _max =   _tmp; \
		if(_tmp < _min) _min =   _tmp; \
		_avg    +=  (_tmp - _avg) / ( ++ count); \
		fprintf(stdout, "***CNT:%d MAX:%03fs MIN:%03fs AVG:%03fs CUR:%03f\n", count, _max, _min, _avg, _tmp); \
	}

#define DEBUG_TIME_END() \
	printf("***********TIME MEASURING END (%d)***********\n", count); \
}

#define DEBUG_HEX_DISPLAY(D, L) \
{ \
		char _tmpChar[100] = {0}; \
		int _cc, i; \
	\
		fprintf(stdout, "*******HEX DISPLAY BEGIN (%03d bytes)******\n", (L));\
	\
		for(_cc = 0; _cc < (L); _cc += 16) \
		{ \
					memset(_tmpChar, 0, sizeof(_tmpChar)); \
			\
					for(i = 0; i < 16 && i + _cc < (L); i ++) \
					{ \
									_tmpChar[i * 3]     =   ((D)[_cc + i] >> 4)["0123456789ABCDEF"]; \
									_tmpChar[i * 3 + 1] =   ((D)[_cc + i] & 0x0F)["0123456789ABCDEF"]; \
									_tmpChar[i * 3 + 2] =   ' '; \
								} \
			\
					fprintf(stdout, "\t%s\n",  _tmpChar); \
				} \
		fprintf(stdout, "************HEX DISPLAY END*************\n");\
}


typedef struct _MHDevStoragePrivate MHDevStoragePrivate;
#define MAX_PATH_LEN 4096
#define MAX_FILE_IN_DEVICE 5000
#define MIN_FILE_INDEX 0
#define MAX_DEPTH 8
#define MAL_SIZE 10
#define ERROR_TIMEOUT 2000 

#define NEXT_DIRECTION 2

#define SHUFFLE_NUM 2

struct _MHDevStoragePrivate
{
//	guint dummy;
	GMainContext * scan_context;
	GMainLoop * scan_mainloop;
	GThread * scan_thread;
};

G_DEFINE_TYPE_WITH_PRIVATE( MHDevStorage, mh_dev_storage, MH_TYPE_DEV )

enum
{
	PROP_0,

//	PROP_DEV_STORAGE_SERIAL,
	PROP_DEV_STORAGE_FS_TYPE,
	PROP_DEV_STORAGE_ROOT,
	PROP_DEV_STORAGE_FILTER,
	PROP_DEV_STORAGE_HASH_TABLE,
	PROP_DEV_STORAGE_INDEXER,
	PROP_DEV_STORAGE_TOTAL_SIZE,
	PROP_DEV_STORAGE_FREE_SIZE,
	PROP_DEV_STORAGE_BUS,
	PROP_DEV_STORAGE_ENTRY_NUMBER,
	PROP_DEV_STORAGE_FILE_COUNT,

	N_PROPERTIES
};
typedef struct
{
	MHDev * dev;
	bool with_metadata;
}dev_metadata_t;

typedef struct
{
	MHPlaylist *playlist;
	uint32_t index;
}play_by_list_t;

typedef struct
{
	MHFolder * scan_folder;
	MHFolder * indexer_folder;
}list_data;

typedef struct _pb_userdata
{
	MHPb * pb;
	gpointer param;
}pb_userdata;

typedef struct _scan_userdata 
{
	MHDev * dev;
	MHDevScanType type;
} scan_userdata;				/* ----------  end of struct scan_userdata  ---------- */

typedef struct _display_size
{
	MHPb * pb;
	uint32_t offsetx;
	uint32_t offsety;
	uint32_t width;
	uint32_t height;
} display_size;				/* ----------  end of struct display_size  ---------- */

typedef struct _display_pixel
{
	MHPb * pb;
	uint32_t pixel_n;
	uint32_t pixel_d;
} display_pixel;				/* ----------  end of struct display_pixel  ---------- */

typedef struct _sink_userdata
{
	MHPb * pb;
	char * sink_name;
} sink_userdata;				/* ----------  end of struct sink_userdata  ---------- */

typedef struct _media_data
{
	MHPb * pb;
	guint type;
	void * user_data;
} media_data;				/* ----------  end of struct media_data  ---------- */

//typedef struct _indexer_element_t 
//{
//	MHItem * item;
//	gboolean flag;
//} indexer_element_t;				/* ----------  end of struct indexer_node_t  ---------- */
//
static GParamSpec *devStroageProperties[ N_PROPERTIES ] = { NULL, };

MHPlayer * mh_player_h;
 dev_metadata_t * dev_meta;

GList * play_list;
static MHContents * _content;	
static void mh_storage_travel_folder( MHDevStorage * dev, MHFolder * folder, MHFolder * indexer_folder, gint64 device_id,
		MHDevScanType type ,gint64 parent_id, GSList ** closure_list,int depth);
static bool mh_storage_analyze_music( MHDevStorage * dev, MHMusic * music);
static void mh_storage_analyze_movie( MHDevStorage * dev, MHMovie * movie);
static void mh_storage_analyze_picture( MHDevStorage * dev, MHPicture * picture);
static bool mh_storage_analyze_taginfo( MHDevStorage * dev, MHItemType type, MHItem * item);
static guint max_depth;
static guint max_file;
static guint max_folder;

static GRecMutex * scan_mutex	=	NULL;
static guint error_timeout_num = 2000;

extern const hanzi_pinyin_initial dictionary[]; 

extern int mh_dev_get_dictionay_count();
extern const unsigned short UniCode2Pinyin_Tbl[0x10000];
static GHashTable * pinyinHash	=	NULL;
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_property
 *  Description:
 * =====================================================================================
 */
static void _get_property( GObject * object, guint property_id, GValue * value,
		        GParamSpec * spec)
{
	MHDevStorage * _self  =   MH_DEV_STORAGE( object );

	switch( property_id )
	{
/*	case PROP_DEV_STORAGE_SERIAL:
		g_value_set_string( value, _self->serial );
		break;
*/
	case PROP_DEV_STORAGE_FS_TYPE:
		g_value_set_string( value, _self->fs_type );
		break;
	case PROP_DEV_STORAGE_ROOT:
		
		if( _self->root	==	NULL )
		{
			GNode * node;
			MHFolder * folder	=	g_object_new( MH_TYPE_FOLDER, NULL);
			MHItem * item	=	MH_ITEM( folder );
			item->dev=MH_DEV( object );
			item->name	=	g_strdup( ".");
			item->uri	=	g_strdup( item->dev->entry );
			item->type	=	MH_ITEM_FOLDER;
			node	=	g_node_new( folder );
			item->node	=	node;
			_self->root	=	folder;

		}
		g_value_set_pointer( value, _self->root );
		
		break;
	case PROP_DEV_STORAGE_INDEXER:
		g_value_set_pointer( value, _self->indexer);
		break;
	case PROP_DEV_STORAGE_TOTAL_SIZE:
		if( _self->total == 0)
		{
			GList * _list;
			devPartInfo * _info;
			guint64 _bsize, _blocks, _bfree;
			struct statfs _diskInfo;
			_list	=	g_list_first( _self->mountList);
			while( _list != NULL && _list->data != NULL)
			{
				_info	=	(devPartInfo *)(_list->data);
				if (0 == statfs( _info->mountPath, &_diskInfo))
				{
					_bsize	=	(guint64)_diskInfo.f_bsize;
					_blocks	=	(guint64)_diskInfo.f_blocks;
					_bfree	=	(guint64)_diskInfo.f_bfree;

					_self->total	+=	_bsize * _blocks;
					_self->free		+=	_bsize * _bfree;
				}
				else
				{
					g_warning("%s get _self->total Error", __func__);
					_self->total = 0;
				}
				_list	=	_list->next;
			}
		}
		g_message("%s %d  _self->total = %lld", __func__, __LINE__, _self->total);
		g_value_set_uint64( value, _self->total);
		break;
	case PROP_DEV_STORAGE_FREE_SIZE:
		if( _self->free == 0)
		{
			GList * _list;
			devPartInfo * _info;
			guint64 _bsize, _blocks, _bfree;
			struct statfs _diskInfo;
			_list	=	g_list_first( _self->mountList);
			while( _list != NULL && _list->data != NULL)
			{
				_info	=	(devPartInfo *)(_list->data);
				if( 0 == statfs( _info->mountPath, &_diskInfo))
				{
					_bsize	=	(guint64)_diskInfo.f_bsize;
					_blocks	=	(guint64)_diskInfo.f_blocks;
					_bfree	=	(guint64)_diskInfo.f_bfree;

					_self->total	+=	_bsize * _blocks;
					_self->free		+=	_bsize * _bfree;
				}
				else
				{
					g_warning("%s get _self->free Error", __func__);
					_self->free = 0;
				}
				_list	=	_list->next;
			}
		}
		g_message("%s %d  _self->free = %lld", __func__, __LINE__, _self->free);
		g_value_set_uint64( value, _self->free);
		break;
//	case PROP_DEV_STORAGE_FILTER:
//		g_value_set_string( value, _self->filter );
//		break;
//	case PROP_DEV_STORAGE_HASH_TABLE:
//		g_value_set_pointer( value, _self->hash );
//		break;
	
	case PROP_DEV_STORAGE_BUS:
		g_value_set_string( value, _self->bus);
		break;
	case PROP_DEV_STORAGE_ENTRY_NUMBER:
		g_value_set_uint( value, _self->entry_number);
		break;
	case PROP_DEV_STORAGE_FILE_COUNT:
		g_value_set_uint( value, _self->file_count);
		break;
	default:
		break;
	}
}       /*  -----  end of static function _get_property  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  filter_to_hash
 *  Description:  
 * =====================================================================================
 */
static GHashTable * filter_to_hash(char * filter)
{
	GHashTable * _res	=	NULL;
	char * _str;
	char * _key;

	if( filter	!=	NULL)
	{
		_res	=	g_hash_table_new( g_str_hash, g_str_equal );
		while(( _str	=	g_strrstr( filter, ";")) != NULL )
		{
//			_key	=	g_strdup( _str + 1 );
//			_key	=	g_strdown( _key );
			_key	=	g_ascii_strdown( _str + 1, strlen( _str + 1));
			g_hash_table_insert( _res, _key, "");
			* _str	=	'\0';
			
		}
		_key	=	g_ascii_strdown( filter, strlen(filter)	);
		g_hash_table_insert( _res, _key, "");

	}

	return _res;
}		/* -----  end of static function filter_to_hash  ----- */

 
/*
 *  * ===  FUNCTION  ======================================================================
 *   *         Name:  _set_property
 *    *  Description:
 *     * =====================================================================================
 *      */
static void _set_property( GObject * object, guint property_id, const GValue * value,
		        GParamSpec * spec)
{
	MHDevStorage * _self  =   MH_DEV_STORAGE( object );

	switch( property_id )
	{
//	case PROP_DEV_STORAGE_SERIAL:
//		g_strlcpy( _self->serial, g_value_get_string( value ), MH_STRING_MIDDLE );
//		break;
//	case PROP_DEV_STORAGE_FS_TYPE:
//		g_strlcpy( _self->fs_type, g_value_get_string( value ), MH_STRING_SHORT );
		break;
	case PROP_DEV_STORAGE_ROOT:
		_self->root	=	g_value_get_pointer( value );
		break;
//	case PROP_DEV_STORAGE_FILTER:
//		g_strlcpy( _self->filter, g_value_get_string( value ),MH_STRING_LONG );
//		filter_to_hash( object );
//		break;
	default:
		break;
	}
}       /*  -----  end of static function _set_property  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: set_media_location 
 *  Description:
 * =====================================================================================
 */
static gboolean set_media_location( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage set_media_location function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	if( _pb->playlist	==	NULL )
	{
		printf( "%s : playlist is NULL\n",__func__ );	
		return FALSE;
	}
	if( _pb->playlist->seq	==	NULL )
	{
		printf( "%s : _pb->playlist->seq is NULL\n",__func__ );	
		return FALSE;
	}

	MHPbInfoData * _info = g_slice_new( MHPbInfoData );
	g_message("g_slice_new-->MHPbInfoData:%p", _info);
	MHItemData * _item	=	g_array_index( _pb->playlist->array, MHItemData *, 
			_pb->playlist->seq[ _pb->playlist->index ] );

	printf( "####_url = [%s]\n",( char * ) _item->uri );

	mh_player_set_media_location( _pb->mh_player, ( char * )_item->uri );

	_info->track_info.index = _pb->playlist->seq[ _pb->playlist->index ];	
	_info->track_info.uri = g_strdup( _item->uri );
	_info->track_info.name =  g_strdup( _item->name );

	mh_pb_set_media_info( _pb, MH_PB_INFO_TRACK_TOP, _info );

	return FALSE;
}      /* -----  end of static function set_media_location  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  remove_error_timeout_source
 *  Description:
 * =====================================================================================
 */
static gboolean remove_error_timeout_source( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage remove_error_timeout_source function : user_data is NULL\n" );	
		return FALSE;
	}
	MHPb * _pb = ( MHPb * )user_data;
	
	if(	_pb->error_source != NULL ) {
		g_source_destroy( _pb->error_source );
		g_source_unref( _pb->error_source );
		_pb->error_source = NULL;
	}
	return FALSE;
}      /* -----  end of static function remove_error_timeout_source  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  ExistOrNot
 *  Description:
 * =====================================================================================
 */
static gboolean ExistOrNot(uint32_t * seq, uint32_t start_index, uint32_t num )
{
	uint32_t _i;
	for( _i = start_index; _i < SHUFFLE_NUM; _i++ )
	{
		if( seq[_i] == num )
		{
			return TRUE;
		}
	}

	return FALSE; 
}      /* -----  end of static function ExistOrNot  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  remove_state_error_timeout_source
 *  Description:
 * =====================================================================================
 */
static void remove_state_error_timeout_source( MHPb * pb )
{
	if(	pb->state_error_source != NULL ) {

		g_source_destroy( pb->state_error_source );

		g_source_unref( pb->state_error_source );

		pb->state_error_source = NULL;
	}else{
		g_message("%s state_error_source is NULL!",__func__);
	}
}      /* -----  end of static function remove_state_error_timeout_source  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  state_error_timeout
 *  Description:
 * =====================================================================================
 */
static gboolean state_error_timeout(gpointer user_data)
{
	if ( user_data == NULL )
	{
		printf( "dev_storage error_timeout function : user_data is NULL\n" );	
		return FALSE;
	}
	MHPb * _pb = ( MHPb * )user_data;

	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );

	mh_pb_set_media_info( _pb, MH_PB_INFO_STATE_ERROR, NULL );
	
	remove_state_error_timeout_source( _pb );

	return FALSE;
}      /* -----  end of static function state_error_timeout  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _state_error
 *  Description:
 * =====================================================================================
 */
static void _state_error( MHPb * pb )
{
//	pb->state_error_source =	g_timeout_source_new( ERROR_TIMEOUT ); 
	pb->state_error_source =	g_timeout_source_new( error_timeout_num );
	g_source_set_callback( pb->state_error_source, state_error_timeout,  pb, NULL );

	mh_io_dispatch( MH_IO( pb->mhDev ), pb->state_error_source );

}      /* -----  end of static function _state_error  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: previous 
 *  Description:
 * =====================================================================================
 */
static gboolean previous( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage previous function : user_data is NULL\n" );
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	if( _pb->playlist	==	NULL )
	{
		printf( "%s : playlist is NULL\n",__func__ );	
		return FALSE;
	}
	if( _pb->playlist->seq	==	NULL )
	{
		printf( "%s : _pb->playlist->seq is NULL\n",__func__ );	
		return FALSE;
	}

	mh_player_stop( _pb->mh_player );

	if( _pb->error_source != NULL )
	{
		remove_error_timeout_source(_pb );
	}
	if( _pb->state_error_source != NULL )
		remove_state_error_timeout_source( _pb );

	if( _pb->playlist->index > 0 ) 
	{
		_pb->playlist->index = _pb->playlist->index - 1;
	}else{
		if(( _pb->repeat_mode	==	MH_PB_REPEAT_MODE_OFF )&&( _pb->shuffle_mode == MH_PB_SHUFFLE_OFF ))
		{
			mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );
			return FALSE;
		}
		_pb->playlist->index = _pb->playlist->array->len - 1;
	}

	if( _pb->playlist->shuffle == MH_PB_SHUFFLE_ALL )
	{
		uint32_t _reset_index	=	0;
		if( _pb->shuffle_start_index == 0)
		{
			_reset_index	=	_pb->playlist->array->len - 1; 
		}else{
			_reset_index	=	_pb->shuffle_start_index - 1;
		}

		if( _pb->playlist->index == _reset_index )
		{
			const char * _shuffle_state_str = getenv("MH_PB_SHUFFLE_STATE");
			_shuffle_state_str = _shuffle_state_str ? _shuffle_state_str : "0";
			guint _shuffle_state = (guint)atoi(_shuffle_state_str);
			if(0 == _shuffle_state)
			{
				printf( "dev_storage previous function : _shuffle_state is 0\n" );
			}
			else
			{
				printf( "dev_storage previous function : _shuffle_state not 0, recover\n" );
				if( _pb->repeat_mode	==	MH_PB_REPEAT_MODE_OFF )
				{
					mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );
					return FALSE;
				}
				uint32_t * old_seq = g_new0( uint32_t, SHUFFLE_NUM );                                               
				int32_t _m;    
				uint32_t _tmp, _rand_num;
				uint32_t _i = _pb->playlist->array->len - 1;
				for( _m = 1; _m >= 0; _m-- )           //save last three seq id                                                
				{                                                                                      
					old_seq[_m] = _pb->playlist->seq[_pb->shuffle_start_index];                        
					printf(" old_seq[ %d ] = %d\n ",_m, old_seq[_m] );

					if( _pb->shuffle_start_index < _pb->playlist->array->len - 1 )                                                
					{                                                                                  
						_pb->shuffle_start_index ++;                    
					}else{                                                                             
						_pb->shuffle_start_index = 0;	
					}                                                                                  
				}     

				for( _m = 0; _m < ( _pb->playlist->array->len ); _m++ )//recover seq
				{
					_pb->playlist->seq[_m] = _m; 
				}

				_pb->playlist->index = 0;
				_pb->shuffle_start_index = 0;

				for( _i; _i >= 1; --_i )//create shuffle list
				{
					_rand_num = g_random_int_range( 0,_i+1 );

					_tmp = _pb->playlist->seq[_i]; 
					_pb->playlist->seq[_i] = _pb->playlist->seq[_rand_num]; 
					_pb->playlist->seq[_rand_num] = _tmp; 
				}
			
				if( _pb->playlist->array->len > 3 )
				{
					for( _m = 0; _m < SHUFFLE_NUM; _m ++ )       //judge last three file whether repeat                                              
					{                                                                                 
						if( ExistOrNot( old_seq, _m, _pb->playlist->seq[_m]) == TRUE )
						{                                                                             
							while( TRUE )
							{
								_rand_num = g_random_int_range( _m, _pb->playlist->array->len);
								if( ExistOrNot( old_seq, _m, _pb->playlist->seq[_rand_num]) == FALSE )break;		
							}
							_tmp = _pb->playlist->seq[_m];
							_pb->playlist->seq[_m] = _pb->playlist->seq[_rand_num];
							_pb->playlist->seq[_rand_num] = _tmp;
						}                                                                             
					}            
				}

				uint32_t x = 0;
				MHPbInfoData * _s_info = g_slice_new( MHPbInfoData );
				_s_info->sf_list_info.list_count	=	_pb->playlist->array->len;
				_s_info->sf_list_info.shuffle_seq	=	g_new(guint, _pb->playlist->array->len);

				for( x = 0; x<_pb->playlist->array->len;x++ )
				{
					printf("seq[%d] = %d\n",x,_pb->playlist->seq[x]);
					_s_info->sf_list_info.shuffle_seq[x]	=	_pb->playlist->seq[x];
				}

				mh_pb_set_media_info( _pb, MH_PB_IP_INFO_SHUFFLE_LIST, _s_info );

				g_free( old_seq );            
			}
		}
	}

	set_media_location(( gpointer )_pb );
	gboolean _result = FALSE;

	_result = mh_player_play( _pb->mh_player );

	if( _result == TRUE )
	{
		mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );
	}else{
		_state_error( _pb );
	}

	return	FALSE;
}      /* -----  end of static function previous  ----- */ 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _previous
 *  Description:
 * =====================================================================================
 */
static void _previous( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, previous, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _previous  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  next
 *  Description:
 * =====================================================================================
 */
static gboolean next( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage next function : user_data is NULL\n" );	
		return FALSE;
	}
	MHPb * _pb = ( MHPb * )user_data;

	if( _pb->playlist	==	NULL )
	{
		printf( "%s : playlist is NULL\n",__func__ );	
		return FALSE;
	}
	if( _pb->playlist->seq	==	NULL )
	{
		printf( "%s : _pb->playlist->seq is NULL\n",__func__ );	
		return FALSE;
	}

	if( _pb->error_source != NULL )
	{
		remove_error_timeout_source(_pb );
	}
	if( _pb->state_error_source != NULL )
		remove_state_error_timeout_source( _pb );

	mh_player_stop( _pb->mh_player );

	if( _pb->playlist->index	<	_pb->playlist->array->len - 1 ) 
	{
		_pb->playlist->index	++;
	}else{
		if(( _pb->repeat_mode	==	MH_PB_REPEAT_MODE_OFF )&&( _pb->shuffle_mode == MH_PB_SHUFFLE_OFF ))
		{
			mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );
			return FALSE;
		}

		_pb->playlist->index	=	0;
	}

	if( _pb->playlist->shuffle == MH_PB_SHUFFLE_ALL ) 
	{
		if( _pb->playlist->index == _pb->shuffle_start_index )
		{
			const char * _shuffle_state_str = getenv("MH_PB_SHUFFLE_STATE");
			_shuffle_state_str = _shuffle_state_str ? _shuffle_state_str : "0";
			guint _shuffle_state = (guint)atoi(_shuffle_state_str);
			if(0 == _shuffle_state)
			{
				printf( "dev_storage next function : _shuffle_state is 0\n" );
			}
			else
			{
				printf( "dev_storage next function : _shuffle_state not 0, recover\n" );

				if( _pb->repeat_mode	==	MH_PB_REPEAT_MODE_OFF )
				{
					mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );
					return FALSE;
				}
				uint32_t * old_seq = g_new0( uint32_t, SHUFFLE_NUM );                                               
				int32_t _m;    
				uint32_t _tmp, _rand_num;
				uint32_t _i = _pb->playlist->array->len - 1;
				for( _m = 1; _m >= 0; _m-- )           //save last three seq id                                                
				{                                                                                      
					if( _pb->shuffle_start_index == 0 )                                                
					{                                                                                  
						_pb->shuffle_start_index =  _pb->playlist->array->len - 1;                     
					}else{                                                                             
						_pb->shuffle_start_index--;                                                    
					}                                                                                  
					old_seq[_m] = _pb->playlist->seq[_pb->shuffle_start_index];                        
				}                                                                                      

				for( _m = 0; _m < ( _pb->playlist->array->len ); _m++ )//recover seq
				{
					_pb->playlist->seq[_m] = _m; 
				}

				_pb->playlist->index = 0;
				_pb->shuffle_start_index = 0;

				for( _i; _i >= 1; --_i )//create shuffle list
				{
					_rand_num = g_random_int_range( 0,_i+1 );

					_tmp = _pb->playlist->seq[_i]; 
					_pb->playlist->seq[_i] = _pb->playlist->seq[_rand_num]; 
					_pb->playlist->seq[_rand_num] = _tmp; 
				}

				if( _pb->playlist->array->len > 3 )
				{
					for( _m = 0; _m < SHUFFLE_NUM; _m ++ )       //judge last three file whether repeat                                              
					{                                                                                 
						if( ExistOrNot( old_seq, _m, _pb->playlist->seq[_m]) == TRUE )
						{                                                                             
							while( TRUE )
							{
								_rand_num = g_random_int_range( _m, _pb->playlist->array->len);
								if( ExistOrNot( old_seq, _m, _pb->playlist->seq[_rand_num]) == FALSE )break;		
							}
							_tmp = _pb->playlist->seq[_m];
							_pb->playlist->seq[_m] = _pb->playlist->seq[_rand_num];
							_pb->playlist->seq[_rand_num] = _tmp;
						}                                                                             
					}                                                                                 
				}

				uint32_t x = 0;
				MHPbInfoData * _s_info = g_slice_new( MHPbInfoData );
				_s_info->sf_list_info.list_count	=	_pb->playlist->array->len;
				_s_info->sf_list_info.shuffle_seq	=	g_new(guint, _pb->playlist->array->len);

				for( x = 0; x<_pb->playlist->array->len;x++ )
				{
					printf("seq[%d] = %d\n",x,_pb->playlist->seq[x]);
					_s_info->sf_list_info.shuffle_seq[x]	=	_pb->playlist->seq[x];
				}

				mh_pb_set_media_info( _pb, MH_PB_IP_INFO_SHUFFLE_LIST, _s_info );

				g_free( old_seq );                                                                
			}
		}
	}

	set_media_location(( gpointer )_pb );

	gboolean _result = FALSE;

	_result = mh_player_play( _pb->mh_player );

	if( _result == TRUE )
	{
		mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );
	}else{
		_state_error( _pb );
	}

	return	FALSE;
}      /* -----  end of static function next  ----- */ 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _next
 *  Description:
 * =====================================================================================
 */
static void _next( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, next, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}      /* -----  end of static function _next  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _error_timeout
 *  Description:
 * =====================================================================================
 */
static gboolean error_timeout(gpointer user_data)
{
	if ( user_data == NULL )
	{
		printf( "dev_storage error_timeout function : user_data is NULL\n" );	
		return FALSE;
	}
	MHPb * _pb = ( MHPb * )user_data;

	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( SWITCHING_STATUS ), NULL );

	if( _pb->play_direction == NEXT_DIRECTION)
	{
		_next( _pb->mhDev, _pb );
	}else{
		_previous( _pb->mhDev, _pb );
	}
	
	return FALSE;
}      /* -----  end of static function error_timeout  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: set_media_info 
 *  Description:
 * =====================================================================================
 */
static gboolean set_media_info( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage set_media_info function : user_data is NULL\n" );	
		return FALSE;
	}

	media_data * _data = ( media_data * )user_data;

	MHPbInfoData * _info = NULL;
	MHPb * _pb	=	_data->pb;

	if ( _data->user_data!=NULL )
	{
		_info = ( MHPbInfoData * )_data->user_data;
	}
	if( _pb->playlist	==	NULL )
	{
		printf( "dev_storage set_media_info function : playlist is NULL\n" );	
		return FALSE;
	}
	switch( _data->type )
	{
		case MH_PLAYER_EOS:
			mh_pb_set_media_info( _pb, MH_PB_INFO_EOS, NULL );
			g_message("%s MH_PLAYER_EOS ",__func__);
			_pb->play_direction = NEXT_DIRECTION; 
			if ( MH_PB_REPEAT_MODE_ONE == _pb->playlist->repeat )
			{
				mh_pb_dispatch( _pb, EVENT_SWITCHING_REPEAT_ONE, NULL, NULL );
				mh_player_stop(_pb->mh_player);
				set_media_location(( gpointer )_pb );
				gboolean _result = FALSE;
				_result = mh_player_play( _pb->mh_player );
				if( _result == TRUE )
				{
					mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );
				}else{
					_state_error( _pb );				
				}
			}else{
				mh_pb_dispatch( _pb, EVENT_SWITCHING_NEXT, NULL, NULL );
			}
			break;
		case MH_PLAYER_PTIME_CHANGE:
//			printf("Current time [ %d ]ms\r",(guint)_info->ptime_info.current_time);
//			fflush(stdout);
			if( _info->time_info.current_time < 1000 )
			{
				if( _pb->playlist->seq	==	NULL )
				{
					printf( "%s MH_PLAYER_PTIME_CHANGE: _pb->playlist->seq is NULL\n",__func__ );	
				}
				else
				{
					MHItemData * _item	=	g_array_index( _pb->playlist->array, MHItemData *, 
							_pb->playlist->seq[ _pb->playlist->index ] );
					if( _item->valid != MH_ITEM_VALID)
						_item->valid = MH_ITEM_VALID;
				}
			}
			_pb->playlist->ptime = _info->time_info.current_time;
			mh_pb_set_media_info( _pb, MH_PB_INFO_PTIME_CHANGE, _info );
			break;
		case MH_PLAYER_TAG_INFO:
			mh_pb_set_media_info( _pb, MH_PB_INFO_TAG, _info );
			break;
		case MH_PLAYER_ERROR:
			{
				if( _pb->state_error_source	!= NULL )
					remove_state_error_timeout_source( _pb );
				if( _pb->playlist->seq	==	NULL )
				{
					printf( "%s MH_PLAYER_ERROR: _pb->playlist->seq is NULL\n",__func__ );	
				}
				else
				{
					MHItemData * _item	=	g_array_index( _pb->playlist->array, MHItemData *, 
							_pb->playlist->seq[ _pb->playlist->index ] );
					if( _item->valid == MH_ITEM_UNKNOWN )
					{
						_item->valid = MH_ITEM_INVALID;
						_pb->playlist->error_count ++;
					}
				}
				mh_pb_dispatch( _pb, EVENT_ERROR, NULL, NULL );

				mh_pb_set_media_info( _pb, MH_PB_INFO_ERROR, NULL );

//				_pb->error_source =	g_timeout_source_new( ERROR_TIMEOUT ); 
				_pb->error_source =	g_timeout_source_new( error_timeout_num ); 
				g_source_set_callback( _pb->error_source, error_timeout,  _pb, NULL );
				mh_io_dispatch( MH_IO( _pb->mhDev), _pb->error_source );

				break;
			}
		case MH_PLAYER_BOS:
			mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );
			break;
		case MH_PLAYER_ERROR_NOT_EXIST:
			{
				if( _pb->state_error_source	!= NULL )
					remove_state_error_timeout_source( _pb );
				if( _pb->playlist->seq	==	NULL )
				{
					printf( "%s MH_PLAYER_ERROR: _pb->playlist->seq is NULL\n",__func__ );	
				}
				else
				{
					MHItemData * _item	=	g_array_index( _pb->playlist->array, MHItemData *, 
							_pb->playlist->seq[ _pb->playlist->index ] );

					_item->valid = MH_ITEM_NOT_EXIST;
					_pb->playlist->error_count ++;
				}	
				mh_pb_dispatch( _pb, EVENT_ERROR, NULL, NULL );

				mh_pb_set_media_info( _pb, MH_PB_INFO_ERROR_NOT_EXIST, NULL );

//				_pb->error_source =	g_timeout_source_new( ERROR_TIMEOUT ); 
				_pb->error_source =	g_timeout_source_new( error_timeout_num );
				g_source_set_callback( _pb->error_source, error_timeout,  _pb, NULL );
				mh_io_dispatch( MH_IO( _pb->mhDev), _pb->error_source );
			}
//		case MH_PLAYER_FREQUENCY_ANALYSIS_RESULT:
//			mh_pb_set_media_info( _pb, MH_PB_FREQUENCY_ANALYSIS_RESULT, _info );
//			break;
		default:
			break;
	}

	return FALSE;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_media_info
 *  Description:
 * =====================================================================================
 */
static void _set_media_info( MHDev * self, MHPb * pb, guint type, void * user_data )
{
	GSource * _source	=	g_idle_source_new();

	media_data * _data = g_new( media_data, 1 );
	_data->pb	=	pb;
	_data->type	=	type;
	_data->user_data	=	user_data;

	g_source_set_callback( _source, set_media_info, ( gpointer )_data, g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}      /* -----  end of static function _set_media_info  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispose_callback
 *  Description:  
 * =====================================================================================
 */
static gboolean _dispose_callback( gpointer user_data )
{
	g_message("%s",__func__);
//	MHPlayer * _player_handle =  ( MHPlayer * )user_data;

	MHPb * _pb	=	( MHPb * )user_data;

	if( _pb->mh_player	!=	NULL)
	{
		mh_player_stop( _pb->mh_player );
		g_object_unref( _pb->mh_player );
		_pb->mh_player	=	NULL;
	}

	if( _pb->playlist != NULL ) 
	{
		g_object_unref(_pb->playlist);

		_pb->playlist	=	NULL;
	}

	if( _pb->mhDev != NULL ) 
	{
		g_object_unref(_pb->mhDev);

		_pb->mhDev	=	NULL;
	}

	return G_SOURCE_REMOVE;
}		/* -----  end of static function _dispose_callback  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: player_dispose
 *  Description:
 * =====================================================================================
 */
static void player_dispose( MHDev * self,  void * user_data )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _dispose_callback, user_data, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}		/* -----  end of static function player_dispose  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  ppm_shuffle
 *  Description:
 * =====================================================================================
 */
static void ppm_shuffle( MHPb * pb )
{
	int32_t	_i;
	uint32_t * old_seq = g_new0( uint32_t, SHUFFLE_NUM );                                               
	uint32_t _tmp, _rand_num, _m;

	if( pb->playlist->seq	==	NULL )
	{
		printf( "%s : _pb->playlist->seq is NULL\n",__func__ );	
		goto error;
	}
	for( _i = 0; _i < pb->playlist->array->len; _i++ )/* -----  print ppm seq list  ----- */
	{
		printf("pb->playlist->seq[%d] = [%d]\n",_i,pb->playlist->seq[_i] );
	}

	for( _i = 0; _i < pb->playlist->array->len; _i++ )// find index
	{
		if( pb->playlist->seq[_i] == pb->playlist->index )
		{
			pb->playlist->index	=	_i;
			break;
		}
	}

	_tmp	=	pb->playlist->index;

	for( _i = 1; _i >= 0; _i-- )           //save last two seq id                                                
	{                                                                                      
		if( pb->playlist->index == 0 )                                                
		{                                                                                  
			pb->playlist->index	=	pb->playlist->array->len - 1;                     
		}else{                                                                             
			pb->playlist->index	=	pb->playlist->index - 1;                                                    
		}                                                                                  
		old_seq[_i] = pb->playlist->seq[ pb->playlist->index ];                        
		printf( " old_seq[%d] = [%d]\n",_i, old_seq[_i]);
	}  

	pb->playlist->index	=	pb->playlist->seq[_tmp];//find index
	_tmp	=	pb->playlist->index;
	printf("index = [%d]\n",pb->playlist->index );

	for( _m = 0; _m < ( pb->playlist->array->len ); _m++ )//recover seq
	{
		pb->playlist->seq[_m] = _m; 
	}

	for( _i = pb->playlist->array->len - 1; _i >= 1; --_i )//make random list
	{
		_rand_num = g_random_int_range( 0,_i+1 );

		_tmp = pb->playlist->seq[_i]; 
		pb->playlist->seq[_i] = pb->playlist->seq[_rand_num]; 
		pb->playlist->seq[_rand_num] = _tmp; 
	}

	if( pb->playlist->array->len > 3 )
	{
		for( _m = 0; _m < SHUFFLE_NUM; _m ++ )       //judge last three file whether repeat                                              
		{                                                                                 
			if( ExistOrNot( old_seq, _m, pb->playlist->seq[_m]) == TRUE )
			{                                                                             
				while( TRUE )
				{
					_rand_num = g_random_int_range( _m, pb->playlist->array->len);
					if( ExistOrNot( old_seq, _m, pb->playlist->seq[_rand_num]) == FALSE )break;		
				}
				_tmp = pb->playlist->seq[_m];
				pb->playlist->seq[_m] = pb->playlist->seq[_rand_num];
				pb->playlist->seq[_rand_num] = _tmp;
			}                                                                             
		}                                                                                 
	}

	for( _i = 0; _i < pb->playlist->array->len; _i++ )//find index
	{
		if( pb->playlist->seq[_i] == pb->playlist->index )
		{
			pb->playlist->index	=	_i;
			pb->shuffle_start_index = _i;
			break;
		}
	}

	printf( "pb->shuffle_start_index = [%d]\n",pb->shuffle_start_index);

	uint32_t x = 0;
	MHPbInfoData * _s_info = g_slice_new( MHPbInfoData );
	_s_info->sf_list_info.list_count	=	pb->playlist->array->len;
	_s_info->sf_list_info.shuffle_seq	=	g_new(guint, pb->playlist->array->len);

	for( x = 0; x<pb->playlist->array->len;x++ )
	{
		printf("seq[%d] = %d\n",x,pb->playlist->seq[x]);
		_s_info->sf_list_info.shuffle_seq[x]	=	pb->playlist->seq[x];
	}

	mh_pb_set_media_info( pb, MH_PB_IP_INFO_SHUFFLE_LIST, _s_info );

error:
	g_free( old_seq );         

}		/* -----  end of static function player_dispose  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  play_by_list
 *  Description:  
 * =====================================================================================
 */
static gboolean play_by_list( gpointer user_data )
{
	if( user_data	==	NULL )
	{
		g_warning( "dev_storage play_by_list function : user_data is NULL\n" );
		return	FALSE;
	}

	pb_userdata * _pb_userdata = ( pb_userdata * )user_data;
	
	MHPb * _pb = ( MHPb * )_pb_userdata->pb;

	if( _pb_userdata->param	==	NULL )
	{
		g_message(" %s user_data->param is NULL ",__func__);
		return FALSE;
	}
	if( _pb->mh_player == NULL )
	{
		g_message( "play_by_list mh_player_open\n" );
		_pb->playlist = g_object_ref(( MHPlaylist * )_pb_userdata->param );
		
		if(( _pb->playlist == NULL )||( _pb->playlist->dev == NULL )) return FALSE;

		_pb->mhDev 	=	g_object_ref(( MHDev * )_pb->playlist->dev ) ;
		
		if( _pb->mhDev	==	NULL )
		{
			g_message(" %s _pb->mhDev is NULL ",__func__);
			return FALSE;
		}

		_pb->mh_player = mh_player_open();

		if( _pb->mh_player	!=	NULL )
		{
			mh_player_set_ptime_source( _pb->mh_player );

			_pb->mh_player->pb	=	_pb;
			MHDevDetachListener _detach_listener	=	
			{
				.callback	=	player_dispose,
				.user_data	=	_pb
			};
			mh_dev_register_detach_listener( _pb->mhDev, & _detach_listener);

			//			g_signal_connect( _pb->mhDev, "dev_detach", G_CALLBACK( player_dispose), _pb);
			g_message( "repeat mode = [%d]\n",_pb->playlist->repeat );

			_pb->repeat_mode	=	_pb->playlist->repeat;

			MHPbInfoData * _repeat_info = g_slice_new( MHPbInfoData );

			_repeat_info->repeat_mode	=	_pb->repeat_mode;

			mh_pb_set_media_info( _pb, MH_PB_IP_INFO_REPEAT_MODE, _repeat_info );

			g_message( "shuffle_mode = [%d]\n",_pb->playlist->shuffle );

			_pb->shuffle_mode	=	_pb->playlist->shuffle;

			MHPbInfoData * _shuffle_info = g_slice_new( MHPbInfoData );

			_shuffle_info->shuffle_mode	=	_pb->shuffle_mode;

			mh_pb_set_media_info( _pb, MH_PB_IP_INFO_SHUFFLE_MODE, _shuffle_info );

			printf( "index = [ %d ]\n ", _pb->playlist->index );

			if( _pb->playlist->shuffle	==	MH_PB_SHUFFLE_ALL )	
			{
				ppm_shuffle( _pb );
			}

			printf( "index = [ %d ]\n ", _pb->playlist->index );

			if( _pb->video_sink_name != NULL )
			{
				GstElement	* _sink;

				_sink	=	gst_element_factory_make( _pb->video_sink_name, NULL );

				g_object_set( _pb->mh_player->playbin2, "video-sink", _sink, NULL);

				if( g_strcmp0( _pb->video_sink_name, "glimagesink" ) == 0 )
				{
					if( _pb->window_layer	!=	0 )
						g_object_set( _sink, "window_layer", _pb->window_layer, NULL);

					if( _pb->force_aspect_ratio	!=	FALSE )
						g_object_set( _sink, "force_aspect_ratio", _pb->force_aspect_ratio, NULL);

					if( _pb->disp_x	!=	0 )
						g_object_set( _sink, "window_x", _pb->disp_x, NULL);
					if( _pb->disp_y	!=	0 )
						g_object_set( _sink, "window_y", _pb->disp_y, NULL);
					if( _pb->disp_width	!=	0 )
						g_object_set( _sink, "window_width", _pb->disp_width, NULL);
					if( _pb->disp_height	!=	0 )
						g_object_set( _sink, "window_height", _pb->disp_height, NULL);
					if(( _pb->pixel_n != 0 )||( _pb->pixel_d != 0 ))
					{
						g_message("%s pixel_n = %d,pixel_d = %d",__func__,_pb->pixel_n,_pb->pixel_d);
						g_object_set( _sink, "pixel-aspect-ratio", _pb->pixel_n, _pb->pixel_d, NULL);
					}
				}
				else if( g_strcmp0( _pb->video_sink_name, "v4l2sink" ) == 0 )
				{
					if(( _pb->pixel_n != 0 ))
					{
						g_message("%s pixel_n = %d, pixel_d = %d",__func__,_pb->pixel_n,_pb->pixel_d);
						g_object_set(_sink, "aspectratio", _pb->pixel_n, NULL );
					}
				}
				else if( g_strcmp0( _pb->video_sink_name, "mfxsink" ) == 0 )
				{
					g_message("%s pixel_n = %d,pixel_d = %d",__func__,_pb->pixel_n,_pb->pixel_d);
					if(( _pb->pixel_n != 0 )||( _pb->pixel_d != 0 ))
					{
						g_message("%s pixel_n = %d,pixel_d = %d",__func__,_pb->pixel_n,_pb->pixel_d);
						g_object_set( _sink, "pixel-aspect-ratio", _pb->pixel_n, _pb->pixel_d, NULL);
					}
				}
				if( _pb->surfaceid	!=	0 )
				{
					g_object_set( _sink, "surfaceid", _pb->surfaceid, NULL);
					g_message("surfaceid = [%d]  set success \n",_pb->surfaceid);
				}
				if (_pb->mh_player->playbin2_mpeg4 != NULL)
				{
					GstElement	* _sink_mpeg4;
					g_object_get( G_OBJECT( _pb->mh_player->playbin2_mpeg4 ), "video-sink", &_sink_mpeg4, NULL );
					if(( _pb->pixel_n != 0 )||( _pb->pixel_d != 0 ))
					{
						g_message("mpeg4 pixel_n = %d,pixel_d = %d",__func__,_pb->pixel_n,_pb->pixel_d);
						g_object_set( _sink_mpeg4, "pixel-aspect-ratio", _pb->pixel_n, _pb->pixel_d, NULL);
					}
					if( _pb->surfaceid	!=	0 )
					{
						g_object_set( _sink_mpeg4, "surfaceid", _pb->surfaceid, NULL);
						g_message("mpeg4 surfaceid = [%d]  set success \n",_pb->surfaceid);
					}
				}
			}
			
			if( _pb->audio_sink_name != NULL )
			{
				GstElement	* _sink;

				_sink	=	gst_element_factory_make( _pb->audio_sink_name, NULL );

//				if( g_strcmp0( _pb->audio_sink_name, "pulsesink" ) == 0 )
				{
					if( _pb->streamid	!=	NULL )
					{
						g_object_set( _sink, "client-name", _pb->streamid, NULL);
						g_message("streamid = [%s] set success\n",_pb->streamid);
					}
					char * _device_name = getenv("MH_PB_AUDIOSINK_DEVICENAME");
					if (_device_name != NULL)
					{
						g_object_set( _sink, "device", _device_name, NULL);
						g_message("_device_name = [%s] set success\n",_device_name);
					}
				}	
				if( g_strcmp0( _pb->audio_sink_name, "ahsink" ) == 0 )
				{
					g_message("audio sink is ahsink\n");
					if( _pb->octave_period	!=	NULL )
					{
						g_object_set( _sink, "octave-period", _pb->octave_period, NULL);
						g_message("octave-period = [%s] set success\n",_pb->octave_period);
					}
					if( _pb->octave_bands	!=	NULL )
					{
						g_object_set( _sink, "octave-bands", _pb->octave_bands, NULL);
						g_message("octave-bands = [%s] set success\n",_pb->octave_bands);
					}
					if( _pb->octave_enable	!=	NULL )
					{
						g_object_set( _sink, "octave-enable", _pb->octave_enable, NULL);
						g_message("octave-enable = [%s] set success\n",_pb->octave_enable);
					}
//					g_object_set( _sink, "octave-period", "200", NULL);
//					g_object_set( _sink, "octave-bands", "10", NULL);
//					g_object_set( _sink, "octave-enable", "yes", NULL);
				}

				g_object_set( _pb->mh_player->playbin2, "audio-sink", _sink, NULL);

				if (_pb->mh_player->playbin2_mpeg4 != NULL)
				{
					GstElement	* _sink_mpeg4;
					g_message("mpeg4 set audiosink");
					_sink_mpeg4	=	gst_element_factory_make( _pb->audio_sink_name, NULL );
					if( _pb->streamid	!=	NULL )
					{
						g_object_set( _sink_mpeg4, "client-name", _pb->streamid, NULL);
						g_message("mpeg4 streamid = [%s] set success\n",_pb->streamid);
					}
					char * _device_name = getenv("MH_PB_AUDIOSINK_DEVICENAME");
					if (_device_name != NULL)
					{
						g_object_set( _sink_mpeg4, "device", _device_name, NULL);
						g_message("mpeg4 _device_name = [%s] set success\n",_device_name);
					}
					if( g_strcmp0( _pb->audio_sink_name, "ahsink" ) == 0 )
					{
						g_message("audio sink is ahsink\n");
						if( _pb->octave_period	!=	NULL )
						{
							g_object_set( _sink_mpeg4, "octave-period", _pb->octave_period, NULL);
							g_message("octave-period = [%s] set success\n",_pb->octave_period);
						}
						if( _pb->octave_bands	!=	NULL )
						{
							g_object_set( _sink_mpeg4, "octave-bands", _pb->octave_bands, NULL);
							g_message("octave-bands = [%s] set success\n",_pb->octave_bands);
						}
						if( _pb->octave_enable	!=	NULL )
						{
							g_object_set( _sink_mpeg4, "octave-enable", _pb->octave_enable, NULL);
							g_message("octave-enable = [%s] set success\n",_pb->octave_enable);
						}
//						g_object_set( _sink_mpeg4, "octave-period", "200", NULL);
//						g_object_set( _sink_mpeg4, "octave-bands", "10", NULL);
//						g_object_set( _sink_mpeg4, "octave-enable", "yes", NULL);
					}
					g_object_set( _pb->mh_player->playbin2_mpeg4, "audio-sink", _sink_mpeg4, NULL);
				}
			}

//			if(( _pb->playlist != NULL )&&(( _pb->playlist->index >= MIN_FILE_INDEX )&&( _pb->playlist->index < MAX_FILE_IN_DEVICE )))
			if(( _pb->playlist != NULL )&&(( _pb->playlist->index >= MIN_FILE_INDEX )))
			{
				gboolean _result = FALSE;

				set_media_location(( gpointer )_pb );
				printf("_pb->playlist->ptime = [%d]\n",_pb->playlist->ptime);
				if( _pb->playlist->ptime != 0)
				{
					mh_player_pause( _pb->mh_player );
					mh_player_seek( _pb->mh_player, _pb->playlist->ptime );

					gboolean _result = FALSE;

					_result = mh_player_play( _pb->mh_player );

					if( _result == TRUE )
					{
						mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );
					}else{
						mh_player_stop( _pb->mh_player );
						_state_error( _pb );
					}
				}else{
					mh_pb_dispatch( _pb, EVENT_PLAY, NULL, NULL );
				}
			}
		}
	}else{
		g_message( "play_by_list playlist change\n" );
				
		if(MH_DEV(_pb->mhDev)->dev_status==false)
		{
			g_message( "_pb->mhDev dev_status = false send _state_error\n" );
			_state_error( _pb );
			return FALSE;
		}
		
		if( _pb->playlist != NULL ) 
		{
			g_object_unref(_pb->playlist);
			_pb->playlist	=	NULL;
		}
		_pb->playlist	=	g_object_ref(( MHPlaylist *)_pb_userdata->param ) ;
		
		if( _pb->playlist == NULL ) return FALSE;
		if( _pb->playlist->seq	==	NULL )
		{
			printf( "%s : _pb->playlist->seq is NULL\n",__func__ );	
			return FALSE;
		}

//		_pb->playlist->repeat = ( MHPbRepeatMode )_pb->repeat_mode;

//		_pb->repeat_mode = ( MHPbRepeatMode )_pb->playlist->repeat;

		if( _pb->repeat_mode != _pb->playlist->repeat )
		{
			_pb->repeat_mode	=	_pb->playlist->repeat;

			MHPbInfoData * _info = g_slice_new( MHPbInfoData );

			_info->repeat_mode	=	_pb->repeat_mode;

			mh_pb_set_media_info( _pb, MH_PB_IP_INFO_REPEAT_MODE, _info );
		}

		_pb->play_direction = NEXT_DIRECTION;

		if( _pb->error_source != NULL )
		{
			remove_error_timeout_source(_pb );
		}
		if( _pb->state_error_source != NULL )
			remove_state_error_timeout_source( _pb );

		mh_player_stop( _pb->mh_player );

//		if( _pb->playlist->shuffle == MH_PB_SHUFFLE_ALL )
//		{
//			uint32_t _j;
//			for( _j = 0; _j < ( _pb->playlist->array->len ); _j++ )
//			{
//				_pb->playlist->seq[_j] = _j; 
//			}
//			_pb->playlist->shuffle = MH_PB_SHUFFLE_OFF;
//		}
//
//		_pb->shuffle_mode   =   _pb->playlist->shuffle;
		if( _pb->playlist->shuffle == MH_PB_SHUFFLE_ALL )
		{
			uint32_t _j;
			for( _j = 0; _j < ( _pb->playlist->array->len ); _j++ )
			{
				if(_pb->playlist->seq[_j] == _pb->playlist->index )
				{
					_pb->playlist->index	=	_j;
					_pb->shuffle_start_index	=	_j;
					g_message("shuffle mode playlist index	=	%d",_pb->playlist->index);
					break;
				}
			}
		}
		if( _pb->shuffle_mode != _pb->playlist->shuffle )
		{
			_pb->shuffle_mode	=	_pb->playlist->shuffle;
		
			MHPbInfoData * _info = g_slice_new( MHPbInfoData );

			_info->shuffle_mode	=	_pb->shuffle_mode;

			mh_pb_set_media_info( _pb, MH_PB_IP_INFO_SHUFFLE_MODE, _info );
		}

		set_media_location(( gpointer )_pb );
		if( _pb->playlist->ptime != 0)
		{
			mh_player_pause( _pb->mh_player );
			mh_player_seek( _pb->mh_player, _pb->playlist->ptime );
		}

		gboolean _result = FALSE;
		_result = mh_player_play( _pb->mh_player );
		if( _result == TRUE )
		{
			mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );
		}else{
			mh_player_stop( _pb->mh_player );
			_state_error( _pb );
		}
	}

	return	FALSE;
}	
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_by_list
 *  Description:
 * =====================================================================================
 */
static void _play_by_list( MHDev * self, MHPb * pb, MHPlaylist * playlist )
{
	GSource * _source	=	g_idle_source_new();
	
	pb_userdata * _pb_userdata = g_new( pb_userdata, 1 );
	_pb_userdata->pb	=	pb;
	_pb_userdata->param 	=	( gpointer )playlist;

	g_source_set_callback( _source, play_by_list, ( gpointer )_pb_userdata , g_free );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}      /* -----  end of static function _play_by_list  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_radio_by_index
 *  Description:
 * =====================================================================================
 */
static void _play_radio_by_index( MHDev * self, MHPb * pb, uint32_t index ) 
{
	printf("not use just for iap2 [%d] _play_radio_by_index\n", index);
}      /* -----  end of static function _play_radio_by_index  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  stop
 *  Description:  
 * =====================================================================================
 */
static gboolean stop( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage stop function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;
	
	if( _pb->error_source != NULL )
	{
		remove_error_timeout_source(( gpointer )_pb );
	}
	if( _pb->state_error_source != NULL )
		remove_state_error_timeout_source( _pb );
	gboolean _result = FALSE;
	 _result = mh_player_stop( _pb->mh_player );
	if( _result == TRUE )
	{
		mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );
	}else{
		_state_error( _pb );	
	}
	return	FALSE;
}	

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _stop
 *  Description:
 * =====================================================================================
 */
static void _stop( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, stop, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}      /* -----  end of static function _stop  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  pb_close
 *  Description:  
 * =====================================================================================
 */
static gboolean pb_close( gpointer user_data )
{
	g_message( "-------------->storage mh_player_close" );

	if ( user_data == NULL )
	{
		printf( "dev_storage close function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;
	
	if( _pb->error_source != NULL )
	{
		remove_error_timeout_source(( gpointer )_pb );
	}
	if( _pb->state_error_source != NULL )
		remove_state_error_timeout_source( _pb );

	mh_player_close( _pb->mh_player );
	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );

	return	FALSE;
}	

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _close
 *  Description:
 * =====================================================================================
 */
static void _close( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, pb_close, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}      /* -----  end of static function _close  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  play
 *  Description:
 * =====================================================================================
 */
static gboolean play( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage play function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	gboolean _result = FALSE;
	_result = mh_player_play( _pb->mh_player );
	if( _result == TRUE )
	{
		mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );
	}else{		
		_state_error( _pb );
	}
	return	FALSE;
}  

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play
 *  Description:
 * =====================================================================================
 */
static void _play( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, play, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}      /* -----  end of static function _play  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: pause 
 *  Description:
 * =====================================================================================
 */
static gboolean pause_player( gpointer user_data )
{
	gboolean _result = FALSE;
	if ( user_data == NULL )
	{
		printf( "dev_storage pause function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	_result = mh_player_pause( _pb->mh_player );
	if( _result == TRUE )
	{
		mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PAUSE_STATUS ), NULL );
	}else{
		_state_error( _pb );	
	}
	return	FALSE;
} 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pause
 *  Description:
 * =====================================================================================
 */
static void _pause( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, pause_player, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _pause  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name: seek 
 *  Description:
 * =====================================================================================
 */
static gboolean seek( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage seek function : user_data is NULL\n" );	
		return FALSE;
	}

	pb_userdata * _pb_userdata = ( pb_userdata * )user_data;

	mh_player_seek( _pb_userdata->pb->mh_player, *((uint32_t *)_pb_userdata->param) );

	g_free( _pb_userdata->param);

	mh_pb_dispatch( _pb_userdata->pb, EVENT_CHANGE, NULL, NULL );	

	return	FALSE;
}  

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _seek
 *  Description:
 * =====================================================================================
 */
static void _seek( MHDev * self, MHPb * pb, uint32_t second )
{
	GSource * _source	=	g_idle_source_new();

	pb_userdata * _pb_userdata = g_new( pb_userdata, 1 );
	_pb_userdata->pb	=	pb;

	uint32_t * _sec	=	g_new( uint32_t, 1);

	*_sec	=	second;

	_pb_userdata->param 	=	( gpointer )_sec;


	g_source_set_callback( _source, seek, ( gpointer )_pb_userdata , g_free );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _seek  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: playlist_change 
 *  Description:
 * =====================================================================================
 */
static gboolean playlist_change( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage playlist_change function : user_data is NULL\n" );	
		return FALSE;
	}

	pb_userdata * _pb_userdata = ( pb_userdata * )user_data;
	if( _pb_userdata->pb->playlist != NULL ) 
		g_object_unref(_pb_userdata->pb->playlist);
 	_pb_userdata->pb->playlist	=	g_object_ref(( MHPlaylist *)_pb_userdata->param ) ;
	_pb_userdata->pb->play_direction = NEXT_DIRECTION;
	return	FALSE;
}  

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _playlist_change
 *  Description:
 * =====================================================================================
 */
static void _playlist_change( MHDev * self, MHPb * pb, MHPlaylist * playlist )
{
	GSource * _source	=	g_idle_source_new();

	pb_userdata * _pb_userdata = g_new( pb_userdata, 1 );
	_pb_userdata->pb	=	pb;
	_pb_userdata->param 	=	( gpointer )playlist;

	g_source_set_callback( _source, playlist_change, ( gpointer )_pb_userdata , g_free );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _playlist_change  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_pause
 *  Description:
 * =====================================================================================
 */
static void _play_pause( MHDev * self )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _play_pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _resume
 *  Description:
 * =====================================================================================
 */
static void _resume( MHDev * self )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _resume  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: forward 
 *  Description:
 * =====================================================================================
 */
static gboolean forward( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage forward function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( SEEKING_STATUS ), NULL );

	mh_player_forward( _pb->mh_player );

	return	FALSE;
}  

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward
 *  Description:
 * =====================================================================================
 */
static void _forward( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, forward, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _forward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: forward_done
 *  Description:
 * =====================================================================================
 */
static gboolean forward_done( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage forward_done function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	mh_player_forward_done( _pb->mh_player );

	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );

	return	FALSE;
}      /* -----  end of static function forward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward_done
 *  Description:
 * =====================================================================================
 */
static void _forward_done( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, forward_done, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _forward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: backward 
 *  Description:
 * =====================================================================================
 */
static gboolean backward( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage backward function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( SEEKING_STATUS ), NULL );

	mh_player_backward( _pb->mh_player );

	return	FALSE;
}  

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward
 *  Description:
 * =====================================================================================
 */
static void _backward( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, backward, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _backward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: backward_done 
 *  Description:
 * =====================================================================================
 */
static gboolean backward_done( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage backward_done function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	mh_player_backward_done( _pb->mh_player );

	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );

	return	FALSE;
}      /* -----  end of static function backward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward_done
 *  Description:
 * =====================================================================================
 */
static void _backward_done( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, backward_done, ( gpointer )pb , NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _backward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  set_index
 *  Description:
 * =====================================================================================
 */
static gboolean set_index( gpointer user_data ) 
{
	if ( user_data == NULL )
	{
		printf( "dev_storage set_index function : user_data is NULL\n" );	
		return FALSE;
	}
	
	pb_userdata * _pb_userdata = ( pb_userdata * )user_data;

	MHPb * _pb = MH_PB( _pb_userdata->pb );
	
	if( _pb->playlist	==	NULL )
	{
		printf( "%s : playlist is NULL\n",__func__ );	
		return FALSE;
	}
	if( _pb->playlist->seq	==	NULL )
	{
		printf( "%s : _pb->playlist->seq is NULL\n",__func__ );	
		return FALSE;
	}

	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( SWITCHING_STATUS ), NULL );

	if( _pb->error_source != NULL )
	{
		remove_error_timeout_source(_pb );
	}
	if( _pb->state_error_source != NULL )
		remove_state_error_timeout_source( _pb );

	mh_player_stop( _pb->mh_player );

//	if( _pb->playlist->shuffle == MH_PB_SHUFFLE_ALL )
//	{
//		uint32_t _j;
//		for( _j = 0; _j < ( _pb->playlist->array->len ); _j++ )
//		{
//			_pb->playlist->seq[_j] = _j; 
//		}
//		_pb->playlist->shuffle = MH_PB_SHUFFLE_OFF;
//	}
//	_pb->playlist->index = (uint32_t)_pb_userdata->param;

	if( _pb->playlist->shuffle == MH_PB_SHUFFLE_ALL )
	{
		uint32_t _j;
		for( _j = 0; _j < ( _pb->playlist->array->len ); _j++ )
		{
			if( _pb->playlist->seq[_j] == *((uint32_t *)_pb_userdata->param) )
			{
				g_free( _pb_userdata->param);
				_pb->playlist->index = _j;
				break;
			}
		}
	}else{
		_pb->playlist->index = *((uint32_t*)_pb_userdata->param);
		g_free( _pb_userdata->param);
	}

	set_media_location(( gpointer )_pb );
	
	gboolean _result = FALSE;

	_result = mh_player_play( _pb->mh_player );

	if( _result == TRUE )
	{
		mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( PLAY_STATUS ), NULL );
	}else{
		_state_error( _pb );	
	}

	return	FALSE;
}      /* -----  end of static function set_index  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_index
 *  Description:
 * =====================================================================================
 */
static void _set_index( MHDev * self, MHPb * pb, uint32_t index ) 
{
	GSource * _source	=	g_idle_source_new();

	pb_userdata * _pb_userdata = g_new( pb_userdata, 1 );
	_pb_userdata->pb	=	pb;

	uint32_t *_index	=	g_new( uint32_t, 1);
	*_index	=	index;

	_pb_userdata->param 	=	( gpointer )_index;

	g_source_set_callback( _source, set_index, ( gpointer )_pb_userdata , g_free );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );

}      /* -----  end of static function _set_index  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: resize 
 *  Description:
 * =====================================================================================
 */
static gboolean resize( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage resize function : user_data is NULL\n" );	
		return FALSE;
	}

	display_size * _size = ( display_size * )user_data;

	mh_player_resize( _size->pb->mh_player, _size->offsetx, _size->offsety, _size->width, _size->height );

	return	FALSE;
}      /* -----  end of static function resize  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: pixel_aspect_ratio 
 *  Description:
 * =====================================================================================
 */
static gboolean pixel_aspect_ratio( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage pixel_aspect_ratio function : user_data is NULL\n" );	
		return FALSE;
	}

	display_pixel * _pixel = ( display_pixel * )user_data;

	mh_player_pixel_aspect_ratio( _pixel->pb->mh_player, _pixel->pixel_n, _pixel->pixel_d );

	return	FALSE;
}      /* -----  end of static function pixel_aspect_ratio  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _resize
 *  Description:
 * =====================================================================================
 */
static void _resize( MHDev * self, MHPb * pb, uint32_t offsetx, uint32_t offsety, uint32_t width, uint32_t height ) 
{
	GSource * _source	=	g_idle_source_new();

	display_size * _size = g_new( display_size, 1 );

	_size->pb	=	pb;
	_size->offsetx	=	offsetx;
	_size->offsety	=	offsety;
	_size->width	=	width;
	_size->height	=	height;

	g_source_set_callback( _source, resize, ( gpointer )_size , g_free );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );

}      /* -----  end of static function _resize  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pixel_aspect_ratio
 *  Description:
 * =====================================================================================
 */
static void _pixel_aspect_ratio( MHDev * self, MHPb * pb, uint32_t pixel_n, uint32_t pixel_d ) 
{
	GSource * _source	=	g_idle_source_new();

	display_pixel * _pixel = g_new( display_pixel, 1 );

	_pixel->pb	=	pb;
	_pixel->pixel_n	=	pixel_n;
	_pixel->pixel_d	=	pixel_d;


	g_source_set_callback( _source, pixel_aspect_ratio, ( gpointer )_pixel , g_free );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );

}      /* -----  end of static function _pixel_aspect_ratio  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: set_video_sink 
 *  Description:
 * =====================================================================================
 */
static gboolean set_video_sink( gpointer user_data )
{
	gboolean _result = FALSE;
	if ( user_data == NULL )
	{
		printf( "dev_storage resize set_video_sink : user_data is NULL\n" );	
		return _result;
	}

	sink_userdata * _data = ( sink_userdata * )user_data;

	_result	=	mh_player_set_video_sink( _data->pb->mh_player, _data->sink_name );

	return	FALSE;
}      /* -----  end of static function resize  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_video_sink
 *  Description:
 * =====================================================================================
 */
static void _set_video_sink( MHDev * self, MHPb * pb, const char * video_sink_name ) 
{
	GSource * _source	=	g_idle_source_new();

	sink_userdata * _data = g_new( sink_userdata, 1 );
	_data->pb	=	pb;
	_data->sink_name	=	g_strdup( video_sink_name );

	g_source_set_callback( _source, set_video_sink, ( gpointer )_data , g_free );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );

}      /* -----  end of static function _set_video_sink  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_speed
 *  Description:
 * =====================================================================================
 */
static void _set_speed( MHDev * self, guint speed )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_speed  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  set_shuffle
 *  Description:
 * =====================================================================================
 */
static gboolean set_shuffle( gpointer user_data )
{
	if ( user_data == NULL )
	{
		g_message( "dev_storage set_shuffle function : user_data is NULL" );	
		return FALSE;
	}
	MHPb * _pb = ( MHPb * )user_data;

	if( _pb->playlist	==	NULL )
	{
		g_message( "%s : playlist is NULL",__func__ );	
		return FALSE;
	}
	if( _pb->playlist->seq	==	NULL )
	{
		printf( "%s : _pb->playlist->seq is NULL\n",__func__ );	
		return FALSE;
	}

	uint32_t _i = _pb->playlist->array->len - 1;
	uint32_t _tmp, _rand_num;
	
//	_pb->playlist->repeat	=	_pb->repeat_mode;
//	_pb->repeat_mode	=	MH_PB_REPEAT_MODE_ALL;
	_pb->playlist->shuffle	=	_pb->shuffle_mode;

	if( _pb->playlist->shuffle == MH_PB_SHUFFLE_ALL )
	{
		g_message( "_pb->playlist->index = [%d]",_pb->playlist->index);
		for( _i; _i >= 1; --_i )
		{
			_rand_num = g_random_int_range( 0,_i+1 );

			 _tmp = _pb->playlist->seq[_i]; 
			_pb->playlist->seq[_i] = _pb->playlist->seq[_rand_num]; 
			_pb->playlist->seq[_rand_num] = _tmp; 
		}
		for( _i = 0; _i < (_pb->playlist->array->len); _i++ )
		{
			if( _pb->playlist->index == _pb->playlist->seq[_i] )
			{
				_pb->shuffle_start_index = _i;
				_pb->playlist->index = _i;
				g_message( "_pb->shuffle_start_index = [%d]",_pb->shuffle_start_index);
				break;
			}
		}
		uint32_t _j = 0;

		MHPbInfoData * _s_info = g_slice_new( MHPbInfoData );
		_s_info->sf_list_info.list_count	=	_pb->playlist->array->len;
		_s_info->sf_list_info.shuffle_seq	=	g_new(guint, _pb->playlist->array->len);

		for( _j = 0; _j<_pb->playlist->array->len;_j++ )
		{
			_s_info->sf_list_info.shuffle_seq[_j]	=	_pb->playlist->seq[_j];
		}
		mh_pb_set_media_info( _pb, MH_PB_IP_INFO_SHUFFLE_LIST, _s_info );

	}else{
		uint32_t _j;
		_pb->playlist->index = _pb->playlist->seq[_pb->playlist->index];
		for( _j = 0; _j < ( _pb->playlist->array->len ); _j++ )
		{
			_pb->playlist->seq[_j] = _j; 
		}
	}
	uint32_t x = 0;
#if 0
	for( x = 0; x<_pb->playlist->array->len;x++ )
	{
		g_message("seq[%d] = %d",x,_pb->playlist->seq[x]);
	}
#endif
	MHPbInfoData * _info = g_slice_new( MHPbInfoData );

	_info->shuffle_mode	=	_pb->playlist->shuffle;

	mh_pb_set_media_info( _pb, MH_PB_IP_INFO_SHUFFLE_MODE, _info );

	return	FALSE;
}      /* -----  end of static function set_shuffle  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_shuffle
 *  Description:
 * =====================================================================================
 */
static void _set_shuffle( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, set_shuffle, ( gpointer )pb, NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _set_shuffle  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: set_rate 
 *  Description:
 * =====================================================================================
 */
static gboolean set_rate( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage set_rate function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data;

	mh_player_set_rate( _pb->mh_player, _pb->rate );

	return	FALSE;
}      /* -----  end of static function set_rate  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_rate
 *  Description:
 * =====================================================================================
 */
static void _set_rate( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, set_rate, ( gpointer )pb, NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _set_rate  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  set_repeat
 *  Description:
 * =====================================================================================
 */
static gboolean set_repeat( gpointer user_data )
{
	if ( user_data == NULL )
	{
		printf( "dev_storage set_repeat function : user_data is NULL\n" );	
		return FALSE;
	}

	MHPb * _pb = ( MHPb * )user_data ;

	if( _pb->playlist	==	NULL )
	{
		printf( "%s : playlist is NULL\n",__func__ );	
		return FALSE;
	}

//	if( _pb->playlist->shuffle != MH_PB_SHUFFLE_OFF )
//	{
//		_pb->shuffle_mode = MH_PB_SHUFFLE_OFF;
//		set_shuffle(( gpointer )_pb );
//	}

	_pb->playlist->repeat = ( MHPbRepeatMode )_pb->repeat_mode;
	printf( "repeat_mode = [%d]\n",_pb->playlist->repeat );	

	MHPbInfoData * _info = g_slice_new( MHPbInfoData );

	_info->repeat_mode	=	_pb->repeat_mode;

	mh_pb_set_media_info( _pb, MH_PB_IP_INFO_REPEAT_MODE, _info );

	return	FALSE;
}      /* -----  end of static function _set_repeat  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_repeat
 *  Description:
 * =====================================================================================
 */
static void _set_repeat( MHDev * self, MHPb * pb )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, set_repeat, ( gpointer )pb, NULL );

	mh_io_dispatch( MH_IO( self ), _source );
	
	g_source_unref( _source );
}      /* -----  end of static function _set_repeat  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_buffer_time
 *  Description:
 * =====================================================================================
 */
static void _set_buffer_time( MHDev * self )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_buffer_time  ----- */

void Func (gpointer key, gpointer value,gpointer user_data)
{
//	g_message("key:%s\n",(char *)key);

}
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  hashValueDestroyFunc
 *  Description:  
 * =====================================================================================
 */
void hashValueDestroyFunc( gpointer value)
{
	indexer_element_t * _value	=	(indexer_element_t *)value;
	g_free(_value);
}		/* -----  end of function hashValueDestroyFunc  ----- */

gboolean TraverseFunc (GNode *node,gpointer data)
{
		MHItem * _item	=	node->data;
//		g_message("uri:%s\n",_item->uri);
		if(_item->type==MH_ITEM_FOLDER)
		{
			g_hash_table_foreach(MH_FOLDER( _item )->hash, Func, NULL);
		}
		return FALSE;
}
static bool dev_on;
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _create_indexer
 *  Description:  
 * =====================================================================================
 */
static MHFolder *  _create_indexer(MHContents * self, MHDev * dev, MHDevScanType type)
{
	MHFolder *_res	=	NULL;
	gchar * _sql ;
	//for table node
	gint64 _nodeId, _deviceId, _size, _type, _valid, _tagId;
	gchar * _name	=	NULL; 
	//for table closure
	gint64 _closureDeviceId, _descendant, _ancestor, _parent;//del db by deviceId
	//for table music
	gint64 _musicId, _musicRating, _musicDuration, _musicTrack, _musicTrackCount,
		   _musicDisc, _musicDiscCount, _musicYear, _musicMediaType, _musicCompliation, _musicDeviceId, _musicLastChgTime;//del db by deviceId //compare by lastchangtime 
	gchar * _musicTitle	=	NULL;
	gchar * _musicAlbumTitle	=	NULL;
	gchar * _musicArtist	=	NULL;
	gchar * _musicAlbumArtist	=	NULL;
    gchar * _musicGenre	=	NULL;
	gchar *	_musicComposer	=	NULL;
	
	//fot table movie
	gint64 _movieId, _movieYear, _movieDuration, _movieFps, _movieXres, _movieYres, _movieDeviceId;//del db by deviceId
	gchar * _movieTitle	=	NULL;
	gchar * _movieDiector	=	NULL;
	gchar * _movieGenre	=	NULL;
	gchar *	_movieLanguage	=	NULL;
	//for table picture
	gint64 _pictureId, _pictureWidth, _pictureHeight, _pictureBpp, _picDeviceId;//del db by deviceId
	gchar * _pictureFormat	=	NULL;

	MHItem * _item	=	NULL;
	MHFolder * _folder	=	NULL;
	MHMusic * _music	=	NULL;
	MHMovie * _movie	=	NULL;
	MHPicture * _picture	=	NULL;

	gint64 _parentid;
	GNode * _node	=	NULL;
	GNode * _parentnode	=	NULL;
	MHItem * _parentitem	=	NULL;

	gint64 _mem_parent;

	int _err;
	MHStmt * _stmt = NULL;

	_deviceId	=	mh_contents_get_device( self,dev->serial);

	if(_deviceId != -1)
	{
		g_message("the device is in db\n");
	}
	else
	{
		_deviceId = mh_contents_add_device( self, dev->serial);

		mh_object_get_properties( ( MHObject * )dev, "root", &_folder, NULL );

		_item	=	MH_ITEM( _folder);
		if (NULL == _item)
		{
			g_message("_create_indexer _item = NULL");
			return NULL;
		}
		_nodeId = mh_contents_add_node(self, _deviceId, _item);

		mh_contents_add_closure(self, _nodeId, _nodeId, _nodeId, _deviceId);//del db by deviceId
	}

	dev->uniqueId	=	_deviceId;

	_sql	=	"select * from node left outer join closure on node.node_id=closure.descendant \
left outer join music on node.node_id=music.node_id left outer join movie on node.node_id=movie.node_id \
left outer join picture on node.node_id=picture.node_id where device_id =? group by node.node_id order by node.node_id ";
//	g_message("%s:%s\n",__func__, _sql);

	_stmt	=	mh_contents_prepare( self, _sql );
	if( _stmt == NULL)
	{
		g_warning("%s:%d->error", __func__, __LINE__);
		return NULL;
	}

	mh_contents_bind_int64(self, _stmt, 1, _deviceId);

	//del db by deviceId //compare by lastchangtime 
	while( mh_contents_step(self,_stmt, &_nodeId, &_deviceId, &_name, &_size, &_type, &_valid, &_tagId, &_closureDeviceId, &_descendant, 
				&_ancestor, &_parent, &_musicId, &_musicTitle, &_musicRating, &_musicDuration, &_musicAlbumTitle, &_musicTrack, 
				&_musicTrackCount, &_musicDisc, &_musicDiscCount, &_musicArtist, &_musicAlbumArtist, &_musicGenre,
				&_musicComposer, &_musicYear, &_musicMediaType, &_musicCompliation,  &_musicDeviceId, &_musicLastChgTime, &_movieId, &_movieTitle, &_movieYear, 
				&_movieDiector, &_movieDuration, &_movieGenre, &_movieFps, &_movieXres, &_movieYres, &_movieLanguage, &_movieDeviceId,
				&_pictureId, &_pictureFormat, &_pictureWidth, &_pictureHeight, &_pictureBpp, &_picDeviceId, NULL)	==	MH_CONTENTS_STEP_CONTINUE )
	{
		switch( _type )
		{
			case MH_ITEM_FOLDER:
				_folder	=	g_object_new(MH_TYPE_FOLDER, NULL);
				_folder->hash	=	g_hash_table_new_full(g_str_hash, g_str_equal, NULL, hashValueDestroyFunc);
				_folder->scanned	=	true;
				_item	=	MH_ITEM( _folder );
				break;

			case MH_ITEM_MUSIC:
				_music	=	g_object_new(MH_TYPE_MUSIC, NULL);
				_item	=	MH_ITEM( _music );
//				if( type	==	SCAN_TAG )
//				{
					_item->mediaId	=	_musicId;
					_music->title	=	_musicTitle ;
					_music->rating	=	_musicRating;
					_music->duration	=	_musicDuration;
					_music->album_title	=	 _musicAlbumTitle;
					_music->track	=	_musicTrack;
					_music->track_count	=	_musicTrackCount;
					_music->disc	=	_musicDisc;
					_music->disc_count	=	_musicDiscCount;
					_music->artist	=	 _musicArtist;
					_music->album_artist	=	_musicAlbumArtist;
					_music->genre	=	_musicGenre;
					_music->composer	=	_musicComposer;
					_music->year	=	_musicYear;
					_music->mediaType	=	_musicMediaType;
					_music->last_chgtime	=	_musicLastChgTime;
//				}

				break;

			case MH_ITEM_MOVIE:
				_movie	=	g_object_new( MH_TYPE_MOVIE, NULL);
				_item	=	MH_ITEM( _movie );
//				if( type	==	SCAN_TAG )
//				{
					_item->mediaId	=	_movieId;
					_movie->title	=	 _movieTitle ;
					_movie->year	=	_movieYear;
					_movie->director	=	 _movieDiector ;
					_movie->duration	=	_movieDuration;
					_movie->genre	=	_movieGenre;
					_movie->fps	=	_movieFps;
					_movie->xres	=	_movieXres;
					_movie->yres	=	_movieYres;
					_movie->language	=	 _movieLanguage ;
//				}

				break;
			case MH_ITEM_PICTURE:
				_picture	=	g_object_new( MH_TYPE_PICTURE, NULL);
				_item	=	MH_ITEM( _picture );
//				if( type	==	SCAN_TAG)
//				{
					_item->mediaId	=	_pictureId;
					_picture->format	=	_pictureFormat;
					_picture->width	=	_pictureWidth;
					_picture->height	=	_pictureHeight;
					_picture->bpp	=	_pictureBpp;
//				}

				break;
			case MH_ITEM_PLAYLIST:
				_item	=	g_object_new( MH_TYPE_ITEM, NULL);
				break;
			default:
				break;
		}
		_item->uniqueId	=	_nodeId;
		_item->name	=	 _name ;
		_item->size	=	_size;
		_item->type	=	_type;
		_item->valid	=	_valid;
		_item->tagId	=	_tagId;

		if(_parent==_descendant)
		{
			g_message("root \n");

			_node	=	g_node_new( _folder);

			_item->node	=	_node;
			_item->dev	=	dev;
			_item->uri	=	g_strdup(dev->entry);

			g_hash_table_insert(dev->itemsHash , &_item->uniqueId, _item );

			_res	=	_folder;

			_mem_parent	=	_parent;
		}
		else
		{
			_parentitem	=	g_hash_table_lookup( dev->itemsHash,&_parent);
			if(_parentitem	==	NULL)
			{
				g_message("_parentitem %ld is not found in dbhash\n",_parent);
		//		assert(0);
			}
			else
			{
				_item->dev	=	_parentitem->dev;

				_item->uri	=	g_strdup_printf( "%s/%s", _parentitem->uri, _item->name );

				_node	=	g_node_new( _item );

				_item->node	=	_node;

				g_node_append( _parentitem->node, _item->node );
				
				indexer_element_t * _element=g_new( indexer_element_t, 1);
	
				_element->item	=	_item;

				_element->flag	=	FALSE;
				
				g_hash_table_insert( MH_FOLDER(_parentitem)->hash, _item->name, _element);

				g_hash_table_insert( dev->itemsHash, & _item->uniqueId, _item);
			}

			mh_folder_add_type_count( MH_FOLDER(_parentitem),_type);
		}
		if(_mem_parent	!=	_parent)
		{

			MHItem * _item;

			_item	=	g_hash_table_lookup( dev->itemsHash,&_mem_parent);

	//		g_node_reverse_children(_item->node);

			_mem_parent	=	_parent;
		}

	}
	mh_contents_release(self, _stmt );
 	return _res;
}		/* -----  end of static function _create_indexer  ----- */
gushort * stringToCode(MHDevStorage * dev,char * name, uint32_t * count );
guint g_ushort_hash(gconstpointer key)
{
	return (guint) *(const gushort *)key;
}
gboolean g_ushort_equal( gconstpointer v1, gconstpointer v2)
{
	return *((const gushort *)v1) == *((const gushort*)v2);
}

void g_hash_destroy_key( gpointer data)
{
	gushort * _data	=	(gushort *)data;
	g_free( _data);

}
void g_hash_destroy_value( gpointer data)
{
	pinyin_initial * _data	=	(pinyin_initial*)data;
	g_free( _data->pinyin);
	g_free( _data->initial);
	g_free( _data);

}
void foreashFunc(gpointer key, gpointer value, gpointer user_data)
{
	pinyin_initial * p	=	(pinyin_initial *)value;
	g_message("%s-->%x-->%s--->%s", __func__, *(gushort *)key, p->pinyin, p->initial); 
}
void _create_dictionary(MHDevStorage * dev)
{
	if( pinyinHash != NULL)
	{
		return;
	}
	DEBUG_TIME_BEGIN();
	DEBUG_TIME_DUR_BEGIN();	
	uint32_t i = 0,_count	=	0;
	gushort * _collate;	

	_count	=	mh_dev_get_dictionay_count();

	g_message("%s-->count=%d", __func__, _count);
	char * _p;
	gushort * _key;
	pinyin_initial * _value;

	pinyinHash	=	g_hash_table_new_full( g_ushort_hash, g_ushort_equal, g_hash_destroy_key, g_hash_destroy_value);

	for(i; i < _count; i++)
	{
//		g_message("dictionary--->%d--->%s", i, dictionary[i].pinyin);
		_p	=	g_strdup(dictionary[i].hanzi);
		int j=0;
		uint32_t _count	=	0;
		_collate	=	stringToCode( dev,_p, &_count);
		if( _collate!= NULL)
		{
			_key	=	g_new0(gushort, 1);
			*_key	=	_collate[0];
//			g_message("key=%p  *key=%x", _key, *_key);
			_value	=	(pinyin_initial *)g_new0( pinyin_initial, 1);
			_value->pinyin	=	g_strdup( dictionary[i].pinyin);
			_value->initial	=	g_strdup( dictionary[i].initial);
			_value->type	=	dictionary[i].type;
			
			g_hash_table_insert( pinyinHash, _key,  _value);
			
			g_free( _collate);
		}
		g_free( _p);
	}
//	g_hash_table_foreach( pinyinHash, foreashFunc, NULL);


	DEBUG_TIME_DUR_END();
	DEBUG_TIME_END();


}
char * stringGetPinYin( char * string)
{
	return NULL;


}
char * stringGetInitial( char * initial)
{
	return NULL;
	
}


gushort * stringToCode(MHDevStorage * dev,char * name, uint32_t * count )
{
//	g_message("%s--->%s", __func__, name);

	gchar _buf[512]	=	{ 0 };
	gchar _pinyin[512]	=	{ 0};
	gchar _initial[512]	=	{0};

	gchar * _out;

	gushort * _collate	=	NULL; 
	gushort * _res	=	NULL;

	gsize _insize, _outsize;
	const gchar *_p;
	_p	=	name;


	_insize	=	strlen( _p);

	_outsize	=	sizeof( _buf );
	
	_out	=	_buf;


	if( dev->conv == NULL )
	{
		dev->conv   =   g_iconv_open( "utf-16le", "utf-8" );
	}
	if( g_iconv( dev->conv, (char **)&_p, &_insize, &_out, &_outsize ) != -1 )
	{
//		g_message("_outsize=%d", 512-_outsize);

		_res	=	( gushort * )g_malloc0( sizeof( _buf ) - _outsize + 2 );
		*count	=	(sizeof(_buf) - _outsize) / 2;
		_collate = _res;
		int i = 0;
		for( i = 0; i < sizeof( _buf ) - _outsize; i += 2, _collate ++ )
		{
			* _collate	=	UniCode2Pinyin_Tbl[ ( guint8 )_buf[i + 1] << 8 | ( guint8 )_buf[ i ] ];
			
//			g_message("[%d]:%x", i, *_collate);

		}

		* _collate	=	0xFFFF;
	}
	else
	{
		perror( "string_orderByPinyin" );

	}
	return _res;

}
void _check_memory_database(MHDev * dev)
{
	g_message("%s", __func__);
	MHDevStorage * _storage	=	MH_DEV_STORAGE( dev);
	sqlite3_stmt * _stmt;
	char *_sql	=	g_strdup("select * from collection;");
	if( sqlite3_prepare_v2( _storage->db, _sql, -1, &_stmt, NULL)!= SQLITE_OK)
	{
		g_warning("sqlite3_prepare_v2:%s is err:%s", _sql, sqlite3_errmsg(_storage->db));
	}
	while( sqlite3_step( _stmt) == SQLITE_ROW)
	{
		int64_t node_id, type;
		const char * name, * pinyin, *initial;
		node_id	=	sqlite3_column_int64( _stmt, 0);
		name	=	sqlite3_column_text( _stmt, 1);
		type	=	sqlite3_column_int64( _stmt, 2);
		pinyin	=	sqlite3_column_text( _stmt, 3);
		initial	=	sqlite3_column_text( _stmt, 4);
		g_message("%lld, %lld, %s, %s, %s", node_id, type, name , pinyin, initial);
	}
	sqlite3_finalize( _stmt);

}
gpointer _create_memory_database( gpointer data)
{

	MHDevStorage * 	_storage	=	(MHDevStorage *)data;
	sqlite3_stmt * _stmt;
	MHStmt * _mhStmt = NULL;
	g_message("%s----->%s", __func__, MH_DEV(_storage)->serial);	
	int64_t _nodeId, _type;
	char * _name = NULL, * _pinyin = NULL, * _initial = NULL, *_p;
	char * _sql	=	g_strdup("create table collection(node_id INTEGER primary key,name TEXT,type INTEGER,pinyin TEXT,initial TEXT)");
	char * _sql2;// contents sql2;
	g_message("%s-->%s", __func__, _sql);

	gushort * _code  =   NULL;
	int i	=	0;
	pinyin_initial * _value;

	_create_dictionary( _storage);
	g_message("%s", __func__);
	DEBUG_TIME_BEGIN();
	DEBUG_TIME_DUR_BEGIN();	

	if(sqlite3_prepare_v2( _storage->db, _sql, -1, &_stmt, NULL) != SQLITE_OK)
	{
		g_warning("sqlite3_prepare_v2 %s is err:%s\n", _sql, sqlite3_errmsg(_storage->db));
	}
	int _sqliteRes	=	sqlite3_step( _stmt );

	sqlite3_finalize( _stmt);
	g_free( _sql);


	if(_sqliteRes != SQLITE_DONE)
	{
		g_warning("create table sqlite3_step is err\n");
		return NULL;
	}

	_sql	=	g_strdup("insert into collection values(?,?,?,?,?)"); 
	if( sqlite3_prepare_v2( _storage->db, _sql, -1, &_stmt, NULL )!= SQLITE_OK)
	{
		g_warning("sqlite3_prepare_v2 %s is err:%s\n", _sql, sqlite3_errmsg(_storage->db));
	}
	_sql2	=	g_strdup_printf("select node_id,name,type from node where device_id=%d and type!=0", MH_DEV(_storage)->uniqueId);
	_mhStmt	=	NULL;
	_mhStmt	=	mh_contents_prepare( _content, _sql2);
	if( _mhStmt	== 	NULL)
	{
		g_warning("mh_contents_prepare-->fail: %s", _sql2);
		g_free( _sql2);
		return NULL;
	}

	
	while( mh_contents_step( _content, _mhStmt, &_nodeId, &_name, &_type,NULL) == MH_CONTENTS_STEP_CONTINUE )
	{
		g_message("_node_id=%d, _name=%s, _type=%d", _nodeId, _name, _type);

		uint32_t _count	=	0;
		_code	=	stringToCode( _storage,_name, &_count);
		if( _code != NULL)
		{
			i	=	0;
			while( _code[i] != 0xFFFF)
			{
//				g_message("_code[%d]:%x", i, _code[i]);
				_value	=	g_hash_table_lookup( pinyinHash, &_code[i]);
				if( _value != NULL)
				{
//					g_message("_code-->%s, %s", _value->pinyin, _value->initial);
					if( _pinyin)
					{
						_p	=	_pinyin;

						_pinyin	=	g_strdup_printf("%s%s", _p, _value->pinyin);

						g_free( _p);
					}
					else
					{
						_pinyin	=	g_strdup_printf( _value->pinyin);
					}
					if( _initial)
					{
						_p	=	_initial;

						_initial	=	g_strdup_printf("%s%s", _p, _value->initial);

						g_free( _p);

					}
					else
					{
						_initial	=	g_strdup( _value->initial);
					}
				}
				else
				{

				}


				i++;
			}
			g_free( _code);
		}
		sqlite3_reset( _stmt );
		g_message("sqlite3_bind:%lld, %s, %lld, %s, %s", _nodeId, _name, _type, _pinyin, _initial);
		sqlite3_bind_int64( _stmt, 1, _nodeId);
		sqlite3_bind_text ( _stmt, 2, _name, -1, NULL);
		sqlite3_bind_int64( _stmt, 3, _type);
		sqlite3_bind_text ( _stmt, 4, _pinyin, -1, NULL);
		sqlite3_bind_text ( _stmt, 5, _initial, -1, NULL);

		if( sqlite3_step( _stmt) != SQLITE_DONE)
		{
			g_warning("%s step failed:%s", __func__, sqlite3_errmsg( _storage->db));
		}

//		g_message("_pinyin:%s, _initial:%s", _pinyin, _initial);
		g_free(_pinyin);
		g_free( _initial);
		g_free( _name);
		_pinyin	=	NULL;
		_initial	=	NULL;
	}
	g_free( _sql2); // contents sql2;
	g_free( _sql);
	sqlite3_finalize( _stmt);
	DEBUG_TIME_DUR_END();
	DEBUG_TIME_END();
//_check_memory_database((MHDev *) data);
	return NULL;
}
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  start_scan
 *  Description:  
 * =====================================================================================
 */
static gboolean start_scan( gpointer user_data )
{	
	MHDev * _dev = ((scan_userdata *)user_data)->dev;
	g_message("%s", __func__);
	if(MH_DEV(_dev)->dev_status==false)
	{
		return FALSE;
	}

	if( scan_mutex == NULL)
	{
		scan_mutex	=	g_new0( GRecMutex, 1);
		g_rec_mutex_init( scan_mutex );
	}
	g_rec_mutex_lock( scan_mutex );
	if( user_data	==	NULL )
	{
		g_warning(" user_data is NULL");
		return	FALSE;
	}

	MHDevScanType type	=	((scan_userdata *)user_data)->type;

	g_free( user_data);

	MHDevStorage * _dev_storage	=	MH_DEV_STORAGE( _dev );
	MHFolder * _folder;	
	MHItem * _item;
	GSList * closure_list	=	NULL;
	int depth	=	0;
	MHFolder * _scan_folder;
	const char * _depth_str	=	getenv("MH_DEV_MAX_DEPTH");
	const char * _max_file_str	=	getenv("MH_DEV_MAX_FILE");
	const char * _max_folder_str	=	getenv("MH_DEV_MAX_FOLDER");

	_depth_str	=	_depth_str ? _depth_str : "8" ;
	max_depth	=	(guint)atoi( _depth_str);

	_dev_storage->file_count = 0;

	_max_file_str	=	_max_file_str ? _max_file_str : "0" ;
	max_file	=	(guint)atoi( _max_file_str );

	_max_folder_str	=	_max_folder_str ? _max_folder_str : "0" ;
	max_folder	=	(guint)atoi( _max_folder_str );
	_dev_storage->folder_count = 0;
	_content	=	mh_contents_instance();

	_dev_storage->indexer	=	(_dev_storage->indexer? _dev_storage->indexer :_create_indexer( _content,_dev, type));	

	_folder	=	_dev_storage->indexer;
	_item	=	MH_ITEM( _folder );

	mh_object_get_properties(( MHObject * )_dev, "root", &_scan_folder, NULL);

	DEBUG_TIME_BEGIN();
	DEBUG_TIME_DUR_BEGIN();	

	mh_contents_begin_transaction( _content);
	_dev_storage->first_music_flag	=	false;
	_dev_storage->first_video_flag	=	false;
	_dev_storage->first_picture_flag=	false;

	mh_storage_travel_folder(_dev_storage, _scan_folder, _dev_storage->indexer,_dev->uniqueId ,type,_item->uniqueId,&closure_list,depth);

	mh_contents_commit_transaction( _content );

	g_signal_emit_by_name(_dev, "dev_events", MH_DEV_FINISH, MH_ITEM_NONE, 0, 0);

	DEBUG_TIME_DUR_END();
	DEBUG_TIME_END();

	if( _dev_storage->memDbFlag	==	true)
	{
//		g_thread_new("memory_database", _create_memory_database, _dev_storage);
		if( _dev_storage->memDbExist == false)
		{
			_dev_storage->memDbExist	=	true;
			g_thread_new("memory_database", _create_memory_database, _dev_storage);

		}

	}
g_rec_mutex_unlock( scan_mutex );
	return	FALSE;
}		/* -----  end of static function start_scan  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _start_sync
 *  Description:
 * =====================================================================================
 */
static void _start_scan( MHDev * self, MHDevScanType type)
{
	self->scanType	=	type;
	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( MH_DEV_STORAGE(self) );
	GSource * _source	=	g_idle_source_new();
	scan_userdata * user_data	=	g_new( scan_userdata,1);
	user_data->dev	=	self;
	user_data->type	=	type;
	g_source_set_callback( _source, start_scan,(gpointer) user_data, NULL );
	g_source_attach( _source,_priv->scan_context);

//	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );

}      /* -----  end of static function _start_sync  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  scan_folder_first_file
 *  Description:  
 * =====================================================================================
 */
static bool scan_folder_first_file(MHDevStorage * self, MHFilter * filter, MHFolder * folder,
		MHDevSearchType type, MHFirstFileFunc func, void * user_data)
{
	int32_t _count=-1;
	MHItem ** _items;
	int i;
	GList * _list;
   	_items	=	mh_folder_get_children(folder, filter, FOLDER_BEGIN, &_count, MH_ITEM_ORDER_BY_DEFAULT);
	for( i=0; i < _count; i++)
	{
		g_message("_items[%d]:%s\n",i,_items[i]->name);
		if( _items[i]->type == MH_ITEM_FOLDER && type==DEPTH_FIRST )
		{
			scan_folder_first_file( self, filter, MH_FOLDER( _items[i]), type, func, user_data);
			break;
		

		}
		else if( _items[i]->type == MH_ITEM_FOLDER && type==BREADTH_FIRST)
		{
			_list	=	g_list_prepend( _list, _items[i]);
		}
		else if( _items[i]->type != MH_ITEM_FOLDER)
		{
			func(_items[i]->type, _items[i],user_data);
			mh_filter_del_data( filter, _items[i]->type);
			scan_folder_first_file(self, filter, folder, type,func,user_data);
	
			break;
		}
	}
	_list	=	g_list_reverse( _list );
	
	return 0;
}		/* -----  end of static function scan_folder_first_file  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _dev_detach
 *  Description:  
 * =====================================================================================
 */
static void _dev_detach( MHDev * self)
{
	self->dev_status	=	false;

}		/* -----  end of static function _dev_detach  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _core_events
 *  Description:  
 * =====================================================================================
 */
static void _core_events( MHCore * self, MHCoreEvent event,const char * type, void * user_data )
{
	g_return_if_fail( user_data !=	NULL);
	if( event	==	MH_CORE_STOPED)
	{
		MHDev * _dev	=	MH_DEV( user_data );
		_dev->dev_status	=	false;

	}
}		/* -----  end of static function _core_events  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_root
 *  Description:  
 * =====================================================================================
 */
static MHFolder * _get_root(MHDev * self)
{
	g_message("_get_root\n");
	MHDevStorage * _storage	=	MH_DEV_STORAGE( self );
	if( _storage->indexer!=NULL)
		return _storage->indexer;
	else
		return NULL; 
}		/* -----  end of static function _get_root  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _destroy
 *  Description:  
 * =====================================================================================
 */
static gboolean  _destroy( GNode * node, gpointer data)
{
	MHItem * _item	=(MHItem *)(node->data);
	g_object_unref( _item );
	return FALSE;
}		/* -----  end of static function _destroy  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  list_free
 *  Description:  
 * =====================================================================================
 */
static void list_free( gpointer data)
{
	devPartInfo * _info	=	(devPartInfo *)data;
	g_free( _info->devNode );
	g_free( _info->mountPath );
	g_free( _info );
}		/* -----  end of static function list_free  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _quit
 *  Description:  
 * =====================================================================================
 */
static gboolean _quit( gpointer object )
{
	g_message("%s",__func__);
	MHDevStorage * _self	=	MH_DEV_STORAGE( object );
	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( _self );
	MHDev * _dev	=	MH_DEV( _self);

	MHItem * _item;

	if( NULL != MH_DEV( _self )->serial)
	{
		g_free( MH_DEV( _self )->serial );
	}
	if( NULL != MH_DEV( _self )->entry)
	{
		g_free( MH_DEV( _self )->entry );
	}
	if( NULL != MH_DEV( _self )->vid)
	{
		g_free( MH_DEV( _self )->vid );
	}
	if( NULL != MH_DEV( _self )->pid)
	{
		g_free( MH_DEV( _self )->pid );
	}
	if( NULL != MH_DEV( _self )->type)
	{
		g_free( MH_DEV( _self )->type);
	}
	if( NULL != _self->fs_type)
	{
		g_free( _self->fs_type );
	}
	if( NULL != _self->bus)
	{
		g_free( _self->bus);
	}
	if( NULL != _self->dev_path)
	{
		g_free( _self->dev_path);
	}

	if( NULL != _self->conv)
	{
		g_iconv_close( _self->conv);
	}
	GNode * _n_root	=	NULL;
	GNode * _n_indexer	=	NULL;
	g_list_free_full( _self->mountList, list_free);
	g_hash_table_destroy( MH_DEV( _self )->itemsHash );
	if( _self->root	!=	NULL)
	{
	 	_n_root	=	MH_ITEM(_self->root)->node;
		g_message("_dispose-------------->root\n");
		g_node_traverse( _n_root, G_IN_ORDER, G_TRAVERSE_ALL, -1, _destroy, NULL);
		g_node_destroy( _n_root );
	}
	if(_self->indexer	!=	NULL)
	{
		_n_indexer	=	 MH_ITEM(_self->indexer)->node;
		g_message("_dispose-------------->indexer\n");
		g_node_traverse( _n_indexer, G_IN_ORDER, G_TRAVERSE_ALL, -1, _destroy, NULL);
		g_node_destroy( _n_indexer );
	}

	g_main_loop_quit( _priv->scan_mainloop );

	g_message("%s end",__func__);

	if( _self->memDbFlag = true)
	{
		sqlite3_close( _self->db);
	}

	return G_SOURCE_REMOVE;
}		/* -----  end of static function _quit  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispose
 *  Description:
 * =====================================================================================
 */
static void _dispose( GObject * object )
{
	g_message("%s",__func__);
	MHDevStorage * _self	=	MH_DEV_STORAGE( object );
	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( _self );
	if( g_thread_self() !=	_priv->scan_thread)
	{
		g_message("_dispose scan");
		if (NULL == _priv->scan_mainloop)
		{
			g_warning("%s already dispose and quit!", __func__);
			return;
		}
		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, _quit, object, NULL);

		g_source_attach( _source, _priv->scan_context );

		g_source_unref( _source );

		g_thread_join( _priv->scan_thread );

	}
	else
	{
		g_message("_dispose self");
		_quit( object );
	}
	
	g_main_context_unref( _priv->scan_context );
	
	g_message("_dispose end");
	G_OBJECT_CLASS( mh_dev_storage_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _finalize
 *  Description:
 * =====================================================================================
 */
static void _finalize( GObject * object )
{
	g_message("%s",__func__);
	MHDevStorage * _self	=	MH_DEV_STORAGE( object );
	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( _self );

	G_OBJECT_CLASS( mh_dev_storage_parent_class )->finalize( object );
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  scani_thread
 *  Description:  
 * =====================================================================================
 */
static gpointer scan_thread(const gpointer user_data)
{
	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( MH_DEV_STORAGE( user_data ));

//	g_main_context_push_thread_default( _priv->scan_context );

	g_main_loop_run( _priv->scan_mainloop );

	g_main_loop_unref( _priv->scan_mainloop );

	_priv->scan_mainloop = NULL;


	return NULL;
}		/* -----  end of static function scan thread  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  save_playlist
 *  Description:  
 * =====================================================================================
 */
static gboolean save_playlist( gpointer user_data )
{
	gint64 _playlist_id;
	GVariantBuilder * _builder;
	GVariant * _list, * _data;
	int i;
	gpointer * _user_data	=	(gpointer *) user_data;	
	MHDev * _dev	=	(MHDev *)(_user_data[0]);
	char * _name	=	(char *)(_user_data[1]);
	MHPlaylist * _playlist	=	(MHPlaylist*)(_user_data[2]);
	_builder	=	g_variant_builder_new( G_VARIANT_TYPE( "a(susxuv)" ));

	g_message("save_playlist cnt = %d", _playlist->array->len);
	for( i = 0; i < _playlist->array->len; i ++ )
	{
		MHItemData * _item	=	g_array_index( _playlist->array, MHItemData *, i );
		GVariant * _metadata;
		if( _item->type == MH_ITEM_MUSIC)
		{
			//g_message("%s[%s]title:%s, album:%s, artist:%s",__FILE__, __func__, _item->metadata.music.title, _item->metadata.music.album, 
			//		_item->metadata.music.artist);
			_metadata	=	g_variant_new("(sssssiiiii)",
					_item->metadata.music.title ? _item->metadata.music.title : "",
					_item->metadata.music.album ? _item->metadata.music.album : "",
					_item->metadata.music.artist ? _item->metadata.music.artist : "",
					_item->metadata.music.genre ? _item->metadata.music.genre : "",
					_item->metadata.music.composer ? _item->metadata.music.composer : "",
					_item->metadata.music.year, _item->metadata.music.track, _item->metadata.music.trackCount,
					_item->metadata.music.mediaType, _item->metadata.music.duration);
		}
		else
		{
			_metadata	=	g_variant_new_string("");
		}
		g_variant_builder_add( _builder, "(susxuv)", _item->uri, _item->type, _item->name, _item->uniqueId,_playlist->seq[i], _metadata );
	}

	_list	=	g_variant_builder_end( _builder );

	g_variant_builder_unref( _builder );

	_data	=	g_variant_new( "(vuuuuu)", _list, _playlist->index, _playlist->ptime, 
			_playlist->shuffle, _playlist->repeat, _playlist->error_count );
	
	MHContents * _contents	=	mh_contents_instance();
	
	_playlist_id	=	mh_contents_save_playlist( _contents, _dev, _name,_playlist->tag_id, (gpointer)g_variant_get_data( _data ), g_variant_get_size( _data ));

	g_variant_unref( _data );
	g_object_unref( _playlist );
	return FALSE;
}		/* -----  end of static function save_playlist  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _save_playlist
 *  Description:  
 * =====================================================================================
 */
static void _save_playlist( MHDev * self, const char * name, MHPlaylist * playlist )
{
	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private(MH_DEV_STORAGE( self));
	
	GSource * _source	=	g_idle_source_new();
	
	gpointer * user_data	=	g_malloc0( sizeof( gpointer )*3);
	MHPlaylist * _playlist	=	g_object_ref( playlist );
	if( _playlist == NULL)
	{
		return; 
	}
	user_data[0]	=	(gpointer)self;
	user_data[1] = (gpointer)g_strdup( name );
	user_data[2]  = (gpointer)_playlist;

	g_source_set_callback( _source, save_playlist, (gpointer)user_data, NULL);

	g_source_attach( _source, _priv->scan_context);
	
	g_source_unref( _source );
}		/* -----  end of static function _save_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  update_playlist
 *  Description:  
 * =====================================================================================
 */
static gboolean update_playlist( gpointer user_data)
{
	gint64 _playlist_id;
	GVariantBuilder * _builder;
	GVariant * _list, * _data;
	int i;
	gpointer * _user_data	=	(gpointer *) user_data;	
	MHContents * _contents	=	mh_contents_instance();

	MHDev * _dev	=	(MHDev *)(_user_data[0]);
	char * _name	=	(char *)(_user_data[1]);
	MHPlaylist * _playlist	=	(MHPlaylist*)(_user_data[2]);
	guint64 * _id	=	(guint64 *)( _user_data[3]);

	_builder	=	g_variant_builder_new( G_VARIANT_TYPE( "a(susxuv)" ));

	for( i = 0; i < _playlist->array->len; i ++ )
	{
		MHItemData * _item	=	g_array_index( _playlist->array, MHItemData *, i );
		GVariant * _metadata;
		if( _item->type == MH_ITEM_MUSIC)
		{
//		g_message("%s[%s]title:%s, album:%s, artist:%s",__FILE__, __func__, _item->metadata.music.title, _item->metadata.music.album, 
//					_item->metadata.music.artist);
			_metadata	=	g_variant_new("(sssssiiiii)",
					_item->metadata.music.title ? _item->metadata.music.title : "",
					_item->metadata.music.album ? _item->metadata.music.album : "",
					_item->metadata.music.artist ? _item->metadata.music.artist : "",
					_item->metadata.music.genre ? _item->metadata.music.genre : "",
					_item->metadata.music.composer ? _item->metadata.music.composer : "",
					_item->metadata.music.year, _item->metadata.music.track, _item->metadata.music.trackCount,
					_item->metadata.music.mediaType, _item->metadata.music.duration);
		}
		else
		{
			_metadata	=	g_variant_new_string("");
		}
		g_variant_builder_add( _builder, "(susxuv)", _item->uri, _item->type, _item->name,
				_item->uniqueId,_playlist->seq[i], _metadata );
	}

	_list	=	g_variant_builder_end( _builder );

	g_variant_builder_unref( _builder );

	_data	=	g_variant_new( "(vuuuuu)", _list, _playlist->index, _playlist->ptime, 
			_playlist->shuffle, _playlist->repeat , _playlist->error_count);
	mh_contents_update_playlist( _contents, _dev, *_id, _name, _playlist->tag_id, (gpointer)g_variant_get_data( _data ), g_variant_get_size( _data ));

	g_variant_unref( _data );

	g_object_unref( _playlist );

	return FALSE;
}		/* -----  end of static function update_playlist  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _updata_playlist
 *  Description:  
 * =====================================================================================
 */
static void _updata_playlist( MHDev * self, const char * name, MHPlaylist * playlist, gint64 playlist_id)
{
	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private(MH_DEV_STORAGE( self));

	MHPlaylist * _playlist	=	g_object_ref( playlist );	
	if( _playlist == 	NULL)
	{
		return;
	}
	GSource * _source	=	g_idle_source_new();
	
	gpointer * user_data	=	g_malloc0( sizeof( gpointer )*4);
	guint64	* _id	=	g_malloc0( sizeof( gint64 ));
	* _id	=	playlist_id;

	user_data[0]	=	(gpointer)self;
	user_data[1] = (gpointer)g_strdup( name );
	user_data[2]  = (gpointer)_playlist;
	user_data[3] = (gpointer)_id;

	g_source_set_callback( _source, update_playlist, (gpointer)user_data, NULL);

	g_source_attach( _source, _priv->scan_context);
	
	g_source_unref( _source );
}		/* -----  end of static function _updata_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_radiolist
 *  Description:  
 * =====================================================================================
 */
static char ** _get_radiolist( MHDev * self, int * count)
{
	printf("not use just for iap2  _get_radiolist test \n");
	char ** res;
	char a[]="123456";
	char b[]="abcd";
	char c[]="xyz";
	char *tmp1 = NULL;
	char *tmp2 = NULL;
	char *tmp3 = NULL;

	tmp1 = (char *)g_malloc0(strlen(a) + 1);
	tmp2 = (char *)g_malloc0(strlen(b) + 1);
	tmp3 = (char *)g_malloc0(strlen(c) + 1);
	strcpy(tmp1, a);
	strcpy(tmp2, b);
	strcpy(tmp3, c);
	
	res	= ( char ** )g_malloc0( 3 * sizeof( char * ) );
	res[0] = tmp1;
	res[1] = tmp2;	
	res[2] = tmp3;
	 * count = 3;
	return res;
}		/* -----  end of static function _get_radiolist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_detach_listener
 *  Description:  
 * =====================================================================================
 */
static uint32_t  _register_detach_listener(MHDev * self,MHDevDetachListener * listener )
{

	if( MH_DEV_STORAGE( self )->detachFlag == true)
	{
		listener->callback( self, listener->user_data);
	}
	else
	{
		g_signal_connect(self,"dev_detach",G_CALLBACK(listener->callback),listener->user_data);
	}

	return 0;
}		/* -----  end of static function _register_detach_listener  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_item_by_uri
 *  Description:  
 * =====================================================================================
 */
static MHItem * _get_item_by_uri( MHDev * dev, const char * uri)
{
	MHDevStorage * _storage	=	MH_DEV_STORAGE( dev );	
	char *_uri	=	g_strdup( uri );
	char * _pos1, * _pos2;
	
	MHItem * _item	=	NULL;
	MHFolder * _folder	=	_storage->indexer;
	if( _folder ==  NULL)
	{
		return NULL;
	}
	indexer_element_t * _element;
	_pos1	=	strstr(_uri, dev->entry);
	if( _pos1 != NULL)
	{
		if ((strlen( dev->entry ) == strlen( _pos1 )) ||
				((strlen( dev->entry )+1) == strlen( _pos1 )))
		{
			g_message("%s %s get root",__func__,_uri);
			return (MHItem *)_folder;
		}
		_pos1	=	_pos1 + strlen( dev->entry ) + 1 ;
		while( _pos1 != NULL)
		{
			_pos2	=	strstr( _pos1, "/");
			if( _pos2 != NULL)
			{
				*_pos2	=	'\0';
				_element	=	g_hash_table_lookup( _folder->hash, _pos1);
				if( _element != NULL)
				{
					_item	=	_element->item;
					_folder	=	MH_FOLDER(_item);
					_pos1	=	_pos2 + 1;
				}
				else
				{
					break;
				}
			}
			else
			{
				_element	=	g_hash_table_lookup( _folder->hash, _pos1);
				if( _element != NULL)
				{
					_item	=	_element->item;
				}
				break;
			

			}

		}
	}
	g_free( _uri );
	return _item;
}		/* -----  end of static function _get_item_by_uri  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  add_database_item
 *  Description:  
 * =====================================================================================
 */
static gboolean add_database_item( gpointer user_data )
{
	gpointer * _user_data	=	(gpointer *)user_data;
	MHDev * _dev	=	(MHDev *)_user_data[0];
	MHFolder * _folder	=	(MHFolder *)_user_data[1];
	MHItem * _item	=	(MHItem *)_user_data[2];
	gint64 * _ancestorList;
	uint32_t _ancestorCount;
	int i =0;
	_item->uniqueId	=	mh_contents_add_node( _content, _dev->uniqueId, _item);

	_ancestorList	=	mh_contents_get_ancestor( _content, MH_ITEM( _folder)->uniqueId, &_ancestorCount);

	for( i; i < _ancestorCount; i++)
	{
		mh_contents_add_closure( _content, _item->uniqueId, _ancestorList[i], MH_ITEM( _folder)->uniqueId, _dev->uniqueId);//del db by deviceId
	}
	if( _dev->scanType	==	SCAN_TAG)
	{
		switch( _item->type )
		{
			case MH_ITEM_MUSIC:
				mh_contents_add_music( _content, MH_MUSIC( _item), _dev->uniqueId);//del db by deviceId
				break;
			case MH_ITEM_MOVIE:
				mh_contents_add_movie( _content, MH_MOVIE(_item), _dev->uniqueId);//del db by deviceId
				break;
			case MH_ITEM_PICTURE:
				mh_contents_add_picture( _content, MH_PICTURE( _item), _dev->uniqueId);//del db by deviceId
				break;
			default:
				break;
		}
		_item->mediaId	=	_item->uniqueId;
	}
	g_hash_table_insert( _dev->itemsHash, &_item->uniqueId, _item);

	return	FALSE;
}		/* -----  end of static function add_database_item  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  delete_database_item
 *  Description:  
 * =====================================================================================
 */
static gboolean delete_database_item(gpointer user_data)
{
	MHItem * _item	=	(MHItem *)user_data;
	mh_contents_del_node(_content, _item);
	g_object_unref( _item );
	return	FALSE;
}		/* -----  end of static function delete_database_item  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _add_file
 *  Description:  
 * =====================================================================================
 */
static MHItem * _add_file( MHDev * dev, MHFolder * folder, MHItem * item)
{	
	g_return_val_if_fail( MH_IS_DEV(dev) && MH_IS_FOLDER( folder) && MH_IS_ITEM( item), NULL);
	indexer_element_t * _idx_element	=	NULL;
	int i = 0;
	_idx_element	=	(indexer_element_t*)g_hash_table_lookup(folder->hash, item->name);
	if( _idx_element != NULL)	
	{
		mh_dev_delete_file(dev, _idx_element->item);
	}
	MHItem * _item;
//	if( item->mediaId != 0)
//	{
		switch( item->type)
		{
			case MH_ITEM_MUSIC:
			{
				MHMusic * _music	=	g_object_new( MH_TYPE_MUSIC, NULL);
				_item	=	MH_ITEM( _music );	
				if( item->mediaId != 0)
				{
					_music->title	=	g_strdup( MH_MUSIC(item)->title ? MH_MUSIC(item)->title : "");
					_music->rating	=	MH_MUSIC( item)->rating;
					_music->duration	=	MH_MUSIC( item )->duration;
					_music->album_title	=	g_strdup( MH_MUSIC(item)->album_title ? MH_MUSIC(item)->album_title : "");
					_music->disc	=	MH_MUSIC( item)->disc;
					_music->disc_count	=	MH_MUSIC( item)->disc_count;
					_music->artist	=	g_strdup( MH_MUSIC(item)->artist ? MH_MUSIC(item)->artist : "");
					_music->album_artist	=	g_strdup( MH_MUSIC(item)->album_artist ? MH_MUSIC(item)->album_artist : "");
					_music->genre	=	g_strdup( MH_MUSIC(item)->genre ? MH_MUSIC(item)->genre : "");
					_music->composer	=	g_strdup( MH_MUSIC(item)->composer ? MH_MUSIC(item)->composer : "");
					_music->year	=	MH_MUSIC(item)->year;
					_music->album_compliation	=	MH_MUSIC(item)->album_compliation;
					_music->mediaType	=	MH_MUSIC(item)->mediaType;
					_music->last_chgtime	=	MH_MUSIC(item)->last_chgtime;//compare by lastchangtime 
				}
			}
			break;

			case MH_ITEM_MOVIE:
			{
				MHMovie * _movie	=	g_object_new( MH_TYPE_MOVIE, NULL);
				_item	=	MH_ITEM( _movie);
				if( item->mediaId != 0)
				{
					_movie->title	=	g_strdup( MH_MOVIE(item)->title ? MH_MOVIE( item)->title : "");
					_movie->year	=	MH_MOVIE( item )->year;
					_movie->director	=	g_strdup( MH_MOVIE(item)->director ? MH_MOVIE( item)->director : "");
					_movie->duration	=	MH_MOVIE( item )->duration;
					_movie->genre	=	g_strdup( MH_MOVIE(item)->genre ? MH_MOVIE( item)->genre : "");
					_movie->fps	=	MH_MOVIE( item )->fps;
					_movie->xres	=	MH_MOVIE( item )->xres;
					_movie->yres	=	MH_MOVIE( item )->yres;
					_movie->language	=	g_strdup( MH_MOVIE(item)->language ? MH_MOVIE( item)->language : "");
				}

			}
			break;

			case MH_ITEM_PICTURE:
			{
				MHPicture * _picture	=	g_object_new( MH_TYPE_PICTURE, NULL);
				_item	=	MH_ITEM( _picture );
				if( item->mediaId != 0)
				{
					_picture->format	=	g_strdup( MH_PICTURE( item )->format ? MH_PICTURE( item)->format : "");
					_picture->width		=	MH_PICTURE( item )->width;
					_picture->height	=	MH_PICTURE( item )->height;
					_picture->bpp		=	MH_PICTURE( item )->bpp;
				}

			}
			break;

			case MH_ITEM_FOLDER:
			{
				MHItem ** _items;
				int32_t _count;
				MHFilter * _filter	=	NULL;
				MHItemType _type;
				MHFolder * _folder	=	g_object_new( MH_TYPE_FOLDER, NULL);
				_item	=	MH_ITEM( _folder );
				_folder->music_count = MH_FOLDER( item )->music_count; 
				_folder->movie_count = MH_FOLDER( item )->movie_count;
				_folder->picture_count = MH_FOLDER( item )->picture_count;
				_folder->playlist_count = MH_FOLDER( item )->playlist_count;
				_folder->order = MH_FOLDER( item )->order;

				_item->name	=	g_strdup( item->name ? item->name : "");
				_item->size	=	item->size;
				_item->type	=	item->type;
				_item->valid	=	item->valid;
				_item->dev	=	dev;
				_item->uri	=	g_strdup_printf("%s/%s", MH_ITEM( folder)->uri, _item->name);
				_item->node	=	g_node_new( _item);
				g_node_append( MH_ITEM(folder)->node, _item->node);

				_idx_element	=	(indexer_element_t *)g_new( indexer_element_t, 1);
				_idx_element->item	=	_item;
				_idx_element->flag	=	TRUE;

				g_hash_table_insert( folder->hash, _item->name, _idx_element);

				mh_folder_add_type_count( folder, _item->type);
				MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( MH_DEV_STORAGE(dev));
				GSource	* _source	=	g_idle_source_new();
				gpointer * user_data	=	g_new( gpointer, 3);

				user_data[0]	=	(gpointer)dev;
				user_data[1]	=	(gpointer)folder;
				user_data[2]	=	(gpointer)_item;
				g_source_set_callback( _source, add_database_item, (gpointer)user_data, NULL);
				g_source_attach( _source, _priv->scan_context);
				g_source_unref( _source);

				_items	=	mh_folder_get_children(_folder, _filter, FOLDER_BEGIN, &_count, MH_ITEM_ORDER_BY_DEFAULT);
				for (i=0; i<_count; i++)
				{
					_type = _items[i]->type;
					switch( _type )
					{
						case MH_ITEM_FOLDER:
						case MH_ITEM_MUSIC:
						case MH_ITEM_MOVIE:
						case MH_ITEM_PICTURE:
							_add_file(dev, _folder, _items[i]);
							break;
					}
				}
			}
			break;

			default:
				g_warning(" the item type is error");
			break;
		}
//	}

		if (item->type != MH_ITEM_FOLDER)
		{
			_item->name	=	g_strdup( item->name ? item->name : "");
			_item->size	=	item->size;
			_item->type	=	item->type;
			_item->valid	=	item->valid;
			_item->dev	=	dev;
			_item->uri	=	g_strdup_printf("%s/%s", MH_ITEM( folder)->uri, _item->name);
			_item->node	=	g_node_new( _item);
			g_node_append( MH_ITEM(folder)->node, _item->node);

			_idx_element	=	(indexer_element_t *)g_new( indexer_element_t, 1);
			_idx_element->item	=	_item;
			_idx_element->flag	=	TRUE;

			g_hash_table_insert( folder->hash, _item->name, _idx_element);

			mh_folder_add_type_count( folder, _item->type);
			MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( MH_DEV_STORAGE(dev));
			GSource	* _source	=	g_idle_source_new();
			gpointer * user_data	=	g_new( gpointer, 3);

			user_data[0]	=	(gpointer)dev;
			user_data[1]	=	(gpointer)folder;
			user_data[2]	=	(gpointer)_item;
			g_source_set_callback( _source, add_database_item, (gpointer)user_data, NULL);
			g_source_attach( _source, _priv->scan_context);
			g_source_unref( _source);
		}
	return _item;
}		/* -----  end of static function _add_file  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _delete_file
 *  Description:  
 * =====================================================================================
 */
static MHResult _delete_file( MHDev * dev, MHItem * item)
{
	MHResult _res	=	MH_OK;
	MHFolder * _parent	=	(MHFolder *)(item->node->parent->data);
	int i = 0;
	switch( item->type)
	{
		case MH_ITEM_MUSIC:
		{
			mh_folder_del_type_count( _parent, MH_ITEM_MUSIC); 
		}
			break;
		case MH_ITEM_MOVIE:
		{
			mh_folder_del_type_count( _parent, MH_ITEM_MOVIE);
		}
			break;
		case MH_ITEM_PICTURE:
		{
			mh_folder_del_type_count( _parent, MH_ITEM_PICTURE );
		}
			break;
		case MH_ITEM_FOLDER:
			{
				MHItem ** _items;
				int32_t _count;
				MHFilter * _filter	=	NULL;
				MHItemType _type;
				_items	=	mh_folder_get_children(MH_FOLDER( item ), _filter, FOLDER_BEGIN, &_count, MH_ITEM_ORDER_BY_DEFAULT);
				for (i=0; i<_count; i++)
				{
					_type = _items[i]->type;
					switch( _type )
					{
						case MH_ITEM_FOLDER:
						case MH_ITEM_MUSIC:
						case MH_ITEM_MOVIE:
						case MH_ITEM_PICTURE:
							_delete_file(dev, _items[i]);
							break;
					}
				}
			}
			break;
		define:
			g_warning("the item type is error");
			break;
	}
	g_node_unlink( item->node);
	g_node_destroy( item->node);
	g_hash_table_remove( dev->itemsHash, &item->uniqueId);
	g_hash_table_remove( _parent->hash, &item->name);

	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( MH_DEV_STORAGE( dev));
	GSource * _source	=	g_idle_source_new();
	g_source_set_callback( _source, delete_database_item, (gpointer)item, NULL);
	g_source_attach( _source, _priv->scan_context);
	g_source_unref(_source);
	return _res;
	
}		/* -----  end of static function _delete_file  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_storage_init
 *  Description:
 * =====================================================================================
 */
static void mh_dev_storage_init( MHDevStorage * self )
{
//	g_message("%s---->self:%p", __func__, self);
	MHDevStoragePrivate * _priv	=	mh_dev_storage_get_instance_private( self );
	MHDev * _dev	=	MH_DEV( self );
	GError *_error = NULL;
	g_message("%s self = %p",__func__,self);
	_priv->scan_context	= g_main_context_new();
	_priv->scan_mainloop	= g_main_loop_new(_priv->scan_context, FALSE);
//	_priv->scan_thread	=	g_thread_new("scan", scan_thread,self);
	_priv->scan_thread	=	g_thread_try_new("scan", scan_thread,self, &_error);
	if( _error != NULL)
	{
		g_warning( "[%s] g_thread_try_new failed: [ %s ]", __func__, _error->message );
		g_error_free( _error );
	}

	self->bus	=	NULL;
	self->fs_type	=	NULL;
	self->root	=	NULL;
	self->indexer	=	NULL;
	self->dev_path	=	NULL;
//	self->dev_status	=	true;
//	_dev->type	=	"storage";
	self->first_music_flag	=	false;
	self->first_video_flag	=	false;
	self->first_picture_flag=	false;
	self->file_count	=	0;
	self->folder_count = 0;
	self->mount_count	=	0;
	self->total	=	0;
	self->free	=	0;
	self->partitionFlag	=	true;
	//	g_signal_connect( _dev, "dev_detach",G_CALLBACK( _dev_detach),NULL);
	self->detachFlag = false;
	self->attachFlag = false;
	self->entry_number	=	0;
	self->memDbFlag	=	false;
	self->memDbExist	=	false;
	self->db	=	NULL;
	self->conv	=	NULL;
	g_signal_connect( mh_core_instance(), "core_events", G_CALLBACK( _core_events), _dev);
	char * _env	=	getenv( "MH_DEV_MEMORY_DATABASE");
	if( _env != 	NULL)
	{
		self->memDbFlag	=	true;
		sqlite3_open(":memory:", &(self->db));
	}
}       /* -----  end of static function mh_dev_storage_init  ----- */

typedef enum _stringtype
{
	TYPE_NULL	=	-1,
	TYPE_HANZI	=	0,
	TYPE_PINYIN	=	1,
	TYPE_XING	=	2,
} stringtype;				/* ----------  end of enum stringtype  ---------- */
MHItem ** _get_item_from_memory_database( MHDev * dev, char * sql, gint * count)
{
	g_message("%s--->sql:%s", __func__, sql);
	MHDevStorage * _storage =	MH_DEV_STORAGE( dev);

	sqlite3_stmt * _stmt	=	NULL;

	MHItem * _item;
	MHItem ** _items; 
	int _offset	=	0;

	int _alloc	=	10;
	gint64 _node_id;

	_items	=	g_new0( MHItem *, _alloc);

	if( sqlite3_prepare_v2( _storage->db, sql, -1, &_stmt, NULL)!= SQLITE_OK)
	{
		g_warning("sqlite3_prepare_v2 %s is err:%s\n", sql, sqlite3_errmsg(_storage->db));
	}
	while( sqlite3_step( _stmt) == SQLITE_ROW)
	{
		if( _offset == _alloc)
		{
			_alloc	*= 2;
			_items	=	g_renew( MHItem *, _items, _alloc);
		}
		_node_id	=	sqlite3_column_int64( _stmt, 0);

		g_message("_node_id:%lld", _node_id);

		_item	=	g_hash_table_lookup(dev->itemsHash, &_node_id);

		if( _item == NULL)
		{
			g_warning("_node_id:%lld is not in itemsHash", _node_id);
		}
		else
		{
			_items[_offset]	= _item;
			_offset ++;
		}


	}
	if( _offset < _alloc)
	{
		_items[_offset]	=	NULL;
	}
	else 
	{
		_items	=	g_renew( MHItem *, _items, _offset + 1);
		_items[_offset]	=	NULL;
	}

	*count	=	_offset;
	if( SQLITE_OK != sqlite3_finalize( _stmt) )
	{

		g_warning("sqlite3_finalize %s is err:%s\n", sql, sqlite3_errmsg(_storage->db));
	}
	return _items;

}
char * _handle_separator( char * pinyin, char * string)
{

	char * _tmp	=	string;
	if( g_strcmp0( pinyin, "*") == 0)
	{
		if( string	==	NULL)
		{
			string	= g_strdup("*");
		}
		else
		{
			string	=	g_strdup_printf("%s%s", _tmp, "*");
			g_free( _tmp);

		}
	}
	else 
	{
		if( string	==	NULL)
		{
			string	= g_strdup(" ");
			g_message("string:%s", string);

			g_message("string:%d", string[0]);
		}
		else
		{
			string	=	g_strdup_printf("%s%s", _tmp, " ");
			g_free( _tmp);

		}

	}
	return string;

}
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _dev_search_name
 *  Description:  
 * =====================================================================================
 */
MHItem ** _dev_search_name( MHDev * dev, MHItemType type, char * string, gint * count)
{
	g_message("dev_storage.c-->%s->type:%d, string:%s", __func__, type, string);

	*count	=	0;	
	gushort * _code;	
	int i = 0;
	char * _string	=	g_strdup( string);
	uint32_t _count	=	0;
	_code	=	stringToCode( MH_DEV_STORAGE( dev),string, &_count);	
	g_message("_count:%d", _count);
	pinyin_initial * _value	=	NULL;;
	stringtype _type[2]	= {TYPE_NULL, TYPE_NULL};
//	int _separator[2]={-1, -1}; //0:*, 1:
	char * _separator[2]	=	{NULL, NULL};
	g_message("type:%d %d %d ", _type[0], _type[1]);
	int y	=	0;
	bool _valid	=	true;

	char * _sql	=	NULL;
	sqlite3_stmt * _stmt	=	NULL;

	MHItem ** _items	=	NULL;
	MHPlaylist * _playlist	=	NULL;

	_playlist	=	g_object_new( MH_TYPE_PLAYLIST, NULL);

	MHDevStorage * _storage	=	MH_DEV_STORAGE( dev);
	int _lastType	=	-1;
	char * _prefix	=	NULL;
	char * _name = NULL, * _pinyin = NULL, *_initial = NULL, * _name2 = NULL;
	uint32_t _sep0Len = 0, _sep1Len = 0, _prefixLen = 0;
	char * _sep0Pos	=	NULL, *_sep1Pos	=	NULL;
	if( _code != NULL && _count > 0)
	{
		for( i; i < _count; i++)
		{
			_value	=	g_hash_table_lookup( pinyinHash, &_code[i]);

			if( _value == NULL || _value->type	== 3)
			{
				goto exit;
				break;
			}
			g_message("_code[%d]:%x, type:%d", i, _code[i], _value->type);

			if( y == 0)
			{
				if(_type[0] == TYPE_NULL)
				{
					if( _value->type == 2)
					{
						_prefix	=	_handle_separator( _value->pinyin, _prefix);
					
					}
					else
					{
						_type[0]	=	_value->type;
					}
				}
				if( _type[0]	==	TYPE_HANZI)
				{
					if( _value->type == 0)
					{

					}
					else if( _value->type == 1)
					{

					}
					else if( _value->type ==  2)
					{
						_separator[0] = _handle_separator( _value->pinyin, _separator[0]);
						g_message("_separator[0]:%s", _separator[0]);
						y	=	1;

					}
				}
				if( _type[0]	==	TYPE_PINYIN)
				{
					if( _value->type == 0)
					{
						_type[0]	==	TYPE_HANZI;

					}
					else if( _value->type == 1)
					{

					}
					else if( _value->type ==  2)
					{
						_separator[0] = _handle_separator( _value->pinyin, _separator[0]);
						y	=	1;

					}
				}


			}
			else if( y == 1)
			{
				if( _type[1] == TYPE_NULL)
				{
					if( _value->type == 2)
					{
						_separator[0]	=	_handle_separator( _value->pinyin, _separator[0]);
					
					}
					else
					{
						_type[1]	=	_value->type;
					}

				}
				else if( _type[1] ==	TYPE_HANZI)
				{
					if( _value->type == 0)
					{

					}
					else if( _value->type == 1)
					{

					}
					else if( _value->type ==  2)
					{
						_separator[1] = _handle_separator( _value->pinyin, _separator[1]);
						y	=	2;
						break;

					}


				}
				else if( _type[1]	==	TYPE_PINYIN)
				{
					if( _value->type == 0)
					{
						_type[0]	==	TYPE_HANZI;

					}
					else if( _value->type == 1)
					{

					}
					else if( _value->type ==  2)
					{
						_separator[1] = _handle_separator( _value->pinyin, _separator[1]);
						y	=	2;
						break;
					}


				} // else if( _type[1]   ==  TYPE_PINYIN)

			}//else if( y == 1)
		}//for( i; i < _count; i++)
	}
	if( _type[0] == -1)
	{
		g_message("_type[0] == -1");
		goto exit;
	}
	else if( _type[0] == 0 && _type[1] == -1)
	{	
		if( _prefix != NULL )
		{
			if( _separator[0] == NULL)
			{
				g_message("_prefix:%s", _prefix);

				_name	=	g_strdup( _string + strlen( _prefix));
	
			}
			else 
			{
				g_message("prefix = %s, _separator[0]:%s", _prefix, _separator[0]);
				_name =	g_strndup( _string + strlen( _prefix), strlen( _string) - strlen( _prefix) -strlen( _separator[0]));
			
			}
		}
		else
		{
			if( _separator[0] == NULL)
			{
				_name	=	g_strdup( _string);

			}
			else 
			{
				_name	=	g_strndup( _string, strlen( _string) - strlen( _separator[0]));
			}
		}
		g_message("_name:%s", _name);

		_sql	=	g_strdup_printf("select node_id from collection where type=%d and name like '%%%s%%'", type,_name);

		_items	=	_get_item_from_memory_database( dev, _sql, count);

		g_free( _name);

		g_free( _sql);

	}
	else if( _type[0] == 0 && _type[1] == 0)
	{
		_sep0Len	=	strlen( _separator[0]);

		if( _prefix != NULL)
		{
			_prefixLen	=	strlen( _prefix);
		}
		else
		{
			_prefixLen	=	0;
		}
		g_message("_string:%s, _separator[0]:%s _separator[0]:%d",_string, _separator[0], _separator[0][0]);
		g_message("_sep0Len:%d", _sep0Len);
		_sep0Pos	=	g_strstr_len( _string + _prefixLen, -1, _separator[0]);	
		if( _sep0Pos != NULL)
		{
			_name	=	g_strndup( _string + _prefixLen, _sep0Pos - _string - _prefixLen);

			if( _separator[1] != NULL)
			{
				_sep1Pos	=	g_strstr_len( _sep0Pos + _sep0Len,  -1, _separator[1]);
				g_message("_sep0Pos:%s, _separator[1]:%s", _sep0Pos, _separator[1]);

				if( _sep1Pos != NULL)
				{
					_name2	=	g_strndup( _sep0Pos + _sep0Len, _sep1Pos - _sep0Pos - _sep0Len);
				}
				else
				{
					g_warning("_separator[1] != NULL, no _separator[1]");
					g_message("_sep0Pos:%s, _sep0Pos+_sep0Len:%s, _separator[1]:%s", _sep0Pos, _sep0Pos + _sep0Len, _separator[1]);
				}
			}
			else
			{
				_name2	=	g_strdup( _sep0Pos + _sep0Len);
			}

			_sql	=	g_strdup_printf("select node_id from collection where type=%d and (name like '%%%s%%' or name like '%%%s%%')", type,_name,  _name2);

			_items	=	_get_item_from_memory_database( dev, _sql, count);

			g_free( _name);

			g_free( _sql);

		}
		else
		{	
			g_warning("_separator[1]!= NULL, no _separator[0]");
		}

	}
	else if( _type[0] == 0 && _type[1]	==	1)
	{
		g_message("not support hanzi * pinyin");

	}
	else if( _type[0] == 1 && _type[1] == -1)
	{
		if( _prefix != NULL )
		{
			_prefixLen	=	strlen( _prefix);
		}
		else
		{
			_prefixLen	=	0;
		}
		if( _separator[0] != NULL)
		{
			_sep0Pos	=	g_strstr_len( _string + _prefixLen, -1, _separator[0]);	

			_pinyin	=	g_strndup( _string + _prefixLen, _sep0Pos - _string - _prefixLen);

		}
		else
		{
			_pinyin	=	g_strdup( _string + _prefixLen);
		}
		g_message("_pinyin:%s", _pinyin);

		_sql	=	g_strdup_printf("select node_id from collection where type=%d and (pinyin like '%%%s%%' or initial like '%%%s%%')", type,_pinyin, _pinyin);

		_items	=	_get_item_from_memory_database( dev, _sql, count);

		g_free( _pinyin);

		g_free( _sql);

	}
	else if( _type[0] == 1 && _type[1] == 0)
	{
		g_message("not support pinyin * hanzi");

	}
	else if( _type[0] == 1 && _type[1]	==	1)
	{
		g_message("not support pinyin * pinyin");

	}
	
		
exit:
	g_free( _code);
	if( _separator[0] != NULL)
	{
		g_free( _separator[0]);
	}
	if( _separator[1] != NULL)	
	{
		g_free( _separator[1]);
	}
	return _items;

}		/* -----  end of function _dev_search_name  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_storage_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_dev_storage_class_init( MHDevStorageClass * klass )
{
	MHDevClass * _parentClass	=	MH_DEV_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	_dispose;
	_gobjectClass->finalize	=	_finalize;
	_gobjectClass->set_property =   _set_property;
	_gobjectClass->get_property =   _get_property;

	/* assemble ios of mh_dev_storage class */

	/* assemble methods of mh_dev_storage class */
	_parentClass->play_by_list	=	_play_by_list;
	_parentClass->play_radio_by_index	=	_play_radio_by_index;
	_parentClass->stop	=	_stop;
	_parentClass->close=	_close;
	_parentClass->play	=	_play;
	_parentClass->pause	=	_pause;
	_parentClass->play_pause	=	_play_pause;
	_parentClass->resume	=	_resume;
	_parentClass->forward	=	_forward;
	_parentClass->forward_done	=	_forward_done;
	_parentClass->backward	=	_backward;
	_parentClass->backward_done	=	_backward_done;
	_parentClass->set_index	=	_set_index;
	_parentClass->set_speed	=	_set_speed;
	_parentClass->set_repeat	=	_set_repeat;
	_parentClass->set_shuffle	=	_set_shuffle;
	_parentClass->set_rate	=	_set_rate;
	_parentClass->set_buffer_time	=	_set_buffer_time;
	_parentClass->start_scan	=	_start_scan;
	_parentClass->next	=	_next;
	_parentClass->previous	=	_previous;

	_parentClass->get_root	=	_get_root;
	_parentClass->seek 	= 	_seek;	
	_parentClass->playlist_change 	= 	_playlist_change;	
	_parentClass->resize 	= 	_resize;
	_parentClass->pixel_aspect_ratio 	= 	_pixel_aspect_ratio;
	_parentClass->set_video_sink	=	_set_video_sink;
	_parentClass->set_media_info	=	_set_media_info;

	_parentClass->save_playlist		=	_save_playlist;
	_parentClass->update_playlist	=	_updata_playlist;
	_parentClass->get_radiolist	= 	_get_radiolist;
	_parentClass->register_detach_listener	=	_register_detach_listener;

	_parentClass->get_item_by_uri	=	_get_item_by_uri;
	_parentClass->add_file	=	_add_file;
	_parentClass->delete_file	=	_delete_file;
	_parentClass->search_name	=	_dev_search_name;
	devStroageProperties[ PROP_DEV_STORAGE_FS_TYPE ]    =
		g_param_spec_string( "fs_type", "MHDevStorage's property", "File system type of storage device",
				"", G_PARAM_READABLE );

	devStroageProperties[ PROP_DEV_STORAGE_ROOT ] =
		g_param_spec_pointer( "root", "MHDevStorage's property", "Root folder of storage device",
				G_PARAM_READABLE );

	devStroageProperties[ PROP_DEV_STORAGE_FILTER ] =
		g_param_spec_string( "filter", "MHDevStorage's property", "filter of storage device",
			    "",G_PARAM_READWRITE );

	devStroageProperties[ PROP_DEV_STORAGE_HASH_TABLE ] =
		g_param_spec_pointer( "hash", "MHDevStorage's property", "hash table of storage device",
				G_PARAM_READABLE );
	devStroageProperties[ PROP_DEV_STORAGE_INDEXER] =
		g_param_spec_pointer( "base", "MHDevStorage's property", "Root folder of storage indexer",
				G_PARAM_READABLE );
	devStroageProperties[ PROP_DEV_STORAGE_TOTAL_SIZE] = 
		g_param_spec_uint64( "total", "MHDevStorage's property", " total_size of storage device",
				0, G_MAXUINT64, 0, G_PARAM_READABLE);
	devStroageProperties[ PROP_DEV_STORAGE_FREE_SIZE] = 
		g_param_spec_uint64( "free", "MHDevStorage's property", " free_size of storage device",
				0, G_MAXUINT64, 0, G_PARAM_READABLE);
	devStroageProperties[ PROP_DEV_STORAGE_BUS] = 
		g_param_spec_string( "bus", "MHDevStorage's property", "the bus of storage device",
				"", G_PARAM_READABLE);

	devStroageProperties[ PROP_DEV_STORAGE_ENTRY_NUMBER] =
		g_param_spec_uint( "entry_number", "MHDevStorage's property", "entry number of storage",
				0, G_MAXUINT, 0, G_PARAM_READABLE );

	devStroageProperties[ PROP_DEV_STORAGE_FILE_COUNT] =
		g_param_spec_uint( "file_count", "MHDevStorage's property", "file count of storage",
				0, G_MAXUINT, 0, G_PARAM_READABLE );

	g_object_class_install_properties( _gobjectClass, N_PROPERTIES, devStroageProperties );
	const char * _error_timeout_str = getenv("MH_ERROR_TIMEOUT");
	_error_timeout_str = _error_timeout_str ? _error_timeout_str : "2000";
	error_timeout_num = (guint)atoi(_error_timeout_str);
	g_message("================================> error_timeout_num = %d",error_timeout_num);
	/* Ios */
	/* Signals */
}       /* -----  end of static function mh_dev_storage_class_init  ----- */

 
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  fun_delete
 *  Description:  
 * =====================================================================================
 */
static gboolean fun_delete(gpointer key, gpointer value, gpointer user_data)
{

	gboolean _res	=	TRUE;


	MHDevStorage * _dev	=	(MHDevStorage *)user_data;
	indexer_element_t * _element	=	(indexer_element_t *)value;
	char * _sql1;
	char * _sql2;
	char * _sql3;
 	static MHStmt * _stmt1	=	NULL;
	static MHStmt * _stmt2	=	NULL;
	static MHStmt * _stmt3	=	NULL;
	gint64 _node_id;
	int i;
	MHItem * _item;
	int _alloc	=	2;
	int _count	=	0;
	gint64 * _list;
	if(_element->flag	==	FALSE)
	{

		if( MH_DEV(_dev)->dev_status	==	false)
		{
			_res	=	FALSE;
			return _res;
		}
		_item	=	g_hash_table_lookup( MH_DEV(_dev)->itemsHash, & _element->item->uniqueId);
		if( _item->type	==	MH_ITEM_FOLDER)
		{
			if( MH_FOLDER( _item )->music_count != 0)
			{
				mh_folder_del_type_count( (MHFolder *)(_item->node->parent->data), MH_ITEM_MUSIC);
			}
			if( MH_FOLDER( _item )->movie_count != 0)
			{
				mh_folder_del_type_count( (MHFolder *)(_item->node->parent->data), MH_ITEM_MOVIE);
			}
			if( MH_FOLDER( _item )->picture_count != 0)
			{
				mh_folder_del_type_count( (MHFolder *)(_item->node->parent->data), MH_ITEM_PICTURE);
			}
			if( MH_FOLDER( _item )->playlist_count != 0)
			{
				mh_folder_del_type_count( (MHFolder *)(_item->node->parent->data), MH_ITEM_PLAYLIST);
			}

			_list	=	mh_contents_get_descendant( _content, _element->item->uniqueId, & _count);
			

		}
		else if( _item->type	==	MH_ITEM_MUSIC )
		{
			mh_folder_del_type_count( (MHFolder *)(_item->node->parent->data), MH_ITEM_MUSIC);
		}
		else if( _item->type	==	MH_ITEM_MOVIE )
		{
			mh_folder_del_type_count( (MHFolder *)(_item->node->parent->data), MH_ITEM_MOVIE);
		}
		else if( _item->type	==	MH_ITEM_PICTURE)
		{
			mh_folder_del_type_count( (MHFolder *)(_item->node->parent->data), MH_ITEM_PICTURE);
		}
		else if( _item->type	==	MH_ITEM_PLAYLIST)
		{
			mh_folder_del_type_count( (MHFolder *)(_item->node->parent->data), MH_ITEM_PLAYLIST);

		}
		g_node_unlink( _item->node );
		g_node_destroy( _item->node );


		mh_contents_del_node( _content, _element->item);
		if( _count == 0)
		{

			g_hash_table_remove( MH_DEV(_dev)->itemsHash, & _element->item->uniqueId );
			
			g_object_unref( _item );

		}
		else
		{
			for( i = 0; i < _count; i++)	
			{
				_item	=	g_hash_table_lookup( MH_DEV(_dev)->itemsHash, & _list[i]);

				g_hash_table_remove( MH_DEV(_dev)->itemsHash, &_list[i] );
			
				g_object_unref( _item );
			}
		}

	}
	else
	{
		_res	=	FALSE;
	}


	return _res;

}		/* -----  end of static function fun_delete  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_storage_travel_folder
 *  Description:  
 * =====================================================================================
 */
#define FIRST_MUSIC	  (0x0001u)
#define FIRST_MOVIE   (0x0002u)
#define FIRST_PICTURE (0x0004u)
static void mh_storage_travel_folder(MHDevStorage * dev, MHFolder * folder, 
		MHFolder * indexer_folder, gint64 device_id, MHDevScanType type ,gint64 parent, GSList ** closure_list,int depth)
{
	MHItem ** _items;
	int32_t _count	;
	int i,j ;
	MHItemType _type;
	MHFolder * _folder;
	MHMusic * _music;
	MHMovie * _movie;
	MHPicture * _picture;
	MHItem * _playlist;
	MHItem * _item;
	indexer_element_t * _idx_element;

	MHFolder * _indexer_folder;
	MHMusic * _indexer_music;
	MHMovie * _indexer_movie;
	MHPicture * _indexer_picture;
	MHItem * _indexer_playlist;
	MHItem * _indexer_item;

	GSList * _folder_list=NULL;
	GSList * _element;
	list_data * _ldata;
	GNode * _node;
    uint32_t _first_file	=	0;
	guint64 * _node_id;
	GSList * _list;
	bool _res	=	true;
	uint32_t folderFlag = 0;
	struct stat statBuf;

	if(depth   > 	max_depth)
	{
		g_warning("the depth > MAX_DEPTH\n");
		return;
	}
	if( max_file != 0 && dev->file_count > max_file)
	{
		g_warning("the file_number > MAX_FILE\n");
		return;
	}
	if(MH_DEV(dev)->dev_status==false)
	{
		return ;
	}
	_node_id	=	g_malloc0( sizeof(guint64) );
	*_node_id	=	MH_ITEM(indexer_folder)->uniqueId;
	*closure_list	=	g_slist_prepend( *closure_list, _node_id);

	_count	=	-1;
	MHFilter * _filter	=	NULL;
	if(folder == dev->root)
	{
		_items	=	mh_folder_get_children( folder, _filter, FOLDER_BEGIN, &_count, MH_ITEM_ORDER_BY_ALPHABET);
	}
	else
	{
		_items	=	mh_folder_get_children(folder,_filter, FOLDER_BEGIN, &_count, MH_ITEM_ORDER_BY_DEFAULT);
	}
	if(MH_DEV(dev)->dev_status==false)
	{
		return; 
	}

	for(i = 0; i < _count; i++)
	{
		folderFlag = 0;
//		g_message("i=%d, _count:%d, MH_DEV( dev)->dev_status:%d", i, _count, MH_DEV( dev)->dev_status );
		if(MH_DEV(dev)->dev_status==false)
		{
			return ;
		}
		
		if ( max_file != 0 && dev->file_count >= max_file)
		{
			g_warning("the file_number > MAX_FILE\n");
			_count	=	i;
			break;
		}
	
		_type	=	_items[i]->type;
		_idx_element	=	(indexer_element_t * )g_hash_table_lookup(indexer_folder->hash, _items[i]->name);
		if( _idx_element	==	NULL )
		{
			if( (_type	!=	MH_ITEM_FOLDER) && (type == SCAN_TAG) )
			{
				_res	=	mh_storage_analyze_taginfo( dev, _type, _items[i]);
			}
			if( _res	==	true )
			{
				_items[i]->uniqueId	=	mh_contents_add_node(_content, device_id, _items[i]);
		//		g_message("_items[%d]->uniqueId=%lld",i,_items[i]->uniqueId);
				for(_list = *closure_list; _list != NULL; _list	= _list->next)
				{
					if( _items[i]->uniqueId < *(guint64 *)_list->data)
					{
						g_message("mh_storage_travel_folder:%lld,%lld,%lld",(long long int)_items[i]->uniqueId,
								(long long int)*(guint64 *)_list->data, (long long int)parent);
					}
					mh_contents_add_closure(_content, _items[i]->uniqueId,*(guint64 *)_list->data,parent, device_id);//del db by deviceId
				}
		
			//	g_hash_table_insert( MH_DEV(dev)->itemsHash, &_items[i]->uniqueId, _items[i] );

				switch( _type )
				{
					case MH_ITEM_FOLDER:
						if(max_folder != 0 && dev->folder_count >= max_folder)
						{
							g_message("the folder_number > MAX_FILE");
							folderFlag = 1;
							break;
						}
							
						_folder	=	MH_FOLDER( _items[i]);
					
						_indexer_folder	=	g_object_new( MH_TYPE_FOLDER, NULL);
						_indexer_folder->scanned	=	true;
						_indexer_folder->hash	=	g_hash_table_new_full(g_str_hash, g_str_equal,NULL, hashValueDestroyFunc);

						_item	=	MH_ITEM( _indexer_folder );
						_ldata	=(list_data *)	g_new(list_data,1);
						_ldata->scan_folder	=	_folder;
						_ldata->indexer_folder	=	_indexer_folder;
						_folder_list	=	g_slist_append(_folder_list, _ldata);
						dev->folder_count++;
						break;

					case MH_ITEM_MUSIC:
						dev->file_count++;

						_music	=	MH_MUSIC( _items[i]);
						_indexer_music	=	g_object_new( MH_TYPE_MUSIC, NULL);
						_item	=	MH_ITEM( _indexer_music );
						if( type	==	SCAN_TAG )
						{

							mh_contents_add_music(_content, _music, device_id);//del db by deviceId
							_item->mediaId	=	_items[i]->uniqueId;
							_indexer_music->title	=	g_strdup(_music->title );
							_indexer_music->rating	=	_music->rating;
							_indexer_music->duration	=	_music->duration;
							_indexer_music->album_title	=	g_strdup( _music->album_title );
							_indexer_music->track	=	_music->track;
							_indexer_music->track_count	=	_music->track_count;
							_indexer_music->disc	=	_music->disc;
							_indexer_music->disc_count	=	_music->disc_count;
							_indexer_music->artist	=	g_strdup( _music->artist);
							_indexer_music->album_artist	=	g_strdup(_music->album_artist);
							_indexer_music->genre	=	g_strdup(_music->genre);
							_indexer_music->composer	=	g_strdup(_music->composer);
							_indexer_music->year	=	_music->year;
							_indexer_music->last_chgtime	=	_music->last_chgtime;
						}

								
						break;
					case MH_ITEM_MOVIE:
						dev->file_count++;

						_movie	=	MH_MOVIE( _items[i]);
						_indexer_movie	=	g_object_new( MH_TYPE_MOVIE, NULL);
						_item	=	MH_ITEM( _indexer_movie );
						if( type	==	SCAN_TAG )
						{
							mh_contents_add_movie(_content, _movie, device_id);//del db by deviceId
							_item->mediaId	=	_items[i]->uniqueId;
						}
						break;

					case MH_ITEM_PICTURE:
						dev->file_count++;

						_picture	=	MH_PICTURE( _items[i]);

						_indexer_picture	=	g_object_new( MH_TYPE_PICTURE, NULL);
						_item	=	MH_ITEM( _indexer_picture );
						if( type == SCAN_TAG )
						{
							mh_contents_add_picture(_content, _picture, device_id);//del db by deviceId
							_item->mediaId	=	_items[i]->uniqueId;
						}
	
						break;
					case MH_ITEM_PLAYLIST:
						_playlist	=	MH_ITEM( _items[i]);
						_indexer_playlist	=	g_object_new( MH_TYPE_PICTURE, NULL);
						_item	=	MH_ITEM( _indexer_playlist );
						break;	
					default:
						g_message("the _type is error\n");
						break;
				}
				if (folderFlag != 1)
				{
					_item->uniqueId	=	_items[i]->uniqueId;
					_item->name	=	g_strdup( _items[i]->name );
					_item->size	=	_items[i]->size;
					_item->type	=	_items[i]->type;
					_item->dev	=	_items[i]->dev;
					_item->uri	=	g_strdup( _items[i]->uri);
				
					_node	=	g_node_new( _item );
					_item->node	=	_node;
					g_node_append(MH_ITEM(indexer_folder)->node, _item->node );
					_idx_element	=(indexer_element_t *)g_new( indexer_element_t, 1);
					_idx_element->item	=	_item;
					_idx_element->flag	=	TRUE;
				
					g_hash_table_insert(indexer_folder->hash, _item->name, _idx_element);

					g_hash_table_insert( MH_DEV(dev)->itemsHash, &_item->uniqueId, _item);
					mh_folder_add_type_count( indexer_folder, _type);
				}
			}
		}

		 			
		else
		{
			_idx_element->flag	=	TRUE;
			
			if(_type	==	MH_ITEM_FOLDER)
			{
				if(max_folder !=0 && dev->folder_count >= max_folder)
				{
					g_message("the folder_number > MAX_FILE");
					folderFlag = 1;
				}
				else
				{
					_folder	=	MH_FOLDER( _items[i]);
						
					_indexer_folder	= MH_FOLDER( _idx_element->item );
					_ldata	=(list_data *)	g_new(list_data,1);
					_ldata->scan_folder	=	_folder;
					_ldata->indexer_folder	=	_indexer_folder;
					_folder_list	=	g_slist_append(_folder_list, _ldata);
					
					dev->folder_count++;
//					g_message("%s  %s [%d]", __func__, MH_ITEM( _folder )->uri, __LINE__);
				}
			}
			else if( _type	==	MH_ITEM_PLAYLIST)
			{

			}
			else
			{
				if( type == SCAN_TAG )
				{
					if( _idx_element->item->mediaId == 0)
					{
						//g_message("_idx_element->item->mediaId==0");
						mh_storage_analyze_taginfo( dev, _type, _idx_element->item);
						switch( _type )
						{
							case MH_ITEM_MUSIC:
								mh_contents_add_music( _content, MH_MUSIC( _idx_element->item), device_id);//del db by deviceId
								break;
							case MH_ITEM_MOVIE:
								mh_contents_add_movie( _content, MH_MOVIE( _idx_element->item), device_id);//del db by deviceId
								break;
							case MH_ITEM_PICTURE:
								mh_contents_add_picture( _content, MH_PICTURE( _idx_element->item), device_id);//del db by deviceId
								break;
							default:
								break;
						}

						_idx_element->item->mediaId	=	_idx_element->item->uniqueId;
					}
					else if( _type	==	MH_ITEM_MUSIC && MH_MUSIC(_idx_element->item)->duration == 0)
					{
						_music	= 	MH_MUSIC( _idx_element->item);
						mh_storage_analyze_taginfo( dev, _type, _idx_element->item);
						mh_contents_update_music( _content, _idx_element->item->uniqueId, MH_MUSIC( _idx_element->item));
					}
					else if( _type	==	MH_ITEM_MUSIC )
					{
						_music	= 	MH_MUSIC( _idx_element->item);
						memset(&statBuf, 0, sizeof(statBuf));
						
						if (0 == stat(_idx_element->item->uri, &statBuf))
						{
							//g_message("uri = %s time = %ld", _idx_element->item->uri, statBuf.st_mtime);
							if (statBuf.st_mtime != _music->last_chgtime)
							{
								g_message("uri = %s CurTime = %ld", _idx_element->item->uri, statBuf.st_mtime);
								mh_storage_analyze_taginfo( dev, _type, _idx_element->item);
								mh_contents_update_music( _content, _idx_element->item->uniqueId, MH_MUSIC( _idx_element->item));

							}
						}
					}
				}
				
				dev->file_count++;
			}
		}
		if( _type	==	MH_ITEM_MUSIC )
			_first_file	=	_first_file | FIRST_MUSIC;
		else if( _type	==	MH_ITEM_MOVIE )
			_first_file	=	_first_file | FIRST_MOVIE;
		else if( _type	==	MH_ITEM_PICTURE)
			_first_file	=	_first_file | FIRST_PICTURE;
		

	}
	g_free(_items);
	if(g_hash_table_size(indexer_folder->hash) != _count)
	{
		g_hash_table_foreach_steal(indexer_folder->hash, fun_delete, dev);
	}
	if( (_first_file & FIRST_MUSIC) && (dev->first_music_flag == false))
	{
		dev->first_music_flag	= true;
		g_signal_emit_by_name(dev, "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_MUSIC, indexer_folder, 0);
	}
	if( (_first_file & FIRST_MOVIE) && (dev->first_video_flag == false))
	{
		dev->first_video_flag	= true;
		g_signal_emit_by_name(dev, "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_MOVIE,indexer_folder, 0);
	}
	if( (_first_file & FIRST_PICTURE) && (dev->first_picture_flag == false))
	{
		dev->first_picture_flag	= true;
		g_signal_emit_by_name(dev, "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_PICTURE, indexer_folder, 0);

	}

//	if( indexer_folder->music_count != 0)
//		g_signal_emit_by_name(dev, "dev_events", MH_DEV_UPDATE_FILE, MH_ITEM_MUSIC, (guint)indexer_folder, 0);
//	if( indexer_folder->movie_count != 0)
//		g_signal_emit_by_name(dev, "dev_events", MH_DEV_UPDATE_FILE, MH_ITEM_MOVIE, (guint)indexer_folder, 0);
//	if( indexer_folder->picture_count != 0)
//		g_signal_emit_by_name(dev, "dev_events", MH_DEV_UPDATE_FILE, MH_ITEM_PICTURE, (guint)indexer_folder, 0);
//	if( indexer_folder->playlist_count != 0)
//		g_signal_emit_by_name(dev, "dev_events", MH_DEV_UPDATE_FILE, MH_ITEM_PLAYLIST, (guint)indexer_folder, 0);
//
//	g_signal_emit_by_name(dev, "dev_events", MH_DEV_UPDATE_FILE, MH_ITEM_NONE, (guint)indexer_folder, 0);

	_element	=	_folder_list;
	while(_element)
	{
		if(MH_DEV(dev)->dev_status==false)
		{
			break;
		}
		_ldata	=	(list_data *)_element->data;
		mh_storage_travel_folder(dev,_ldata->scan_folder,_ldata->indexer_folder,device_id,type,MH_ITEM(_ldata->indexer_folder)->uniqueId,closure_list,depth+1 );
		g_free( _element->data);
		_folder_list	=	g_slist_remove( _folder_list, _folder_list->data);
		_element	=	_folder_list;
	}
	
	g_free( _node_id);

	*closure_list	=	g_slist_remove( *closure_list, (*closure_list)->data);

}		/* -----  end of static function mh_folder_travel_dir  ----- */
bool is_magiced_by_c2c3(const char str[], uint32_t len)
{
	uint32_t i;
	if(len >= 2)
	{
		for(i = 0; i < len - 2; i++) 
		{
	
			if((uint8_t)str[i] < 0x7F) 
			{
			}
			else if((((uint8_t)str[i] == 0xC2U) || ((uint8_t)str[i] == 0xC3U))
					&& (((uint8_t)str[i + 2] == 0xC2U)|| ((uint8_t)str[i + 2] == 0xC3U)) )
			{
					return true;
			}
		}
	}
	return false;
}
static char * fix_c2c3_string( char * string )
{
	char * _revert	=	string;
	if(is_magiced_by_c2c3(string,strlen(string))== true)
	{
		_revert	=	g_convert( string, strlen( string ),  "iso-8859-1", "utf-8", NULL, NULL, NULL );

		g_free( string );
		if( _revert	!=	NULL )
		{
			if(g_utf8_validate(_revert, -1, NULL))
			{
			}
			else
			{
				iconv_t cd = iconv_open("utf-8", "gb18030");
				 if((iconv_t)-1 == cd)
				 {
					 printf("** Message: [%s : %d]-----iconv_open failed!!!!!\n","gststorage.c", __LINE__);
				 }
				 else
				 {
					 printf("** Message: [%s : %d]-----iconv_open success!!!!!\n","gststorage.c", __LINE__);
					 int _inbytes_left = strlen(_revert);
					 int _outbytes_left;
					 if(_inbytes_left < 128)
					 {
						 _outbytes_left = _inbytes_left * 2;
					 }
					 else
					 {
						 _outbytes_left = 256;
					 }
					 printf("** Message: [%s : %d]-----make iconv args!!!!![_inbytes_left=%d, _outbytes_left=%d]\n","gststorage.c", __LINE__, _inbytes_left, _outbytes_left);
					 gchar *_inbuf = _revert;
					 gchar *_outstr = g_malloc0(_outbytes_left);
					 gchar *_outbuf = _outstr;
					 int ret = iconv(cd, &_inbuf, &_inbytes_left, &_outbuf, &_outbytes_left);
					 if(-1 == ret)
					 {
						 printf("** Message: [%s : %d]-----iconv() failed!!!!![%s]\n","gststorage.c", __LINE__, strerror(errno));
						 g_free(_revert);
						 g_free(_outstr);
						 _revert = NULL;
						 _outstr = NULL;
					 }
					 else
					 {
						 printf("** Message: [%s : %d]-----iconv() success!!!!![%s]\n","gststorage.c", __LINE__, _outstr);
						 g_free(_revert);
						 _revert = _outstr;
						 iconv_close(cd);
					 }
				 }
			}
		}
	}
	return _revert;



}
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_storage_analyze_music
 *  Description:  
 * =====================================================================================
 */
static bool mh_storage_analyze_music(MHDevStorage * dev, MHMusic * music)
{
	g_message("-------------------------->mh_storage_analyze_music\n");
	MHItem * _item	=	MH_ITEM( music );
	gchar * _tag_uri	=	_item->uri;
	TagLib_File * _tag_file;
	TagLib_Tag * _tag;
//	const TagLib_AudioProperties * _properties;
	int _music_id;

	_tag_file	=	taglib_file_new( _tag_uri );
	if(_tag_file	==	NULL)
	{
		g_warning("_tag_file 	==	NULL\n");
		return false;
	}
	_tag	=	taglib_file_tag( _tag_file );
//	_properties	=	taglib_file_audioproperties( _tag_file );
	if(_tag !=	NULL)
	{

		 music->title	=	g_strdup( taglib_tag_title( _tag ));
		 music->artist	=	g_strdup( taglib_tag_artist( _tag ));
		 music->album_title	=	g_strdup( taglib_tag_album( _tag ));
		 music->year 	=	taglib_tag_year( _tag );
		 music->track	=	taglib_tag_track( _tag );
		 music->genre	=	g_strdup( taglib_tag_genre( _tag ));
	  	 music->rating	=	0;
		 music->title	=	fix_c2c3_string( music->title );
		 music->artist	=	fix_c2c3_string( music->artist );
		 music->album_title	=	fix_c2c3_string( music->album_title );
		 music->genre	=	fix_c2c3_string( music->genre );


	}
	else
	{
	
		g_message("_tag	==	NULL\n");

	}
	taglib_tag_free_strings();
	taglib_file_free( _tag_file );
	if(MH_DEV(dev)->dev_status==false)
	{
		return false;
	}
	return true;
//	g_free(_tag_uri);
}		/* -----  end of static function mh_storage_analyze_music  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_storage_analyze_movie
 *  Description:  
 * =====================================================================================
 */
static void mh_storage_analyze_movie(MHDevStorage * dev, MHMovie * movie)
{
	movie->title	=	g_strdup(  MH_ITEM( movie )->name );
	movie->director	=	g_strdup("unknown");
	movie->language	=	g_strdup("unknown");
//	return 0;
}		/* -----  end of static function mh_storage_analyze_movie  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_storage_analyze_picture
 *  Description:  
 * =====================================================================================
 */
static void mh_storage_analyze_picture(MHDevStorage * dev, MHPicture * picture)
{
//	return 0;
}		/* -----  end of static function mh_storage_analyze_picture  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_storage_analyze_taginfo
 *  Description:  
 * =====================================================================================
 */
static bool mh_storage_analyze_taginfo(MHDevStorage * dev, MHItemType type, MHItem * item)
{
	gchar * _tag_uri;
	TagLib_File * _tag_file;
	TagLib_Tag * _tag;
	MHMusic * _music;
	MHMovie * _movie;
	MHPlaylist * _playlist;
	const TagLib_AudioProperties * _properties;
	struct stat statBuf;
	
	switch( type )
	{
		case MH_ITEM_MUSIC:
			_music	=	MH_MUSIC( item );
			_tag_uri	=	item->uri;
			_tag_file	=	taglib_file_new( _tag_uri);
			if(_tag_file	==	NULL)
			{
				g_warning("_tag_file 	==	NULL\n");
				return false;
			}
			_tag	=	taglib_file_tag( _tag_file );
			_properties = taglib_file_audioproperties( _tag_file );
			if(_tag !=	NULL && _properties != NULL)
			{
				 _music->duration	=	taglib_audioproperties_length(_properties);
				 _music->title	=	g_strdup( taglib_tag_title( _tag ));
				 _music->artist	=	g_strdup( taglib_tag_artist( _tag ));
				 _music->album_title	=	g_strdup( taglib_tag_album( _tag ));
				 _music->year 	=	taglib_tag_year( _tag );
				 _music->track	=	taglib_tag_track( _tag );
				 _music->genre	=	g_strdup( taglib_tag_genre( _tag ));
				 _music->rating	=	0;
				 _music->title	=	fix_c2c3_string( _music->title );
				 _music->artist	=	fix_c2c3_string( _music->artist );
				 _music->album_title	=	fix_c2c3_string( _music->album_title );
				 _music->genre	=	fix_c2c3_string( _music->genre );

				memset(&statBuf, 0, sizeof(statBuf));
				if (0 == stat(_tag_uri, &statBuf))
				{
					//g_message("uri = %s time = %ld", _tag_uri, statBuf.st_mtime);
					_music->last_chgtime = statBuf.st_mtime;
				}
				 taglib_tag_free_strings();
				 taglib_file_free( _tag_file );

			}
			else
			{
				taglib_tag_free_strings();
				taglib_file_free( _tag_file );

				g_message("_tag	==	NULL or _properties == NULL\n");
				return false;

			}
//			taglib_tag_free_strings();
//			taglib_file_free( _tag_file );
			if(MH_DEV(dev)->dev_status==false)
			{
				return false;
			}
			break;

		case MH_ITEM_MOVIE:
			break;
		case MH_ITEM_PICTURE:
			break;
	}
	return true;

}		/* -----  end of static function mh_storage_analyze_taginfo  ----- */

