/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include <stdio.h>
#include <alsa/asoundlib.h>
#include "dev_iap2.h"
#include <iAP2ControlSession.h>
#include "iAP2FileSession.h"
#include <mh_core.h>
#include <mh_contents.h>
#include <mh_misc.h>
#include <mh_playlist.h>
#include <mh_pb.h>
#include <mh_player.h>
#include <iAP2Misc.h>
#include <string.h>
#include "iAP2Hid.h"
#include <iAP2Media.h>
#include <gst/gst.h>
#include <gst/app/gstappsrc.h>
#include "debug.h"
#include <mh_api.h>
extern gboolean eaNativeFlag;
typedef struct _MHDevIap2Private MHDevIap2Private;
extern iAP2PacketSYNData_t synParam;
extern bool ep2State;
#define MaxMusic 8180

struct _MHDevIap2Private
{
	gint dummy;

	uint64_t clock;
	uint64_t running;

	GMainLoop * mainloop;
	GMainContext * context;
	GSource * source;
	GThread * thread;

	uint32_t source_status;//0 stop 1 play	
};

G_DEFINE_TYPE_WITH_PRIVATE( MHDevIap2, mh_dev_iap2, MH_TYPE_DEV )

enum {
	/* Signals */
	EA_SESSION_START,
	EA_SESSION_STOP,
	EA_SESSION_DATA,

	START_LOCATION_INFO,
	STOP_LOCATION_INFO,

	START_VEHICLE_STATUS_UPDATES,
	STOP_VEHICLE_STATUS_UPDATES,

	BT_DATA,
	REQ_ACCESSORY_WIFI_CONF_INFO,
	WIFI_CARPLAY_UPDATE,

	EA_NATIVE_START,
	EA_NATIVE_STOP,
	EA_NATIVE_DATA,
	EA_SESSION_SEND_PB,

	N_SIGNALS
};

static guint signals[ N_SIGNALS ]	=	{ 0 };

//MHDevIap2 * iAP2Object = NULL;
extern GSList *gRadioList;

#if 1 //double iap2
GSList * _iAP2GlobalInfolist=NULL;
#endif
#define IAP2_PCM_LATENCY_US     (200000)                /*  latency in us      */
#define IAP2_PCM_CHANNEL_NUM    (2)                     /*  channel number     */
#define IAP2_PCM_BIT            (16)                    /*  PCM Bit Resolution */
#define IAP2_PCM_READ_FRAME_NUM (4800)                  
#define IAP2_PCM_FRAME_SIZE     (IAP2_PCM_CHANNEL_NUM * IAP2_PCM_BIT / 8)
#define IAP2_PCM_BUFFER_SIZE    (IAP2_PCM_FRAME_SIZE * IAP2_PCM_READ_FRAME_NUM * 4)

//static uint32_t	sample_rate	=	44100;

static guint8	iAP2_pcm_buffer[ IAP2_PCM_BUFFER_SIZE ];

#define IAP2_PCM_MAX_SOUND_CARD_COUNT	(16)
#define IAP2_PCM_IPOD_CARD_NAME			"iPod"
#define IAP2_PCM_IPAD_CARD_NAME			"iPad"
#define IAP2_PCM_IPHONE_CARD_NAME       "iPhone"
#define IAP2_PCM_CARD_NAME_LENGTH       (7)
#define IAP2_PCM_HOST_CARD_NAME       	"UAC"
#define IAP2_PCM_HOST_CARD_NAME_LENGTH  (3)

#define IAP2_PCM_OPEN_MAX_COUNT	(3)

#define IAP2_PCM_THROW_DATA_COUNT (2)

#define IAP2_NUM_ONE (1) 
#define IAP2_NUM_ZERO (0) 

static char	iAP2_pcm_card[16];

static snd_pcm_t	*	iAP2_pcm_handle	=	NULL;

static GPollFD alsaFd;

GstElement * appsrc = NULL; 

//static	GSource * fd_source = NULL;
GSource *  timeout_source = NULL;
#define IAP2_MEDIA_LIBRARY_UPDATE_TIMEOUT (10000)  

static uint32_t	throw_count	=	0;
static uint32_t	reset_count	=	0;
extern GRecMutex * loop_mutex_iAP2;
static	MHPbStatusEvent pipeline_status = READY_STATUS; 

GSource * timeout_Source = NULL;
typedef struct _timeoutparam 
{
	iAP2Timer_t* timer_t;
    iAP2TimeCB_t callback_t;
} timeoutparam;		

typedef struct
{
	iAP2LinkRunLoop_t* plinkRunLoop;
	void *arg;
}signalparam;

enum
{
	PROP_0,

	PROP_DEV_BT_IAP2_MAC,	
	PROP_DEV_EA_NATIVE_FLAG,

	N_PROPERTIES
};
static GParamSpec *deviAPProperties[ N_PROPERTIES ] = { NULL, };
//
//enum {
//	/* Ios */
//
//	/* Signals */
//
//	N_SIGNALS
//};
//
//static guint signals[ N_SIGNALS ] = {0};

static char ** _get_radiolist( MHDev * self, int * count);

static void _play_radio_by_index( MHDev * self, MHPb * pb, uint32_t index ) 
{
	gint _paramsLen =	4 + 8 + 5 + 8  + 4 +  MH_DEV_IAP2( self )->radioLibraryIdLen;
	guint8 * _params	=	g_malloc0( _paramsLen );
	int _offset =	0, i;
	gint64 _uid = 0;
	GSList *list = NULL;
	list = gRadioList;
	iAP2RadioPlayListInfo *pstRadioInfo = NULL;

	for(i = 0; i < index; i++)
	{
		if (list != NULL)
		{
			list = list->next;
		}
	}
	pstRadioInfo = (iAP2RadioPlayListInfo *)list->data;
	g_message("%s-----id:%d-----name:%d", __func__, pstRadioInfo->listId, pstRadioInfo->listName);
	_params[ _offset + 0 ]	=	IAP2_HI_BYTE( 4 + 8);
	_params[ _offset + 1 ]	=	IAP2_LO_BYTE( 4 + 8);
	_params[ _offset + 2 ]	=	0x00;
	_params[ _offset + 3 ]	=	0x00;
	_offset +=	4;


	_uid = pstRadioInfo->listId; 
	
	IAP2_MISC_WRITE_BIG64( _params + _offset, _uid );
	_offset +=	8;
	
	_params[ _offset + 0 ]	=	IAP2_HI_BYTE( 4 + 1);
	_params[ _offset + 1 ]	=	IAP2_LO_BYTE( 4 +1);
	_params[ _offset + 2 ]	=	0x00;
	_params[ _offset + 3 ]	=	0x01;
	_params[ _offset + 4 ]	=	0x00;
//	_params[ _offset + 5 ]	=	0x00;
	_offset +=	5;

	_params[ _offset + 0 ]	=	IAP2_HI_BYTE( 4 + 4);
	_params[ _offset + 1 ]	=	IAP2_LO_BYTE( 4 + 4);
	_params[ _offset + 2 ]	=	0x00;
	_params[ _offset + 3 ]	=	0x02;
	_params[ _offset + 4 ]	=	0x00;
	_params[ _offset + 5 ]	=	0x00;
	_params[ _offset + 6 ]	=	0x00;
	_params[ _offset + 7 ]	=	0x00;
	_offset +=	8;

	_params[ _offset + 0 ]	=	IAP2_HI_BYTE( 4 + MH_DEV_IAP2( self )->radioLibraryIdLen );
	_params[ _offset + 1 ]	=	IAP2_LO_BYTE( 4 + MH_DEV_IAP2( self )->radioLibraryIdLen );
	_params[ _offset + 2 ]	=	0x00;
	_params[ _offset + 3 ]	=	0x03;
	_offset +=	4;

	memcpy( _params + _offset, MH_DEV_IAP2( self )->radioLibraryId, MH_DEV_IAP2( self )->radioLibraryIdLen );

	iAP2SendControlMessage( MH_DEV_IAP2( self )->plinkRunLoop->link, 0x4C08, _params, _paramsLen, IAP2_CONTROL_SESSION_ID );

	g_free( _params );

}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  UpTicks
 *  Description:
 * =====================================================================================
 */
uint64_t UpTicks( void )
{
	uint64_t            nanos;
	struct timespec     ts;

	ts.tv_sec  = 0;
	ts.tv_nsec = 0;
	clock_gettime( CLOCK_MONOTONIC, &ts );
	nanos = ts.tv_sec;
	nanos *= 1000000000;
	nanos += ts.tv_nsec;
	return( nanos );
}		/*  -----  end of static function UpTicks  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pcm_data_callback
 *  Description:
 * =====================================================================================
 */
//gboolean  _pcm_data_callback( gpointer user_data )
//{
//	gint32 _size = -1;
//
//	if( iAP2_pcm_handle	!=	NULL )	
//	{
//		snd_pcm_sframes_t _avail;
//
//		_avail	=	 snd_pcm_avail( iAP2_pcm_handle );	
//	
//		_size = snd_pcm_readi( iAP2_pcm_handle, iAP2_pcm_buffer, _avail );	
//
//		if(( _size > 0 )&&( appsrc != NULL ))
//		{
//			GstBuffer * _buf;
//
//			GstFlowReturn _ret;
//
//			_buf	=	gst_buffer_new_and_alloc( _size * 4 );
//
//			memcpy( GST_BUFFER_DATA( _buf ), iAP2_pcm_buffer, _size * 4 );
//
//			GST_BUFFER_SIZE( _buf )	=	_size * 4;
//
//			g_signal_emit_by_name( appsrc, "push-buffer", _buf, &_ret );
//
//			gst_buffer_unref( _buf );
//		}else{
//			int ret;
//			snd_pcm_state_t state = 0;
//			g_message( "_pcm_data_callback, failed: %s\n",  snd_strerror( _size ));
//			ret = snd_pcm_recover(iAP2_pcm_handle, _size, 0);
//			if (ret < 0)
//			{
//				g_message("snd_pcm_recover failed! %s.\n", snd_strerror(ret));
//			}
//			else
//			{
//				state = snd_pcm_state(iAP2_pcm_handle);
//				if (state == SND_PCM_STATE_PREPARED)
//				{
//					ret = snd_pcm_start(iAP2_pcm_handle);
//					if (ret < 0)
//					{
//						g_message("snd_pcm_start Failed! %s\n", snd_strerror(ret));
//					}
//				}
//			}
//		}
//	}
//	return TRUE;
//}		/*  -----  end of static function _pcm_data_callback  ----- */

/*  
 * ===  FUNCTION  ======================================================================
 *         Name:  _prepare
 *  Description:  
 * =====================================================================================
 */
//static gboolean _prepare( GSource * source, gint * timeout )
//{
//	* timeout	=	-1;
//
//	return FALSE;
//}		/*  -----  end of static function _prepare  ----- */

/*  
 * ===  FUNCTION  ======================================================================
 *         Name:  _check
 *  Description:  
 * =====================================================================================
 */
//static gboolean _check( GSource * source )
//{
//	gboolean _ret	=	FALSE;
//
//	if(( alsaFd.revents != 0 )&&(( alsaFd.revents & POLLIN)== POLLIN))
//	{
//		_ret	=	TRUE;
//	}
//
//	return _ret;
//}		/*  -----  end of static function _check  ----- */
					
/*  
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispatch
 *  Description:  
 * =====================================================================================
 */
//static gboolean _dispatch( GSource * source, GSourceFunc callback, gpointer user_data )
//{
//	return _pcm_data_callback( user_data );
//}		/*  -----  end of static function _dispatch  ----- */

//static GSourceFuncs _funcs	=	
//{
//	.prepare	=	_prepare,
//	.check		=	_check,
//	.dispatch	=	_dispatch
//};

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  pushThread
 *  Description:  
 * =====================================================================================
 */
static gpointer pushThread( gpointer user_data )
{
	
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( MH_DEV_IAP2( user_data ) );

	g_main_context_push_thread_default( _priv->context );	

	g_main_loop_run( _priv->mainloop );

	g_main_loop_unref( _priv->mainloop );
	return NULL;
}		/* -----  end of static function pushThread  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  recover_start_snd
 *  Description:  
 * =====================================================================================
 */
static void recover_start_snd( gint32 size, MHDevIap2 * _iap2)
{
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _iap2 );

	pipeline_status = READY_STATUS;	
	g_source_set_ready_time( _priv->source, -1 );

	int ret;
	snd_pcm_state_t state = 0;
	g_message("snd Failed: %s\n",  snd_strerror( size ));
	static int retryCnt = 0;
	ret = snd_pcm_recover(iAP2_pcm_handle, size, 0);
	if (ret < 0)
	{
		g_message("snd_pcm_recover Failed: %s _priv->source_status = %d \n", snd_strerror(ret), _priv->source_status);
		if ( _priv->source_status	== IAP2_NUM_ONE && retryCnt < 10)
		{
			_priv->clock	=	UpTicks();
			g_source_set_ready_time( _priv->source, _priv->clock / 1000 );
			retryCnt++;
		}
		else
		{
			retryCnt = 0;
		}
	}
	else
	{
		retryCnt = 0;
		state = snd_pcm_state(iAP2_pcm_handle);
		if (state == SND_PCM_STATE_PREPARED)
		{
			ret = snd_pcm_start(iAP2_pcm_handle);
			if (ret < 0)
			{
				g_message("snd_pcm_start Failed: %s\n", snd_strerror(ret));
				_priv->clock	=	UpTicks();
				g_source_set_ready_time( _priv->source, _priv->clock / 1000 );
			}else{
				_priv->clock	=	UpTicks();
				g_source_set_ready_time( _priv->source, _priv->clock / 1000 );
			}
		}
	}
}		/* -----  end of static function recover_start_snd  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  pushDispatch
 *  Description:  
 * =====================================================================================
 */
static gboolean pushDispatch( GSource * source, GSourceFunc callback, gpointer user_data )
{
	MHPb * _pb	=	( MHPb * )user_data;
	MHDevIap2 * _iap2	=	MH_DEV_IAP2( _pb->mhDev );
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _iap2 );

	gint32 _size = -1;

	if( iAP2_pcm_handle	!=	NULL )
	{
		snd_pcm_sframes_t _avail;

		_avail	=	 snd_pcm_avail( iAP2_pcm_handle );	

//		g_message("_avail = [%d]",_avail);	
		if( _avail == 0 ) // if snd no data, set pipeline ready
		{
			if( pipeline_status == 	PLAY_STATUS )
			{
				g_message("avail is zero! set pipeline ready\n");
//				gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_READY );
				gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_NULL );
				gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_READY );
				pipeline_status = READY_STATUS;
			}
			_priv->clock	=	UpTicks() + 10000000;

			g_source_set_ready_time( _priv->source, _priv->clock / 1000 );

			return G_SOURCE_CONTINUE;
		}
		
		if( _avail < 0 )
		{
			gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_NULL );
			g_message("snd_pcm_avail Failed! \n");	
			recover_start_snd( _avail, _iap2 );
		}

		memset( iAP2_pcm_buffer, 0, sizeof( iAP2_pcm_buffer ));

		if( pipeline_status == READY_STATUS )//reset pipeline status playing
		{
			if( _avail > 0)
			{
				gint32 _ret;
				_ret	=	snd_pcm_drop( iAP2_pcm_handle );

				if ( _ret < 0 )
				{
					g_message( "pipeline ready start snd_pcm_drop, failed: %s\n", snd_strerror( _ret ));
				}

				_ret	=	snd_pcm_prepare( iAP2_pcm_handle );

				if ( _ret < 0 )
				{
					g_message("pipeline ready start snd_pcm_prepare Failed! %s\n", snd_strerror( _ret ));
				}

				_ret = snd_pcm_start( iAP2_pcm_handle );
				usleep( 1000 );   /*  Waiting for device response */
				if ( _ret < 0 )
				{
					g_message("pipeline ready start snd_pcm_start Failed! %s\n", snd_strerror( _ret ));
				}

				_size = snd_pcm_readi( iAP2_pcm_handle, iAP2_pcm_buffer, _iap2->sample_rate/10 );

				if( _size > 0 )
				{
					_priv->clock	=	UpTicks() + 20000000;
					_priv->running	=	200000000;

					g_message("_size = %d\n",_size);
					gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_PLAYING );
				//	GST_DEBUG_BIN_TO_DOT_FILE( GST_BIN(_iap2->pb->mh_player->playbin2), GST_DEBUG_GRAPH_SHOW_ALL, "iAP2_ReadyToPlaying");
					pipeline_status = PLAY_STATUS;
					throw_count = 0;
					reset_count = 0;
					GstBuffer * _buf;
					GstFlowReturn _ret;

					GstMemory * _mem;

					_buf	=	gst_buffer_new();

					_mem	=	gst_allocator_alloc(NULL, _size * 4, NULL);

					gst_buffer_insert_memory( _buf, -1, _mem);

					gst_buffer_fill (_buf, 0, iAP2_pcm_buffer, _size * 4);

//					GST_BUFFER_TIMESTAMP( _buf )	=	_priv->running;

					GST_BUFFER_PTS( _buf )	=	_priv->running;
					g_signal_emit_by_name( appsrc, "push-buffer", _buf, &_ret );

					gst_buffer_unref( _buf );

					g_source_set_ready_time( _priv->source, _priv->clock / 1000 );

					return G_SOURCE_CONTINUE;

				}else{
#if 0
					//					recover_start_snd( _size );
					gst_element_set_state( _pb->mh_player->playbin2, GST_STATE_READY );
					pipeline_status = READY_STATUS;	
					g_source_set_ready_time( _priv->source, -1 );

					int ret;
					snd_pcm_state_t state = 0;
					g_message("pipeline ready start snd_pcm_readi, failed: %s\n",  snd_strerror( _size ));
					ret = snd_pcm_recover(iAP2_pcm_handle, _size, 0);
					if (ret < 0)
					{
						g_message("pipeline ready start snd_pcm_recover failed! %s.\n", snd_strerror(ret));
					}
					else
					{
						state = snd_pcm_state(iAP2_pcm_handle);
						if (state == SND_PCM_STATE_PREPARED)
						{
							ret = snd_pcm_start(iAP2_pcm_handle);
							if (ret < 0)
							{
								g_message("pipeline ready start snd_pcm_start Failed! %s\n", snd_strerror(ret));
							}else{
								_priv->clock	=	UpTicks();
								//							_priv->running	=	0;
								//							gst_element_set_state( _pb->mh_player->playbin2, GST_STATE_PLAYING );
								g_source_set_ready_time( _priv->source, _priv->clock / 1000 );
							}
						}
					}
#else
					usleep(10000);
					gst_element_set_state( _pb->mh_player->playbin2, GST_STATE_READY );
										
					g_message("READY_STATUS snd_pcm_readi Failed! \n");	
					recover_start_snd( _size, _iap2 );	
#endif
				}
			}else{
				_priv->clock	=	UpTicks() + 10000000;
				g_source_set_ready_time( _priv->source, _priv->clock / 1000 );	
			}
			return G_SOURCE_CONTINUE;
		}

		if(( _iap2->curphoneStatus != PLAY_STATUS )||(_avail == 0))
		{
			if( _avail > _iap2->sample_rate/100 )
			{
				_size = snd_pcm_readi( iAP2_pcm_handle, iAP2_pcm_buffer, _iap2->sample_rate/100 );	
			}else{
				_size = snd_pcm_readi( iAP2_pcm_handle, iAP2_pcm_buffer, _avail );	
			}	
		}else{
			if(_avail < _iap2->sample_rate/200)
			{
				g_message("slow _avail = %d",(uint32_t)_avail);
//				_priv->running	=	20000000;
//				_priv->clock	+= 10000000;
//
//				g_source_set_ready_time( _priv->source, _priv->clock / 1000 );		
//				return G_SOURCE_CONTINUE;
	
//				_priv->clock	+= 10000000;
//				_priv->running	+= 10000000;
//				_size	=	0;
				throw_count ++ ;
				reset_count ++ ;
				if(( throw_count == 6 )||( reset_count == 2))
				{
					if( pipeline_status == 	PLAY_STATUS )
					{
						g_message("src is slow! set pipeline ready\n");
//						gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_READY );
						gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_NULL );
						gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_READY );
						pipeline_status = READY_STATUS;
					}

					_priv->clock	=	UpTicks() + 10000000;
				}else{
					_priv->clock	+= 10000000;
				}

				g_source_set_ready_time( _priv->source, _priv->clock / 1000 );

				return G_SOURCE_CONTINUE;
			}else if ( _avail > _iap2->sample_rate  /10){
				g_message("fast _avail = %d",(uint32_t)_avail);
				_size = snd_pcm_readi( iAP2_pcm_handle, iAP2_pcm_buffer, _iap2->sample_rate/10 );	
				_priv->running	+= 100000000;
				_priv->clock	+= 10000000;
				reset_count = 0;	
			}else{
				_size = snd_pcm_readi( iAP2_pcm_handle, iAP2_pcm_buffer, _iap2->sample_rate/100 );	
				reset_count = 0;
			}
		}

		if(( _size >= 0 )&&( appsrc != NULL ))
		{
			_priv->clock	+= 10000000;
			_priv->running	+= 10000000;

			GstBuffer * _buf;
			GstFlowReturn _ret;
				
			GstMemory * _mem;

			if( _size != 0 )
			{
				_buf	=	gst_buffer_new();

				_mem	=	gst_allocator_alloc(NULL, _size * 4, NULL);

				gst_buffer_insert_memory( _buf, -1, _mem);

				gst_buffer_fill (_buf, 0, iAP2_pcm_buffer, _size * 4);
			}else{
				_buf	=	gst_buffer_new();

				_mem	=	gst_allocator_alloc(NULL, _iap2->sample_rate/100 * 8, NULL);

				gst_buffer_insert_memory( _buf, -1, _mem);

				gst_buffer_fill (_buf, 0, iAP2_pcm_buffer, _iap2->sample_rate/100 * 8);
			}
//			GST_BUFFER_TIMESTAMP( _buf )	=	_priv->running;

			GST_BUFFER_PTS( _buf )	=	_priv->running;
			g_signal_emit_by_name( appsrc, "push-buffer", _buf, &_ret );

			gst_buffer_unref( _buf );

			g_source_set_ready_time( _priv->source, _priv->clock / 1000 );
		}
		else
		{
	#if 0
			gst_element_set_state( _pb->mh_player->playbin2, GST_STATE_READY );
			pipeline_status = READY_STATUS;	
			g_source_set_ready_time( _priv->source, -1 );

			int ret;
			snd_pcm_state_t state = 0;
			g_message( "snd_pcm_readi, failed: %s\n",  snd_strerror( _size ));
			ret = snd_pcm_recover(iAP2_pcm_handle, _size, 0);
			if (ret < 0)
			{
				g_message("snd_pcm_recover failed! %s.\n", snd_strerror(ret));
			}
			else
			{
				state = snd_pcm_state(iAP2_pcm_handle);
				if (state == SND_PCM_STATE_PREPARED)
				{
					ret = snd_pcm_start(iAP2_pcm_handle);
					if (ret < 0)
					{
						g_message("snd_pcm_start Failed! %s\n", snd_strerror(ret));
					}
					else
					{
						_priv->clock	=	UpTicks();
//						_priv->running	=	0;
//						gst_element_set_state( _pb->mh_player->playbin2, GST_STATE_PLAYING );
						g_source_set_ready_time( _priv->source, _priv->clock / 1000 );
					}
				}
			}
#else
			gst_element_set_state( _pb->mh_player->playbin2, GST_STATE_READY );
			
			g_message("snd_pcm_readi Failed! \n");	
			recover_start_snd( _size, _iap2 ); 
#endif
		}
	}	

	return G_SOURCE_CONTINUE;
}		

static GSourceFuncs pushFuncs	=	
{
	.dispatch	=	pushDispatch
};

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _iAP2_pcm_open
 *  Description:
 * =====================================================================================
 */
static BOOL _iAP2_pcm_open( MHPb * pb )
{
	gint32 _ret;

//	_ret = snd_pcm_open( &iAP2_pcm_handle, iAP2_pcm_card, SND_PCM_STREAM_CAPTURE, SND_PCM_ASYNC );//SND_PCM_NONBLOCK, SND_PCM_ASYNC

	_ret = snd_pcm_open( &iAP2_pcm_handle, iAP2_pcm_card, SND_PCM_STREAM_CAPTURE,  0 );//SND_PCM_NONBLOCK

	if ( _ret < 0 )
	{
		g_message( "snd_pcm_open, failed: %s %s\n", iAP2_pcm_card, snd_strerror( _ret ));
		return FALSE;
	}

	_ret	=	snd_pcm_set_params( iAP2_pcm_handle,
					SND_PCM_FORMAT_S16_LE,
					SND_PCM_ACCESS_RW_INTERLEAVED,
					IAP2_PCM_CHANNEL_NUM,
					MH_DEV_IAP2(pb->mhDev)->sample_rate,
					1,
					IAP2_PCM_LATENCY_US );

	if ( _ret < 0 )
	{
		g_message( "snd_pcm_set_params, failed: %s\n", snd_strerror( _ret ));
		return FALSE;
	}

	snd_pcm_sw_params_t * swparams;

	snd_pcm_sw_params_alloca( &swparams );

	_ret	=	snd_pcm_sw_params_current( iAP2_pcm_handle, swparams );

	if ( _ret < 0 )
	{
		g_message( "snd_pcm_sw_params_current, failed: %s\n", snd_strerror( _ret ));
		return FALSE;
	}

	_ret	=	snd_pcm_sw_params_set_start_threshold( iAP2_pcm_handle, swparams, 0 );

	if ( _ret < 0 )
	{
		g_message( "snd_pcm_sw_params_set_start_threshold, failed: %s\n", snd_strerror( _ret ));
		return FALSE;
	}

//	_ret	=	snd_pcm_sw_params_set_avail_min( iAP2_pcm_handle, swparams, IAP2_PCM_READ_FRAME_NUM );
//
//	if ( _ret < 0 )
//	{
//		g_message( "snd_pcm_sw_params_set_avail_min, failed: %s\n", snd_strerror( _ret ));
//		return FALSE;
//	}
//
	snd_pcm_sw_params_set_tstamp_mode(iAP2_pcm_handle, swparams,SND_PCM_TSTAMP_MMAP );

	_ret	=	snd_pcm_sw_params( iAP2_pcm_handle, swparams );

	if ( _ret < 0 )
	{
		g_message( "snd_pcm_sw_params, failed: %s\n", snd_strerror( _ret ));
		return FALSE;
	}

//	uint32_t count;
//
//	count = snd_pcm_poll_descriptors_count ( iAP2_pcm_handle );        
//
//	if ( count <= 0 ) 
//	{                
//		printf("Invalid poll descriptors count\n");                
//		return FALSE;
//	}        
//
//	printf("count	=	[%d]\n",count);

//	struct pollfd * ufds;
//
//	ufds = malloc( sizeof( struct pollfd ) * count );        
//
//	if ( ufds == NULL ) 
//	{                
//		printf("No enough memory\n");                
//		return FALSE;
//	}
//
//	if (( _ret = snd_pcm_poll_descriptors( iAP2_pcm_handle, ufds, count )) < 0 ) 
//	{                
//		printf("Unable to obtain poll descriptors for playback: %s\n", snd_strerror( _ret ));              
//		return FALSE;
//	}
//
////	GSource * _source	=	NULL;
//
////	alsaFd	=	g_new0(GPollFD,  1 );
//
//	alsaFd.fd	=	ufds[0].fd;
//
//	g_free( ufds );
//
//	if( alsaFd.fd > 0 )
//	{
//		alsaFd.events	=	POLLIN;
//
//		alsaFd.revents	=	0;
//
//		fd_source	=	g_source_new( &_funcs, sizeof( GSource ));
//
//		g_source_add_poll( fd_source, &alsaFd );
//
//		mh_io_dispatch( MH_IO( pb->mhDev ), fd_source );
//
//		g_source_unref( fd_source );
//	}
//	else
//	{
//		g_warning( "udev_monitor_get_fd faild" );
//	}
	
//	_ret	=	snd_pcm_prepare( iAP2_pcm_handle );
//
//	if ( _ret < 0 )
//	{
//		g_message("snd_pcm_prepare Failed! %s\n", snd_strerror( _ret ));
//		return FALSE;
//	}
//
//	_ret = snd_pcm_start( iAP2_pcm_handle );
//
//	if ( _ret < 0 )
//	{
//		g_message("snd_pcm_start Failed! %s\n", snd_strerror( _ret ));
//		return FALSE;
//	}

	return TRUE;
}		/* -----  end of static function _iAP2_pcm_open  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _needData
 *  Description:
 * =====================================================================================
 */
static void _needData( GstAppSrc * src, guint arg1, gpointer user_data )
{
//	g_message( "%s %d\n", __func__,arg1 );
}		/* -----  end of static function _needData  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _enoughData
 *  Description:
 * =====================================================================================
 */
static void _enoughData( GstElement * src, gpointer user_data )
{
//	g_message( "%s", __func__ );
}		/* -----  end of static function _enoughData  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  setupSrc
 *  Description:
 * =====================================================================================
 */
static void setupSrc( GstElement * object, GstElement * arg0, gpointer user_data )
{
	GstCaps * _caps;

	appsrc	=	arg0;

//	g_object_set( arg0, "stream-type", GST_APP_STREAM_TYPE_STREAM, "block", TRUE, NULL );
	g_object_set( arg0, "stream-type", GST_APP_STREAM_TYPE_STREAM,  
			"is-live", TRUE, "block", TRUE,
			"format", GST_FORMAT_TIME, NULL );
//	if ( iAP2Object->hostMode	==	TRUE )
	
//	{
//		g_object_set( arg0, "is-live", TRUE, NULL );

		g_object_set( arg0, "do-timestamp", TRUE, NULL );

		g_object_set( arg0, "min-latency",(gint64)0, NULL );

		g_object_set( arg0, "max-latency", (gint64)0, NULL );
//	}

	_caps   =   gst_caps_new_simple( "audio/x-raw",
					"format", G_TYPE_STRING, "S16LE",
					"endianness", G_TYPE_INT, 1234,
					"signed", G_TYPE_BOOLEAN, TRUE,
					"width", G_TYPE_INT, 16,
					"depth", G_TYPE_INT, 16,
					"layout", G_TYPE_STRING,"interleaved",
					"rate", G_TYPE_INT,  ((iAP2GlobalInfo *)_iAP2GlobalInfolist->data)->piAP2Object->sample_rate,
					"channels", G_TYPE_INT, 2,
					NULL );

	g_object_set( arg0, "caps", _caps, NULL );

	gst_caps_unref( _caps );

	g_signal_connect( arg0, "need-data", G_CALLBACK( _needData ), NULL );

	g_signal_connect( arg0, "enough-data", G_CALLBACK( _enoughData ), NULL );

}       /*  -----  end of static function setupSrc  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _iAP2_stream_open
 *  Description:
 * =====================================================================================
 */
static BOOL _iAP2_stream_open( MHPb * pb )
{
	gint32 _ret = 0;

	char   * _card_name;

	gint32 _card_no, _open_no;
	
	memset( iAP2_pcm_card, 0, sizeof( iAP2_pcm_card ));

	for( _card_no = 0; _card_no < IAP2_PCM_MAX_SOUND_CARD_COUNT; _card_no ++ )
	{
		_ret = snd_card_get_name( _card_no, &_card_name );

		printf("cord_name	=	[%s]\n",_card_name);

		if ( _ret == 0 )
		{
			if((( MH_DEV_IAP2( pb->mhDev )->hostMode == TRUE ) 
					&& ( strncmp( _card_name, IAP2_PCM_HOST_CARD_NAME, IAP2_PCM_HOST_CARD_NAME_LENGTH ) == 0 ))
				|| (( MH_DEV_IAP2( pb->mhDev )->hostMode == FALSE ) 
					&&(( strncmp( _card_name, IAP2_PCM_IPOD_CARD_NAME, IAP2_PCM_CARD_NAME_LENGTH ) == 0 )
					|| ( strncmp( _card_name, IAP2_PCM_IPHONE_CARD_NAME, IAP2_PCM_CARD_NAME_LENGTH ) == 0 )
					|| ( strncmp( _card_name, IAP2_PCM_IPAD_CARD_NAME, IAP2_PCM_CARD_NAME_LENGTH ) == 0 )))) 
			{
				snprintf( iAP2_pcm_card, sizeof( iAP2_pcm_card ), "hw:%d", _card_no );

				for( _open_no = 0; _open_no < IAP2_PCM_OPEN_MAX_COUNT; _open_no ++ )
				{
					if( _iAP2_pcm_open( pb ))
					{
						pb->mh_player = mh_player_open();
						
						if( pb->mh_player != NULL )
						{
							g_object_set( pb->mh_player->playbin2, "uri", "appsrc://", NULL );

							MHDevIap2 * _iap2	=	MH_DEV_IAP2( pb->mhDev );
							MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _iap2 );

							_priv->source	=	g_source_new( &pushFuncs, sizeof( GSource ));
							g_source_set_callback( _priv->source, NULL, pb, NULL );
							g_source_set_ready_time( _priv->source, -1 );
							g_source_attach( _priv->source, _priv->context );

							g_source_unref( _priv->source );

//							GstStateChangeReturn _result = GST_STATE_CHANGE_FAILURE;

//							GstElement * _sink;

//							_sink	=	gst_element_factory_make( "alsasink", "alsa" );
//
//							g_object_set( _sink, "device", "hw:1", NULL );
//							_sink	=	gst_element_factory_make( "pulsesink", "pulseaudio" );
//
//							gint64 _time = 200000; 
//
//							g_object_set( G_OBJECT(_sink), "buffer-time", _time, NULL);
//
//							g_object_set( pb->mh_player->playbin2, "audio-sink", _sink, NULL);

							if( pb->audio_sink_name != NULL )
							{
								GstElement * _sink;

								_sink	=	gst_element_factory_make( pb->audio_sink_name, NULL );
//								if( g_strcmp0( pb->audio_sink_name, "pulsesink" ) == 0 )
								{
									if( pb->streamid	!=	NULL )
									{
										g_object_set( _sink, "client-name", pb->streamid, NULL);
										g_message("streamid = [%s] set success\n",pb->streamid);
									}
									char * _device_name = getenv("MH_PB_AUDIOSINK_DEVICENAME");
									if (_device_name != NULL)
									{
										g_object_set( _sink, "device", _device_name, NULL);
										g_message("_device_name = [%s] set success\n",_device_name);
									}
								}

								if( pb->device_name	!=	NULL )
									g_object_set( _sink, "device", pb->device_name, NULL );

//								if( pb->buffer_time	!=	200000 )
//									g_object_set( G_OBJECT( _sink ), "buffer-time", ( uint64_t )pb->buffer_time, NULL);
								g_object_set( G_OBJECT( _sink ), "buffer-time", ( uint64_t )100000, NULL);	
								//g_object_set( G_OBJECT( _sink ), "slave-method", 2, NULL);
								g_object_set( G_OBJECT( _sink ), "latency-time", ( uint64_t )50000, NULL);
								g_object_set( G_OBJECT( _sink ), "drift-tolerance", ( gint64 )500000, NULL);	

								g_object_set( pb->mh_player->playbin2, "audio-sink", _sink, NULL);
							}

							g_signal_connect( pb->mh_player->playbin2, "source-setup", G_CALLBACK( setupSrc ), NULL );
							
//							_priv->clock	=	UpTicks();
//							_priv->running	=	0;
//
							gst_element_set_state( pb->mh_player->playbin2, GST_STATE_READY );
						//	GST_DEBUG_BIN_TO_DOT_FILE( GST_BIN(pb->mh_player->playbin2), GST_DEBUG_GRAPH_SHOW_ALL, "iAP2_NullToReady");
//							g_source_set_ready_time( _priv->source, _priv->clock / 1000 );1000 );

//							if( _result == GST_STATE_CHANGE_FAILURE )
//							{
//								g_message(" GST_STATE_PLAYING Change Failed!\n" );
//							}else{
//								g_message(" GST_STATE_PLAYING Change success!\n" );
//							}
						}else{
							g_message( " player open Failed !\n" );
							return FALSE;
						}
						break;
					}
				}
				if ( _open_no >= IAP2_PCM_OPEN_MAX_COUNT ) 
				{
					g_message( "Open PCM failed.\n" );
					return FALSE;
				}
				break;
			}
		}
	}

	if ( _card_no >= IAP2_PCM_MAX_SOUND_CARD_COUNT ) 
	{
		g_message( "Find iPod card failed.\n" );
		return FALSE;
	}

	return TRUE;
}		/* -----  end of static function _iAP2_stream_open  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispose_callback
 *  Description:  
 * =====================================================================================
 */
static gboolean _dispose_callback( gpointer user_data )
{
	MHPb * _pb	=	( MHPb * )user_data;

	mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );

	if( _pb->mh_player	!=	NULL)
	{
		g_object_unref( _pb->mh_player );

		_pb->mh_player	=	NULL;
	}

	if( _pb->playlist != NULL ) 
	{
		g_object_unref(_pb->playlist);

		_pb->playlist	=	NULL;
	}

	return G_SOURCE_REMOVE;
}		/* -----  end of static function _dispose_callback  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name: player_dispose
 *  Description:
 * =====================================================================================
 */
static void player_dispose( MHDev * self,  void * user_data )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _dispose_callback, user_data, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}		/* -----  end of static function player_dispose  ----- */


/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_by_list
 *  Description:
 * =====================================================================================
 */
static void _play_by_list( MHDev * self, MHPb * pb, MHPlaylist * playlist )
{
	MHDevIap2 * _iap2	=	MH_DEV_IAP2( pb->mhDev );
	int j = 0;
	
	if( pb->playlist != NULL ) 
	{
		g_object_unref( pb->playlist );
	}

	pb->playlist = g_object_ref( playlist );
	
	if( pb->playlist == NULL)
	{
		return;
	}

	gint arrayLen = playlist->array->len;
	//Packets have a maximum Payload Data size of 65525 bytes
	if (arrayLen > MaxMusic)
	{
		g_message(" #################### %s playlist->array->len = %d Error ", __func__, playlist->array->len);
		arrayLen = MaxMusic;
	}
	if (playlist->index >= MaxMusic)
	{
		j = playlist->index - MaxMusic + 1;
		g_message(" #################### %s playlist->index = %d Error ", __func__, playlist->index);
		playlist->index = MaxMusic - 1;
	}
	
	gint _paramsLen	=	4 + arrayLen * 8 + 4 + 4 + 4 + _iap2->libraryIdLen;
	guint8 * _params	=	g_malloc0( _paramsLen );
	int _offset	=	0, i = 0;

	_params[ _offset + 0 ]	=	IAP2_HI_BYTE( 4 + arrayLen * 8 );
	_params[ _offset + 1 ]	=	IAP2_LO_BYTE( 4 + arrayLen * 8 );
	_params[ _offset + 2 ]	=	0x00;
	_params[ _offset + 3 ]	=	0x00;

	_offset	+=	4;

	g_message( "items in playlist:" );
	for(i = j; i < arrayLen + j; i ++ )
	{
		gint64 _uid	=	g_array_index( playlist->array, MHItemData *, i )->tagId;

		IAP2_MISC_WRITE_BIG64( _params + _offset + (i - j) * 8, _uid );

//		g_message( "[%llX] %s", g_array_index( playlist->array, MHItemData *, i )->tagId, 
//				g_array_index( playlist->array, MHItemData *, i )->metadata.music.title );
	}

	_offset	+=	arrayLen * 8;

	_params[ _offset + 0 ]	=	0x00;
	_params[ _offset + 1 ]	=	0x08;
	_params[ _offset + 2 ]	=	0x00;
	_params[ _offset + 3 ]	=	0x01;
	_params[ _offset + 4 ]	=	playlist->index >> 24;
	_params[ _offset + 5 ]	=	playlist->index >> 16;
	_params[ _offset + 6 ]	=	playlist->index >> 8;
	_params[ _offset + 7 ]	=	playlist->index & 0xFF;

	_offset	+=	8;

	_params[ _offset + 0 ]	=	IAP2_HI_BYTE( 4 + _iap2->libraryIdLen );
	_params[ _offset + 1 ]	=	IAP2_LO_BYTE( 4 + _iap2->libraryIdLen );
	_params[ _offset + 2 ]	=	0x00;
	_params[ _offset + 3 ]	=	0x02;

	_offset	+=	4;

	memcpy( _params + _offset, _iap2->mediaLibraryId, _iap2->libraryIdLen );

	g_message( "####################_paramsLen:%d" ,_paramsLen);

	iAP2SendControlMessage( _iap2->plinkRunLoop->link, 0x4C07, _params, _paramsLen, IAP2_CONTROL_SESSION_ID );
//	if( _iap2->oldStatus	== PLAY_STATUS )
//		mh_pb_dispatch( pb, EVENT_CHANGE, GUINT_TO_POINTER( _iap2->oldStatus ), NULL );

	g_free( _params );
}      /* -----  end of static function _play_by_list  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _stop
 *  Description:
 * =====================================================================================
 */
static void _stop( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommand(MH_DEV_IAP2( self )->plinkRunLoop->link, HID_PAUSE);
	iAP2HidExecCommandDone(MH_DEV_IAP2( self )->plinkRunLoop->link);

	MH_DEV_IAP2( self )->curphoneStatus = PAUSE_STATUS;

}      /* -----  end of static function _stop  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play
 *  Description:
 * =====================================================================================
 */
static void _play( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommand(MH_DEV_IAP2( self )->plinkRunLoop->link, HID_PLAY);
	iAP2HidExecCommandDone(MH_DEV_IAP2( self )->plinkRunLoop->link);

}      /* -----  end of static function _play  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pause
 *  Description:
 * =====================================================================================
 */
static void _pause( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommand( MH_DEV_IAP2( self )->plinkRunLoop->link, HID_PAUSE );
	iAP2HidExecCommandDone(MH_DEV_IAP2( self )->plinkRunLoop->link);

	MH_DEV_IAP2( self )->curphoneStatus = PAUSE_STATUS;
}      /* -----  end of static function _pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_pause
 *  Description:
 * =====================================================================================
 */
static void _play_pause( MHDev * self )
{
	g_message("%s", __func__);

	iAP2HidExecCommand( MH_DEV_IAP2( self )->plinkRunLoop->link, HID_PLAY_PAUSE );
	iAP2HidExecCommandDone(MH_DEV_IAP2( self )->plinkRunLoop->link);

}      /* -----  end of static function _play_pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _resume
 *  Description:
 * =====================================================================================
 */
static void _resume( MHDev * self )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _resume  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward
 *  Description:
 * =====================================================================================
 */
static void _forward( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommand(MH_DEV_IAP2( self )->plinkRunLoop->link, HID_SCAN_NEXT_TRACK);

}      /* -----  end of static function _forward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward_done
 *  Description:
 * =====================================================================================
 */
static void _forward_done( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommandDone(MH_DEV_IAP2( self )->plinkRunLoop->link);

}      /* -----  end of static function _forward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward
 *  Description:
 * =====================================================================================
 */
static void _backward( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommand(MH_DEV_IAP2( self )->plinkRunLoop->link, HID_SCAN_PREVIOUS_TRACK);

}      /* -----  end of static function _backward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward_done
 *  Description:
 * =====================================================================================
 */
static void _backward_done( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommandDone(MH_DEV_IAP2( self )->plinkRunLoop->link);

}      /* -----  end of static function _backward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_index
 *  Description:
 * =====================================================================================
 */
static void _set_index( MHDev * self, MHPb * pb, uint32_t index ) 
{
	g_message("%s, index = [ %d ]\n", __func__ , index );
	
        MHDevIap2 * _iap2	=	MH_DEV_IAP2( pb->mhDev );

	if( _iap2->indentifyFlag	== TRUE )
	{			
		mh_pb_set_media_info( _iap2->pb, MH_PB_IP_INFO_FUNC_UNSUPPORT, NULL );
	}
	else{ 
		if( _iap2->elapsedTimeAvailable == TRUE )
		{
			pb->playlist->index = index;

			mh_pb_dispatch( pb, EVENT_CHANGE, GUINT_TO_POINTER( SWITCHING_STATUS ), NULL );

			_iap2->curStatus	=	SWITCHING_STATUS;

			gint _paramsLen = 4 + sizeof( uint32_t ) + 4 + sizeof( uint32_t );

			guint8 * _params	=	g_malloc0( _paramsLen );

			_params[0] = IAP2_HI_BYTE(4 + sizeof(uint32_t));
			_params[1] = IAP2_LO_BYTE(4 + sizeof(uint32_t));
			_params[2] = 0x00;
			_params[3] = 0x00;               /*  ElapsedTime */
			_params[4] = 0x00;
			_params[5] = 0x00;
			_params[6] = 0x00;
			_params[7] = 0x00;

			_params[8] = IAP2_HI_BYTE(4 + sizeof(uint32_t));
			_params[9] = IAP2_LO_BYTE(4 + sizeof(uint32_t));
			_params[10] = 0x00;
			_params[11] = 0x01;               /*  PlaybackQueueIndex */
			_params[12] = index >> 24;
			_params[13] = index >> 16;
			_params[14] = index >> 8;
			_params[15] = index & 0xFF;

			iAP2SendControlMessage( _iap2->plinkRunLoop->link, 0x5003, _params, _paramsLen, IAP2_CONTROL_SESSION_ID );

			//		mh_pb_dispatch( pb, EVENT_CHANGE, GUINT_TO_POINTER( iAP2Object->oldStatus ), NULL );

			g_free( _params );
		}else{
			g_message( " SetElapsedTimeAvailable is FALSE\n" );
		}
	}
}      /* -----  end of static function _set_index  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_speed
 *  Description:
 * =====================================================================================
 */
static void _set_speed( MHDev * self, guint speed )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_speed  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_repeat
 *  Description:
 * =====================================================================================
 */
static void _set_repeat( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommand( MH_DEV_IAP2( self )->plinkRunLoop->link, HID_REPEAT );
	iAP2HidExecCommandDone(MH_DEV_IAP2( self )->plinkRunLoop->link);

}      /* -----  end of static function _set_repeat  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_shuffle
 *  Description:
 * =====================================================================================
 */
static void _set_shuffle( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	iAP2HidExecCommand( MH_DEV_IAP2( self )->plinkRunLoop->link, HID_RANDOM_PLAY );
	iAP2HidExecCommandDone(MH_DEV_IAP2( self )->plinkRunLoop->link);

}      /* -----  end of static function _set_shuffle  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_buffer_time
 *  Description:
 * =====================================================================================
 */
static void _set_buffer_time( MHDev * self )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_buffer_time  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _restore_media_from_db
 *  Description:  
 * =====================================================================================
 */
static void _restore_media_from_db( MHDev * dev)
{
	MHContents * _contents	=	mh_contents_instance();
	gchar * _sql	=	"select * from node left outer join music on node.node_id = "
						"music.node_id where device_id = ?";
	gint64 _nodeId, _deviceId, _tagId;
	gint64 _size, _type, _valid, _rating, _duration, _track, _track_count,
		_disc, _disc_count, _year, _mediaType;
	gchar * _name, * _title, * _album_title, * _artist, * _genre, * _composer, *_album_artist;
	MHStmt * _stmt;
	gchar ** _playlists;
	int i;

	_deviceId	=	mh_contents_get_device( _contents, dev->serial );

	if( _deviceId != -1 )
	{
		_stmt	=	mh_contents_prepare( _contents, _sql );

		mh_contents_bind_int64( _contents, _stmt, 1, _deviceId );

		while( mh_contents_step( _contents, _stmt, &_nodeId, &_deviceId, &_name, &_size, 
					&_type, &_valid, &_tagId, &_nodeId, &_title, &_rating, &_duration, &_album_title, 
					&_track, &_track_count, &_disc, &_disc_count, &_artist, &_album_artist,
					&_genre, &_composer, &_year, &_mediaType, NULL ) == MH_CONTENTS_STEP_CONTINUE )
		{
			MHMusic * _music	=	g_object_new( MH_TYPE_MUSIC, NULL );
			MHItem * _item	=	MH_ITEM( _music );

			_item->uniqueId	=	_nodeId;
			_item->name		=	_name;
			_item->size		=	_size;
			_item->type		=	_type;
			_item->valid	=	_valid;
			_item->tagId	=	_tagId;

			_music->title	=	_title;
			_music->rating	=	_rating;
			_music->duration	=	_duration;
			_music->album_title	=	_album_title;
			_music->track	=	_track;
			_music->track_count	=	_track_count;
			_music->disc	=	_disc;
			_music->disc_count	=	_disc_count;
			_music->artist	=	_artist;
			_music->album_artist	=	_album_artist;
			_music->genre	=	_genre;
			_music->composer	=	_composer;
			_music->year	=	_year;
			_music->mediaType	=	_mediaType;

			g_hash_table_insert( dev->itemsHash, &_item->uniqueId, _item );
		}

		mh_contents_release( _contents, _stmt );
	}
}		/* -----  end of static function _restore_media_from_db  ----- */

struct timeval startTime;
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _start_scan
 *  Description:
 * =====================================================================================
 */
static void _start_scan( MHDev * self, MHDevScanType type)
{
	MHDevIap2 * _iap2	=	MH_DEV_IAP2( self );
	MHContents * _contents	=	mh_contents_instance();
	void * _data;
	gint _size;

	self->uniqueId	=	mh_contents_get_device( _contents, 
			MH_DEV( self )->serial );

	/* Device is existed? */
	if( self->uniqueId > 0 )
	{
		/* Get the library information from database */
		_data	=	mh_contents_get_device_private( _contents, MH_DEV( self )->uniqueId, &_size );

		if( _data != NULL )
		{
			g_message( "Restored MediaLibraryRevision [ %s ]", ( gchar * )_data );
			_iap2->libraryRevision	=	_data;
		}
	}
	else
	{
		g_message( "Register a new Apple device to database" );
		/* Append device to database */
		self->uniqueId	=	mh_contents_add_device( mh_contents_instance(),
				MH_DEV( self )->serial );
	}
	
	_restore_media_from_db( self );

	g_message( "Starting sync media library contents..." );
	gettimeofday( &startTime, NULL );
	iAP2StartMLUpdate( _iap2->plinkRunLoop->link );
}      /* -----  end of static function _start_scan  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _previous
 *  Description:
 * =====================================================================================
 */
static void _previous( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);

	MHDevIap2 * _iap2	=	MH_DEV_IAP2( self );
	_iap2->curStatus	=	SWITCHING_STATUS;
	iAP2HidExecCommand( _iap2->plinkRunLoop->link, HID_SCAN_PREVIOUS_TRACK);
	iAP2HidExecCommandDone( _iap2->plinkRunLoop->link);

	mh_pb_dispatch( pb, EVENT_CHANGE, GUINT_TO_POINTER( _iap2->oldStatus ), NULL );
}      /* -----  end of static function _previous  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _seek
 *  Description:
 * =====================================================================================
 */
static void _seek( MHDev * self, MHPb * pb, uint32_t second )
{
	g_message("%s, second = [ %d ]\n", __func__ , second );
	MHDevIap2 * _iap2	=	MH_DEV_IAP2( self );

	if( _iap2->indentifyFlag	== TRUE )
	{			
		mh_pb_set_media_info( _iap2->pb, MH_PB_IP_INFO_FUNC_UNSUPPORT, NULL );
	}
	else{
		if( _iap2->elapsedTimeAvailable == TRUE )
		{
			gint _paramsLen = 4 + sizeof( uint32_t ) + 4 + sizeof( uint32_t );

			guint8 * _params	=	g_malloc0( _paramsLen );

			_params[0] = IAP2_HI_BYTE(4 + sizeof(uint32_t));
			_params[1] = IAP2_LO_BYTE(4 + sizeof(uint32_t));
			_params[2] = 0x00;
			_params[3] = 0x00;               /*  ElapsedTime */
			_params[4] = second >> 24;
			_params[5] = second >> 16;
			_params[6] = second >> 8;
			_params[7] = second & 0xFF;

			_params[8] = IAP2_HI_BYTE(4 + sizeof(uint32_t));
			_params[9] = IAP2_LO_BYTE(4 + sizeof(uint32_t));
			_params[10] = 0x00;
			_params[11] = 0x01;               /*  PlaybackQueueIndex */
			_params[12] = _iap2->currentQueueIndex >> 24;
			_params[13] = _iap2->currentQueueIndex >> 16;
			_params[14] = _iap2->currentQueueIndex >> 8;
			_params[15] = _iap2->currentQueueIndex & 0xFF;

			iAP2SendControlMessage( _iap2->plinkRunLoop->link, 0x5003, _params, _paramsLen, IAP2_CONTROL_SESSION_ID );

//			mh_pb_dispatch( pb, EVENT_CHANGE, GUINT_TO_POINTER( _iap2->oldStatus ), NULL );

			g_free( _params );
		}else{
			g_message( " SetElapsedTimeAvailable is FALSE\n" );
		}
	}

	mh_pb_dispatch( pb, EVENT_CHANGE, GUINT_TO_POINTER( _iap2->oldStatus ), NULL );
}      /* -----  end of static function _seek  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _next
 *  Description:
 * =====================================================================================
 */
static void _next( MHDev * self, MHPb * pb )
{
	g_message("%s", __func__);
	
	MHDevIap2 * _iap2	=	MH_DEV_IAP2( self );
	_iap2->curStatus	=	SWITCHING_STATUS;
	iAP2HidExecCommand(_iap2->plinkRunLoop->link, HID_SCAN_NEXT_TRACK);
	iAP2HidExecCommandDone(_iap2->plinkRunLoop->link);

//	mh_pb_dispatch( pb, EVENT_CHANGE, GUINT_TO_POINTER( iAP2Object->oldStatus ), NULL );
}      /* -----  end of static function _next  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_pb_events_listener
 *  Description:  
 * =====================================================================================
 */
static gboolean _register_pb_events_listener( MHDev * self, MHPb * pb, MHDevPbEventsListener * listener )
{

	return FALSE;
}		/* -----  end of static function _register_pb_events_listener  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  attach_pb
 *  Description:
 * =====================================================================================
 */
static gboolean attach_pb( gpointer user_data )
{
		if ( user_data == NULL )
		{
			return FALSE;
		}
		MHPb * _pb = ( MHPb * )user_data;

		if( MH_DEV_IAP2( _pb->mhDev )->mediaInfoFlag	==	TRUE )
		{
			iAP2MediaResendMessage( MH_DEV_IAP2( _pb->mhDev ), RS_TAG );
		}
		if( MH_DEV_IAP2( _pb->mhDev )->repeatFlag	==	TRUE )
		{
			iAP2MediaResendMessage( MH_DEV_IAP2( _pb->mhDev ), RS_REPEAT );
		}
		if( MH_DEV_IAP2( _pb->mhDev )->shuffleFlag	==	TRUE )
		{
			iAP2MediaResendMessage( MH_DEV_IAP2( _pb->mhDev ), RS_SHUFFLE);
		}
		if( MH_DEV_IAP2( _pb->mhDev )->appNameFlag	==	TRUE )
		{
			iAP2MediaResendMessage( MH_DEV_IAP2( _pb->mhDev ), RS_APP_NAME );
		}
		if( MH_DEV_IAP2( _pb->mhDev )->curStatusFlag	==	TRUE )
		{
			iAP2MediaResendMessage( MH_DEV_IAP2( _pb->mhDev ), RS_CUR_STATUS );
		}
		if( MH_DEV_IAP2( _pb->mhDev )->speedFlag	==	TRUE )
		{
			iAP2MediaResendMessage( MH_DEV_IAP2( _pb->mhDev ), RS_PLAYBACK_SPEED );
		}
		if( MH_DEV_IAP2( _pb->mhDev )->mode	==	MISC_IAP )
			_iAP2_stream_open( MH_DEV_IAP2( _pb->mhDev )->pb );
#ifdef __x86_64__
		g_signal_emit_by_name(MH_DEV_IAP2( _pb->mhDev ),"ea_session_send_pb",(guint64)MH_DEV_IAP2( _pb->mhDev )->pb);
#else
		g_signal_emit_by_name(MH_DEV_IAP2( _pb->mhDev ),"ea_session_send_pb",(guint)MH_DEV_IAP2( _pb->mhDev )->pb);
#endif
		if( MH_DEV_IAP2( _pb->mhDev )->deviceNameFlag	==	TRUE )
		{
			iAP2MediaResendMessage( MH_DEV_IAP2( _pb->mhDev ), RS_DEV_NAME );
		}
//		MHDevDetachListener _detach_listener	=	
//		{
//			.callback	=	player_dispose,
//		.user_data	=	iAP2Object->pb
//		};
//		mh_dev_register_detach_listener( iAP2Object->pb->mhDev, & _detach_listener);

	return	FALSE;	
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _attach_pb
 *  Description:
 * =====================================================================================
 */
static void _attach_pb( MHDev * self, MHPb * pb )
{
	g_message("%s\n",__func__);
	if( pb->mh_player == NULL )
	{
		pb->mhDev	=	self;

		MH_DEV_IAP2( self )->pb	=	pb;
		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, attach_pb, pb, NULL );

		mh_io_dispatch( MH_IO( MH_DEV_IAP2( self ) ), _source );

		g_source_unref( _source );
	}
}      /* -----  end of static function _attach_pb  ----- */

#include <debug.h>

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _restore_playlist_from_data
 *  Description:  
 * =====================================================================================
 */
MHPlaylist * restore_playlist_from_data( MHDev * self, guint8 * data, int length )
{
	MHPlaylist * _playlist	=	NULL;
	MHContents * _contents	=	mh_contents_instance();
	gchar * _sql	=	"select * from node left outer join music on node.node_id = "
						"music.node_id where node.tagId = ?;";
	gint64 _nodeId, _deviceId, _tagId;
	gint64 _size, _type, _valid, _rating, _duration, _track, _track_count,
		_disc, _disc_count, _year, _mediaType;
	gchar * _title, * _album_title, * _artist, * _genre, * _composer, *_album_artist;
	gchar * _name	=	NULL; 
	MHStmt * _stmt;
	int _offset	=	0;
	MHItem ** _items;
	int _count	=	0, i;

	_playlist	=	g_object_new( MH_TYPE_PLAYLIST, NULL );
	_playlist->dev	=	self;

	_stmt	=	mh_contents_prepare( _contents, _sql );
	_items	=	g_new0( MHItem *, length / sizeof( uint64_t ));

	while(_offset < length)
	{
		uint64_t _itemId;

		_itemId	=	IAP2_MISC_READ_BIG64(data + _offset);

		mh_contents_reset( _contents, _stmt );

		mh_contents_bind_int64( _contents, _stmt, 1, _itemId );

		while( mh_contents_step( _contents, _stmt, &_nodeId, &_deviceId, &_name, &_size, 
					&_type, &_valid, &_tagId, &_nodeId, &_title, &_rating, &_duration, &_album_title, 
					&_track, &_track_count, &_disc, &_disc_count, &_artist, &_album_artist,
					&_genre, &_composer, &_year, &_mediaType, NULL ) == MH_CONTENTS_STEP_CONTINUE )
		{
			MHMusic * _music	=	g_object_new( MH_TYPE_MUSIC, NULL );
			MHItem * _item	=	MH_ITEM( _music );

			_item->uniqueId	=	_nodeId;
			_item->name		=	_name;
			_item->size		=	_size;
			_item->type		=	_type;
			_item->valid	=	_valid;
			_item->tagId	=	_tagId;

			_music->title	=	_title;
			_music->rating	=	_rating;
			_music->duration	=	_duration;
			_music->album_title	=	_album_title;
			_music->track	=	_track;
			_music->track_count	=	_track_count;
			_music->disc	=	_disc;
			_music->disc_count	=	_disc_count;
			_music->artist	=	_artist;
			_music->album_artist	=	_album_artist;
			_music->genre	=	_genre;
			_music->composer	=	_composer;
			_music->year	=	_year;
			_music->mediaType	=	_mediaType;

			_items[ _count ++ ]	=	_item;
		}

		_offset	+=	sizeof(uint64_t);
	}

	mh_contents_release( _contents, _stmt );

	mh_playlist_append( _playlist, _items, _count );

	for( i = 0; i < _count; i ++ )
	{
		g_object_unref( _items[i] );
	}

	return _playlist;
}		/* -----  end of function _restore_playlist_from_data  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _restore_playlist
 *  Description:  
 * =====================================================================================
 */
static MHPlaylist * _restore_playlist( MHDev * self,gint64 playlist_id )
{
	MHPlaylist * _playlist	=	NULL;
	gint8 * _buf;
	int _length;

	if( MH_DEV_IAP2( self )->syncComplete )
	{
		_buf	=	mh_contents_restore_playlist( mh_contents_instance(),playlist_id ,&_length);
		if( _buf != NULL )
			_playlist	=	restore_playlist_from_data( self, _buf, _length );
	}
	else
	{
		g_warning( "iAP2 Media Library sync isn't completed" );
	}

	return _playlist;
}		/* -----  end of static function _restore_playlist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_radiolist
 *  Description:  
 * =====================================================================================
 */
static char ** _get_radiolist( MHDev * self, int * count)
{
	char ** res;
	int listLen = 0;
	int i = 0;
	GSList *list = NULL;

	iAP2RadioPlayListInfo *pstRadioInfo = NULL;

	list = gRadioList;
	listLen = g_slist_length(list);
	 * count = listLen;
	 
	g_message("%s listLen = %d", __func__, listLen);
	if (listLen <= 0)
		return NULL;

	res = (char ** )g_malloc0(sizeof(char *) * listLen);

	for (i = 0; i < listLen; i++)
	{
		pstRadioInfo = (iAP2RadioPlayListInfo *)list->data;
		if (pstRadioInfo !=NULL && pstRadioInfo->listName != NULL)
		{
			res[i] = (char *)g_malloc0(strlen(pstRadioInfo->listName) + 1);
			memcpy(res[i], pstRadioInfo->listName, strlen(pstRadioInfo->listName) + 1);
		}
		list = list->next;
	}
	return res;
}		/* -----  end of static function _get_radiolist  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  request_app_launch
 *  Description:  
 * =====================================================================================
 */
static MHResult request_app_launch( MHDev * self, const char * app_bundle_id )
{
	gint _idLen	=	strlen( app_bundle_id ) + 1;
	guint8 _params[ 4 + _idLen + 4 + 1 ];

	_params[0]	=	IAP2_HI_BYTE( 4 + _idLen );
	_params[1]	=	IAP2_LO_BYTE( 4 + _idLen );
	_params[2]	=	0x00;
	_params[3]	=	0x00;

	memcpy( _params + 4, app_bundle_id, _idLen );

	_params[ 4 + _idLen + 0 ]	=	IAP2_HI_BYTE( 4 + 1 );
	_params[ 4 + _idLen + 1 ]	=	IAP2_LO_BYTE( 4 + 1 );
	_params[ 4 + _idLen + 2 ]	=	0x00;
	_params[ 4 + _idLen + 3 ]	=	0x01;
	_params[ 4 + _idLen + 4 ]	=	0x00;

	iAP2SendControlMessage( MH_DEV_IAP2( self )->plinkRunLoop->link, 0xEA02, _params, 4 + _idLen + 4 + 1, IAP2_CONTROL_SESSION_ID );

	return 0;
}		/* -----  end of static function request_app_launch  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  write_location_data
 *  Description:  
 * =====================================================================================
 */
static MHResult write_location_data( MHDev * self, const char * data )
{
	//g_message("%s   data = %s\n",__func__,data);

	gint _idLen	=	strlen( data ) + 1;
	guint8 _params[ 4 + _idLen ];

	_params[0]	=	IAP2_HI_BYTE( 4 + _idLen );
	_params[1]	=	IAP2_LO_BYTE( 4 + _idLen );
	_params[2]	=	0x00;
	_params[3]	=	0x00;

	memcpy( _params + 4, data, _idLen );

	iAP2SendControlMessage( MH_DEV_IAP2( self )->plinkRunLoop->link, 0xFFFB, _params, 4 + _idLen, IAP2_CONTROL_SESSION_ID );

	return 0;
}		/* -----  end of static function write_location_data  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  send_vehicle_status
 *  Description:  
 * =====================================================================================
 */
static MHResult send_vehicle_status( MHDev * self, uint32_t remainingRange, int32_t outsideTempreture, int32_t rangeWarning )
{
	g_message("remainingRange = [%d] outsideTempreture = [%d] rangeWarning = [%d]\n", remainingRange, outsideTempreture, rangeWarning);

	gint _paramsLen = 4 + sizeof( uint16_t ) + 4 + sizeof( int16_t ) + 4 + sizeof( bool );

	guint8 * _params	=	g_malloc0( _paramsLen );
	guint8 * _data		=	NULL;
	gint _dataLen	=	0;
	gint _dataLen_t	=	0;
	gint _params_p	=	0;

	_params[0] = IAP2_HI_BYTE( 4 + sizeof( uint16_t ));
	_params[1] = IAP2_LO_BYTE( 4 + sizeof( uint16_t ));
	_params[2] = 0x00;
	_params[3] = 0x03;               /*  remainingRange */
	_params[4] = remainingRange >> 8;
	_params[5] = remainingRange & 0xFF;

	_params[6] = IAP2_HI_BYTE( 4 + sizeof( int16_t ));
	_params[7] = IAP2_LO_BYTE( 4 + sizeof( int16_t ));
	_params[8] = 0x00;
	_params[9] = 0x04;               /*  outsideTempreture */
	_params[10] = outsideTempreture >> 8;
	_params[11] = outsideTempreture & 0xFF;

	_params[12] = IAP2_HI_BYTE( 4 + sizeof( bool ));
	_params[13] = IAP2_LO_BYTE( 4 + sizeof( bool ));
	_params[14] = 0x00;
	_params[15] = 0x06;               /*  rangeWarning */
	_params[16] = rangeWarning & 0xFF;

	if( remainingRange != 0xFFFF )
	{
		_dataLen	+=	4 + sizeof( uint16_t );
		_data 	=	( uint8_t *)realloc( _data, _dataLen );	
		memcpy( _data, _params, _dataLen );
	}

	_params_p	=	4 + sizeof( uint16_t );

	if( outsideTempreture != 0xFFFF )
	{
		_dataLen_t	=	_dataLen;
		_dataLen	+=	4 + sizeof( uint16_t );
		_data 	=	( uint8_t *)realloc( _data, _dataLen );	
		memcpy( _data + _dataLen_t, _params + _params_p, ( 4 + sizeof( int16_t )));
	}

	_params_p	+=	4 + sizeof( int16_t );

	if( rangeWarning != 0xFFFF )
	{
		_dataLen_t	=	_dataLen;
		_dataLen	+=	4 + sizeof( bool );
		_data 	=	( uint8_t *)realloc( _data, _dataLen );	
		memcpy( _data + _dataLen_t, _params + _params_p, ( 4 + sizeof( bool )));
	}
	if( _dataLen != 0 )
	{
		iAP2SendControlMessage( MH_DEV_IAP2( self )->plinkRunLoop->link, 0xA101, _data, _dataLen, IAP2_CONTROL_SESSION_ID );
		g_free( _data );
	}
	g_free( _params );

	return 0;
}		/* -----  end of static function send_vehicle_status  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  write_ea_data
 *  Description:  
 * =====================================================================================
 */
static gint write_ea_data( MHDev * self, const uint8_t * buf, int32_t len )
{
	MHDevIap2 * _self	=	MH_DEV_IAP2( self );

	if( iAP2LinkQueueSendData( MH_DEV_IAP2( self )->plinkRunLoop->link, buf, len, IAP2_EA_SESSION_ID, NULL, NULL) )
		return len;
	else
		return -1;
}		/* -----  end of static function write_ea_data  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  write_ea_native_data
 *  Description:  
 * =====================================================================================
 */
static gint write_ea_native_data( MHDev * self, const uint8_t * buf, int32_t len )
{
	MHDevIap2 * _self	=	MH_DEV_IAP2( self );
	gint _res	=	0;

	_res	=	_self->eaNative_write( self, buf, len);
	
	return _res;

}		/* -----  end of static function write_ea_native_data  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  write_bt_data
 *  Description:  
 * =====================================================================================
 */
static gint write_bt_data( MHDev * self, const uint8_t * buf, int32_t len )
{
	MHDevIap2 * _self	=	MH_DEV_IAP2( self );
	//g_message("\n\nwrite_bt_data************************************ start\n");
	//DEBUG_HEX_DISPLAY( buf, len);
	//g_message("write_bt_data************************************ end\n\n\n");

	static iAP2Packet_t * iPacket	=	NULL;
	static BOOL _detect = FALSE;
	uint32_t _remlen = 0;
	uint32_t _cumlen = 0;

	if( iPacket == NULL )
	{
		iPacket	=	iAP2PacketCreateEmptyRecvPacket( MH_DEV_IAP2( self )->plinkRunLoop->link );
	}

	_remlen = iAP2PacketParseBuffer( buf, len, iPacket, 0, &_detect, NULL, NULL );

	if( _detect )
		g_message( "iAP 1.0/2.0 has been detected" );
		
	if( iAP2PacketIsComplete( iPacket ))
	{
		iAP2LinkRunLoopHandleReadyPacket( MH_DEV_IAP2( self )->plinkRunLoop, iPacket );

		iPacket	=	NULL;
	}

	if ((_remlen < len)&&(_remlen != 0))
	{
		iPacket	=	iAP2PacketCreateEmptyRecvPacket( MH_DEV_IAP2( self )->plinkRunLoop->link );
		_cumlen = iAP2PacketParseBuffer( buf+_remlen, len-_remlen, iPacket, 0, &_detect, NULL, NULL );

		if( _detect )
			g_message( "iAP 1.0/2.0 has been detected" );

		if( iAP2PacketIsComplete( iPacket ))
		{
			iAP2LinkRunLoopHandleReadyPacket( MH_DEV_IAP2( self )->plinkRunLoop, iPacket );

			iPacket	=	NULL;
		}
	}

	return len;
}		/* -----  end of static function write_bt_data  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_pipeline_status
 *  Description:
 * =====================================================================================
 */
static void _set_pipeline_status( MHDev * self, MHPb * pb, uint32_t status )
{
	g_message("%s", __func__);
	MHDevIap2 * _iap2	=	MH_DEV_IAP2( pb->mhDev );
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _iap2 );
	gint32 _ret;

	if( status == IAP2_NUM_ZERO )
	{
		if( _priv->source_status	==	IAP2_NUM_ONE )
		{
			_priv->source_status	= IAP2_NUM_ZERO;
			g_source_set_ready_time( _priv->source, -1 );

			gst_element_set_state( pb->mh_player->playbin2, GST_STATE_READY );
			pipeline_status = READY_STATUS;

			if (iAP2_pcm_handle == NULL)
			{
				g_message("source stop false iAP2_pcm_handle == NULL");
				return;
			}
			_ret	=	snd_pcm_drop( iAP2_pcm_handle );

			if ( _ret < 0 )
			{
				g_message( "%s snd_pcm_drop, failed: %s\n", __func__,snd_strerror( _ret ));
			}

			g_message("source stop success\n");
			if (NULL != _iap2->plinkRunLoop->link)
			{
				g_message("iAP2StopMLUpdate 0x4C02 when _set_pipeline_status");
				_iap2->stopUpdateFlag = 1;
				if (_iap2->libraryIdLen > 0);
				{
//					iAP2StopMLMessageUpdate(_iap2->plinkRunLoop->link, _iap2->mediaLibraryId, _iap2->libraryIdLen);
					g_message("iAP2StopMLMessageUpdate 0x4C05 when _set_pipeline_status id = %s", _iap2->mediaLibraryId);
				}
//				iAP2StopMLUpdate( _iap2->plinkRunLoop->link ); 
			}
		}else{
			g_message("source already stop status\n");
		}	
	}else if( status == IAP2_NUM_ONE ){
		if( _priv->source_status	== IAP2_NUM_ZERO )
		{
			if (iAP2_pcm_handle == NULL)
			{
				g_message("source wake up false iAP2_pcm_handle == NULL");
				return;
			}
			_ret	=	snd_pcm_prepare( iAP2_pcm_handle );

			if ( _ret < 0 )
			{
				g_message("%s snd_pcm_prepare Failed! %s\n",__func__, snd_strerror( _ret ));
			}

			_ret = snd_pcm_start( iAP2_pcm_handle );

			if ( _ret < 0 )
			{
				g_message("%s snd_pcm_start Failed! %s\n",__func__, snd_strerror( _ret ));
			}

			_priv->clock	=	UpTicks();
			g_source_set_ready_time( _priv->source, _priv->clock / 1000 );
			_priv->source_status	= IAP2_NUM_ONE;
			g_message("source wake up success\n");
			if (NULL != _iap2->plinkRunLoop->link &&  1 == _iap2->stopUpdateFlag)
			{
				g_message("iAP2StartMLUpdate when _set_pipeline_status");
				_iap2->stopUpdateFlag = 2; //source start;
//				iAP2StartMLUpdate( _iap2->plinkRunLoop->link ); 
			}
		}else{
			g_message("source already wake up\n");
		}
	}else{
		g_message( "%s set status error\n",__func__);
	}
}      /* -----  end of static function _set_pipeline_status  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _audiobook_playback_speed
 *  Description:
 * =====================================================================================
 */
static void _audiobook_playback_speed( MHDev * self, MHPb * pb, uint32_t speed )
{
	g_message("%s speed = %d", __func__,speed);
	MHDevIap2 * _iap2	=	MH_DEV_IAP2( self );
	
	if (0 == speed)
	{
		iAP2HidExecCommand(_iap2->plinkRunLoop->link, HID_TRACKING_NORMAL);
		iAP2HidExecCommandDone(_iap2->plinkRunLoop->link);
	}
	else if (1 == speed)
	{
		iAP2HidExecCommand(_iap2->plinkRunLoop->link, HID_TRACKING_INCREMENT);
		iAP2HidExecCommandDone(_iap2->plinkRunLoop->link);
	}
	else if (2 == speed)
	{
		iAP2HidExecCommand(_iap2->plinkRunLoop->link, HID_TRACKING_DECREMENT);
		iAP2HidExecCommandDone(_iap2->plinkRunLoop->link);
	}
	else{
		g_message("%s else", __func__);
	}
}      /* -----  end of static function _audiobook_playback_speed  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  send_wifi_conf_info
 *  Description:  
 * =====================================================================================
 */
static MHResult send_wifi_conf_info( MHDev * self, const uint8_t * ssid, const uint8_t * pass, uint8_t securityType, uint8_t channel )
{
	g_message( "%s \n",__func__);
	DEBUG_HEX_DISPLAY(ssid, ssid[0]);
	DEBUG_HEX_DISPLAY(pass, pass[0]);

	int _len	=	4 + ssid[0] + 4 + pass[0] + 4 + sizeof( uint8_t ) + 4 + sizeof( uint8_t ) ;

	uint8_t _params[ _len ]; 
	
	_params[0] = IAP2_HI_BYTE(4 + ssid[0] );
	_params[1] = IAP2_LO_BYTE(4 + ssid[0] );
	_params[2] = 0x00;
	_params[3] = 0x01;

	memcpy( _params + 4, ssid + 1, ssid[0] - 1 );

	_params[ 4 + ssid[0] - 1 ] = '\0';

	_params[ 4 + ssid[0] ] 		= IAP2_HI_BYTE(4 + pass[0] ); ;
	_params[ 4 + ssid[0] + 1 ]	= IAP2_LO_BYTE(4 + pass[0] ); ;
	_params[ 4 + ssid[0] + 2 ]	= 0x00;
	_params[ 4 + ssid[0] + 3 ]	= 0x02;

	memcpy( _params + 4 + ssid[0] + 4, pass + 1, pass[0] - 1 );
	
	_params[ 4 + ssid[0] + 4 + pass[0] - 1 ] = '\0';
	
	_params[ 4 + ssid[0] + 4 + pass[0] ]		= 0x00;
	_params[ 4 + ssid[0] + 4 + pass[0] + 1 ]	= 0x05;
	_params[ 4 + ssid[0] + 4 + pass[0] + 2 ]	= 0x00;
	_params[ 4 + ssid[0] + 4 + pass[0] + 3 ]	= 0x03;
	_params[ 4 + ssid[0] + 4 + pass[0] + 4 ]	= securityType & 0xFF;

	_params[ 4 + ssid[0] + 4 + pass[0] + 5 ]	= 0x00;
	_params[ 4 + ssid[0] + 4 + pass[0] + 6 ]	= 0x05;
	_params[ 4 + ssid[0] + 4 + pass[0] + 7 ]	= 0x00;
	_params[ 4 + ssid[0] + 4 + pass[0] + 8 ]	= 0x04;
	_params[ 4 + ssid[0] + 4 + pass[0] + 9 ]	= channel & 0xFF;

	iAP2SendControlMessage( MH_DEV_IAP2( self )->plinkRunLoop->link, 0x5703, _params, _len, IAP2_CONTROL_SESSION_ID );

	return 0;
}		/* -----  end of static function send_vehicle_status  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _quit
 *  Description:  
 * =====================================================================================
 */
static gboolean _quit( gpointer object )
{
	MHDev * _dev	=	MH_DEV( object );
	MHDevIap2 * _self	=	MH_DEV_IAP2( object );
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _self );

	gint32 _ret;
	g_message("iap2---->%s", __func__);

	if( iAP2_pcm_handle	!=	NULL )
	{
//		_ret	=	snd_pcm_drop( iAP2_pcm_handle );

//		if ( _ret < 0 )
//		{
//			g_message( "snd_pcm_set_params, failed: %s\n", snd_strerror( _ret ));
//		}

		_ret	=	snd_pcm_close(iAP2_pcm_handle);

		if ( _ret < 0 )
		{
			g_message( "snd_pcm_close, failed: %s\n", snd_strerror( _ret ));
		}

		iAP2_pcm_handle = NULL;
	}

	throw_count	=	0;

	if(	timeout_source != NULL ) 
	{
		g_source_destroy( timeout_source );
		timeout_source	= NULL;
	}
	if(  MH_DEV_IAP2( _self )->device_name != NULL )
	{
		g_free( MH_DEV_IAP2( _self )->device_name );
	}
	if( MH_DEV_IAP2( _self )->libraryRevision != NULL )
	{
		g_free( MH_DEV_IAP2( _self )->libraryRevision );
		MH_DEV_IAP2( _self )->libraryRevision	= NULL;
	}
	if( MH_DEV_IAP2( _self )->mediaLibraryName != NULL )
	{
		g_free(MH_DEV_IAP2( _self )->mediaLibraryName );
	}
	if( MH_DEV_IAP2( _self )->mediaLibraryId != NULL )
	{
		g_free(MH_DEV_IAP2( _self )->mediaLibraryId );
	}
	if( MH_DEV_IAP2( _self )->radioLibraryRevision != NULL )
	{
		g_free( MH_DEV_IAP2( _self )->radioLibraryRevision );
		MH_DEV_IAP2( _self )->radioLibraryRevision	= NULL;
	}

	if( MH_DEV_IAP2( _self )->radioLibraryName != NULL )
	{
		g_free(MH_DEV_IAP2( _self )->radioLibraryName );
	}
	if( MH_DEV_IAP2( _self )->radioLibraryId != NULL )
	{
		g_free(MH_DEV_IAP2( _self )->radioLibraryId );
	}
	if( MH_DEV_IAP2( _self )->app_name != NULL )
	{
		g_free( MH_DEV_IAP2( _self )->app_name );
	}

	if( _self->currentData != NULL )
	{
		g_free( _self->currentData );
	}
	if( _self->macAddress !=	NULL )
		g_free( _self->macAddress );

	g_free( _dev->type );

	if( _priv->mainloop != NULL)
	{
		g_main_loop_quit( _priv->mainloop );
	}

	return G_SOURCE_REMOVE;
}		/* -----  end of static function _quit  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pb_quit
 *  Description:  
 * =====================================================================================
 */
static gboolean  _pb_quit( gpointer user_data)
{
	MHPb * _pb	=	(MHPb *)user_data;
	if( _pb != NULL)
	{
		mh_pb_dispatch( _pb, EVENT_CHANGE, GUINT_TO_POINTER( READY_STATUS ), NULL );

		if( _pb->mh_player	!=	NULL)
		{
			g_object_unref( _pb->mh_player );
			_pb->mh_player	=	NULL;
		}

		if( _pb->playlist != NULL ) 
		{
			g_object_unref(_pb->playlist);
			_pb->playlist	=	NULL;
		}

	}
	return G_SOURCE_REMOVE;
}		/* -----  end of static function _pb_quit  ----- */
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispose
 *  Description:
 * =====================================================================================
 */
static void _dispose( GObject * object )
{
	MHDevIap2 * _self	=	MH_DEV_IAP2( object );
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _self );
	gint32 _ret;
	GSource * _source;
	g_message("iap2---->%s", __func__);
	if( iAP2_pcm_handle	!=	NULL )
	{
		_ret	=	snd_pcm_drop( iAP2_pcm_handle );

		if ( _ret < 0 )
		{
			g_message( "snd_pcm_set_params, failed: %s\n", snd_strerror( _ret ));
		}
	}

	if(( g_thread_self() !=	_priv->thread)&&(  _priv->thread != NULL ))
	{
		_source	=	g_idle_source_new();

		g_source_set_callback( _source, _quit, object, NULL);

		g_source_attach( _source, _priv->context );

		g_source_unref( _source );

		g_thread_join( _priv->thread );
	}
	else
	{
		_quit( object );

		if( _priv->thread != NULL )
			g_thread_unref( _priv->thread );
	}

	_source	=	g_idle_source_new();

	g_source_set_callback( _source, _pb_quit, _self->pb, NULL);

	mh_io_dispatch( MH_IO(_self), _source );

	g_source_unref( _source );

	if( _priv->context	!=	NULL )
	{
		g_main_context_unref( _priv->context );
		_priv->context	=	NULL;
	}
	iAP2FileCleanupTransfer(_self);

	iAP2LinkRunLoopDetached( MH_DEV_IAP2( _self )->plinkRunLoop );

	if( timeout_Source != NULL )
	{
		g_source_destroy( timeout_Source );

		g_source_unref( timeout_Source );

		timeout_Source = NULL;
	}

	g_free( MH_DEV( _self )->serial );
	if (MH_DEV( _self )->devPath != NULL)
		g_free( MH_DEV( _self )->devPath );
    g_message("%s end", __func__);

	G_OBJECT_CLASS( mh_dev_iap2_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _finalize
 *  Description:
 * =====================================================================================
 */
static void _finalize( GObject * object )
{
	MHDevIap2 * _self	=	MH_DEV_IAP2( object );
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _self );

	g_message("%s",__func__);
	GSList *iterator = NULL;
	//g_message("%s link = %p",__func__, link);

	for (iterator = _iAP2GlobalInfolist; iterator; iterator = iterator->next) 
	{
		if (_self == ((iAP2GlobalInfo *)iterator->data)->piAP2Object)
		{
//			iAP2LinkRunLoopDelete( ((iAP2GlobalInfo *)iterator->data)->piAP2Object->plinkRunLoop );
			
			g_message("remove iAP2GlobalInfo from _iAP2GlobalInfolist");
			_iAP2GlobalInfolist = g_slist_remove( _iAP2GlobalInfolist,	iterator->data);
			
			break;
		}
	}

	G_OBJECT_CLASS( mh_dev_iap2_parent_class )->finalize( object );
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  send_packet
 *  Description:  
 * =====================================================================================
 */
void send_packet ( struct iAP2Link_st *link, iAP2Packet_t *packet )
{
	GSList *iterator = NULL;
	for (iterator = _iAP2GlobalInfolist; iterator; iterator = iterator->next) 
	{
		if (link == ((iAP2GlobalInfo *)iterator->data)->piAP2Object->plinkRunLoop->link)
		{
			 ((iAP2GlobalInfo *)iterator->data)->piAP2Object->write(iAP2PacketGenerateBuffer(packet), packet->bufferLen,
			 	 ((iAP2GlobalInfo *)iterator->data)->piAP2Object->_iap2hidFd,MH_DEV(((iAP2GlobalInfo *)iterator->data)->piAP2Object));
			 return;
		}
	}
	printf("send_packet not find link \n");

//	if( iAP2Object != NULL )
//		iAP2Object->write(iAP2PacketGenerateBuffer(packet), packet->bufferLen);
}		/* -----  end of static function send_packet  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  data_ready
 *  Description:  
 * =====================================================================================
 */
BOOL data_ready ( struct iAP2Link_st *link, uint8_t *data, uint32_t dataLen, uint8_t session )
{
//	g_message("%s",__func__);

	GVariant * _var;
	MHDevIap2 * _iAP2Object = NULL;
	GSList *iterator = NULL;
	for (iterator = _iAP2GlobalInfolist; iterator; iterator = iterator->next) 
	{
		if (link == ((iAP2GlobalInfo *)iterator->data)->piAP2Object->plinkRunLoop->link)
		{
			_iAP2Object = ((iAP2GlobalInfo *)iterator->data)->piAP2Object;
			break;
		}
	}

	switch(session)
	{
	case IAP2_CONTROL_SESSION_ID:
//		printf("control session\n");
		iAP2ParseControlSession(link, data, dataLen, session);
		break;
	case IAP2_FILE_SESSION_ID:
//		printf("file transfer session %d\n", dataLen);
		iAP2ParseFileSession(link, data, dataLen, session);
		break;
	case IAP2_EA_SESSION_ID:
		_var	=	g_variant_new_fixed_array( G_VARIANT_TYPE_BYTE, data, dataLen, sizeof( guchar ));
		_var	=	g_variant_new_variant( _var );
		g_signal_emit_by_name( _iAP2Object, "ea_session_data", _var );
		break;
	default:
//		g_message("unhandled session message: id[0x%X]\n", session);
//		g_assert(0);
		g_critical("unhandled session message: id[0x%X]\n", session);
		break;
	}

	return TRUE;
}		/* -----  end of function data_ready  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  is_connected
 *  Description:  
 * =====================================================================================
 */
void is_connected ( struct iAP2Link_st * link, BOOL bConnected )
{
	g_message( "iAP2 Link[link = %p] is %s", link, bConnected ? "Connected" : "Disconnected" );
}		/* -----  end of function is_connected  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  send_detect
 *  Description:  
 * =====================================================================================
 */
void send_detect ( struct iAP2Link_st *link, BOOL bBad )
{
	uint8_t _detect[]	=	{0xFF, 0x55, 0x02, 0x00, 0xEE, 0x10};

	GSList *iterator = NULL;
	g_message("%s link = %p",__func__, link);

	for (iterator = _iAP2GlobalInfolist; iterator; iterator = iterator->next) 
	{
		if (link == ((iAP2GlobalInfo *)iterator->data)->piAP2Object->plinkRunLoop->link)
		{
			 ((iAP2GlobalInfo *)iterator->data)->piAP2Object->write(_detect, sizeof(_detect),
			 	 ((iAP2GlobalInfo *)iterator->data)->piAP2Object->_iap2hidFd, MH_DEV( ((iAP2GlobalInfo *)iterator->data)->piAP2Object));			 
			 return;
		}
	}

//	iAP2Object->write(_detect, sizeof(_detect));
}		/* -----  end of function send_detect  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_property
 *  Description:  
 * =====================================================================================
 */
static void _get_property( GObject * object, guint property_id, GValue * value,
		GParamSpec * spec)
{
	MHDevIap2 * _self	=	MH_DEV_IAP2( object );
	
	if (NULL == _self)
	{
		g_message("%s dev _self == NULL", __func__);
		return;
	}
	switch( property_id )
	{
		case PROP_DEV_BT_IAP2_MAC:
			g_value_set_string( value, _self->macAddress );
			break;

		case PROP_DEV_EA_NATIVE_FLAG:
			g_value_set_boolean( value, eaNativeFlag);
			break;

		default:
			break;
	}
}		/* -----  end of static function _get_property  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_iap2_init
 *  Description:
 * =====================================================================================
 */
static void mh_dev_iap2_init( MHDevIap2 * self )
{
	g_message("%s---->%p\n", __func__, self);
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( self );

	MHDev * _dev	=	MH_DEV( self );
	g_message("%s self = %p",__func__,self);

//	_priv->context	=	g_main_context_new();
//	_priv->mainloop	=	g_main_loop_new( _priv->context, FALSE );
//	_priv->thread	=	g_thread_new( "pushThread", pushThread, self);

	_priv->context	=	NULL;
	_priv->mainloop	=	NULL;
	_priv->thread	=	NULL;
	_priv->source_status	=	0;

	_dev->type	=	g_strdup("iap2");	
	_dev->iapType = mh_misc_get_local_iap_device_mode();
	g_message("%s ======================_dev = %p",__func__,_dev);
	g_message("%s ======================_dev->iapType = %d",__func__,_dev->iapType);

	self->syncComplete	=	FALSE;
	self->oldStatus	=	READY_STATUS;
	self->curStatus	=	READY_STATUS;
	self->curphoneStatus	=	READY_STATUS;
	self->mediaInfoFlag	=	FALSE;	
	self->deviceNameFlag	=	FALSE;	
	self->repeatFlag	=	FALSE;	
	self->shuffleFlag	=	FALSE;	
	self->sample_rate	=	44100;
	self->screenMode	=	IAP2_DATA_FRIST_NOTIFY;
	self->indentifyFlag	=	FALSE;
	self->appNameFlag	=	FALSE;
	self->curStatusFlag =   FALSE;
	self->speedFlag 	=   FALSE;
    self->_iap2hidFd 	=   0;
	self->radioLibraryFlag = 0;
	self->stopUpdateFlag = 0;
	memset(self->xfers, 0, sizeof(self->xfers));

	self->mode	=	mh_misc_get_local_iap_device_mode();
	if( self->mode	== MISC_IAP)
	{
		_priv->context	=	g_main_context_new();
		_priv->mainloop	=	g_main_loop_new( _priv->context, FALSE );
		_priv->thread	=	g_thread_new( "pushThread", pushThread, self);

	}

#if 1 //double iap2
	//insert a new iAP2Object
	self->plinkRunLoop	=	iAP2LinkRunLoopCreateAccessory( &synParam, NULL, send_packet, data_ready, 
				is_connected, send_detect, TRUE, 10, NULL );
//	linkRunLoop = self->plinkRunLoop;

	iAP2GlobalInfo * _ldata;
	_ldata	=(iAP2GlobalInfo *)g_new(iAP2GlobalInfo,1);
	_ldata->piAP2Object =	self;
	_ldata->plinkRunLoop = self->plinkRunLoop;
	g_message("iAP2LinkRunLoopCreateAccessory start ");

	

	_iAP2GlobalInfolist =	g_slist_prepend(_iAP2GlobalInfolist, _ldata);
	g_message("init _ldata->piAP2Object = %p", _ldata->piAP2Object);
//	g_message("mh_dev_iap2_init iAP2Object = %p", iAP2Object);
#else
	iAP2Object	=	self;
#endif 
	self->transportType	=	MH_DEV_USB_IAP;
	self->macAddress = NULL;
}       /* -----  end of static function mh_dev_iap2_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_iap2_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_dev_iap2_class_init( MHDevIap2Class * klass )
{
	MHDevClass * _parentClass	=	MH_DEV_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	_dispose;
	_gobjectClass->finalize	=	_finalize;
	_gobjectClass->get_property =   _get_property;

	/* assemble ios of mh_dev_iap2 class */

	/* assemble methods of mh_dev_iap2 class */
	_parentClass->play_by_list	=	_play_by_list;
	_parentClass->play_radio_by_index	=	_play_radio_by_index;
	_parentClass->stop	=	_stop;
	_parentClass->play	=	_play;
	_parentClass->pause	=	_pause;
	_parentClass->play_pause	=	_play_pause;
	_parentClass->resume	=	_resume;
	_parentClass->forward	=	_forward;
	_parentClass->forward_done	=	_forward_done;
	_parentClass->backward	=	_backward;
	_parentClass->backward_done	=	_backward_done;
	_parentClass->set_index	=	_set_index;
	_parentClass->set_speed	=	_set_speed;
	_parentClass->set_repeat	=	_set_repeat;
	_parentClass->set_shuffle	=	_set_shuffle;
	_parentClass->set_buffer_time	=	_set_buffer_time;
	_parentClass->start_scan	=	_start_scan;
	_parentClass->next	=	_next;
	_parentClass->previous	=	_previous;
	_parentClass->seek 	= 	_seek;	

	_parentClass->save_playlist	=	NULL;
	_parentClass->restore_playlist	=	_restore_playlist;
	_parentClass->get_radiolist = _get_radiolist;
	_parentClass->attach_pb	=	_attach_pb;

	_parentClass->request_app_launch	=	request_app_launch;
	_parentClass->write_ea_data	=	write_ea_data;
	_parentClass->set_pipeline_status	=	_set_pipeline_status;
	_parentClass->audiobook_playback_speed	=	_audiobook_playback_speed;
	_parentClass->write_location_data	=	write_location_data;
	_parentClass->send_vehicle_status	=	send_vehicle_status;
	_parentClass->write_bt_data			=	write_bt_data;
	_parentClass->send_wifi_conf_info	=	send_wifi_conf_info;
	_parentClass->write_ea_native_data	=	write_ea_native_data;

	/* Ios */
	/* Signals */
	signals[ EA_SESSION_START ]	=	
		g_signal_new( "ea_session_start",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
//				2,
//				G_TYPE_INT, G_TYPE_INT );
				3,
				G_TYPE_INT, G_TYPE_INT, G_TYPE_INT );

	signals[ EA_SESSION_STOP ]	=	
		g_signal_new( "ea_session_stop",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1,
				G_TYPE_INT );

	signals[ EA_SESSION_DATA ]	=	
		g_signal_new( "ea_session_data",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1,
				G_TYPE_VARIANT );

	signals[ START_LOCATION_INFO ]	=	
		g_signal_new( "start_location_info",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1,
				G_TYPE_INT );
	signals[STOP_LOCATION_INFO]	=	
		g_signal_new("stop_location_info",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				0);

	signals[ START_VEHICLE_STATUS_UPDATES ]	=	
		g_signal_new( "start_vehicle_status_updates",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1,
				G_TYPE_INT );

	signals[STOP_VEHICLE_STATUS_UPDATES]	=	
		g_signal_new("stop_vehicle_status_updates",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				0);

	signals[ BT_DATA ]	=	
		g_signal_new( "bt_data",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1,
				G_TYPE_VARIANT );

	signals[REQ_ACCESSORY_WIFI_CONF_INFO]	=	
		g_signal_new("req_accessory_wifi_conf_info",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				0);

	signals[ WIFI_CARPLAY_UPDATE ]	=	
		g_signal_new( "wifi_carplay_update",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1,
				G_TYPE_INT );
	
	signals[ EA_NATIVE_START ]	=	
		g_signal_new( "ea_native_start",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				0);

	signals[ EA_NATIVE_STOP ]	=	
		g_signal_new( "ea_native_stop",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				0);

	signals[ EA_NATIVE_DATA ]	=	
		g_signal_new( "ea_native_data",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1,
				G_TYPE_VARIANT );

	signals[ EA_SESSION_SEND_PB ]	=	
		g_signal_new( "ea_session_send_pb",
				G_TYPE_FROM_CLASS( klass ),
				G_SIGNAL_RUN_LAST,
				0,
				NULL,
				NULL,
				g_cclosure_marshal_generic,
				G_TYPE_NONE,
				1,
				G_TYPE_INT );

	deviAPProperties[PROP_DEV_BT_IAP2_MAC]	=	
		g_param_spec_string( "bt_mac_address", "MHDevIap2 property", "Bluetooth mac address",
				"", G_PARAM_READABLE );	

	deviAPProperties[PROP_DEV_EA_NATIVE_FLAG]	=	
		g_param_spec_boolean( "ea_native_flag", "MHDevIap2 property", "ea native flag",
				0, G_PARAM_READABLE );	

	g_object_class_install_properties( _gobjectClass, N_PROPERTIES, deviAPProperties );
}       /* -----  end of static function mh_dev_iap2_class_init  ----- */

void iAP2LinkRunLoopInitImplementation (iAP2LinkRunLoop_t* linkRunLoop)
{
}

void iAP2LinkRunLoopCleanupImplementation (iAP2LinkRunLoop_t* linkRunLoop)
{
}

uint32_t iAP2LinkRunLoopGetResetEventMask (iAP2LinkRunLoop_t* linkRunLoop)
{
	uint32_t	_mask	=	linkRunLoop->eventMask;

	linkRunLoop->eventMask	=	kiAP2LinkRunLoopEventMaskNone;

	return _mask;
}

BOOL iAP2LinkRunLoopProtectedCall (iAP2LinkRunLoop_t* linkRunLoop,
                                   void* arg,
                                   BOOL (*func)(iAP2LinkRunLoop_t* linkRunLoop, void* arg))
{
	return func(linkRunLoop, arg);
}

BOOL iAP2LinkRunLoopWait (iAP2LinkRunLoop_t* linkRunLoop)
{
	return TRUE;
}

void iAP2LinkRunLoopSetEventMaskBit (iAP2LinkRunLoop_t*         linkRunLoop,
                                     iAP2LinkRunLoopEventMask_t bit)
{
	linkRunLoop->eventMask	|=	bit;
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  ack_timeout
 *  Description:
 * =====================================================================================
 */
static gboolean ack_timeout(gpointer user_data)
{
	if ( user_data == NULL )
	{
		printf( "%s : user_data is NULL\n",__func__ );	
		return FALSE;
	}

	timeoutparam * _param = ( timeoutparam * )user_data;

	_param->callback_t(_param->timer_t, iAP2TimeGetCurTimeMs());

	return FALSE;
}      /*  -----  end of static function ack_timeout  ----- */ 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _iAP2TimeCancelCallback
 *  Description:
 * =====================================================================================
 */
void _iAP2TimeCancelCallback (iAP2Timer_t* timer)
{
	if( timeout_Source != NULL )
	{
		g_source_destroy( timeout_Source );

		g_source_unref( timeout_Source );

		timeout_Source = NULL;
	}
	else{
		g_message("%s timeout_Source is NULL!",__func__);
	}
}      /*  -----  end of static function _iAP2TimeCancelCallback  ----- */ 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _iAP2TimeCallbackAfter
 *  Description:
 * =====================================================================================
 */
BOOL _iAP2TimeCallbackAfter (iAP2Timer_t* timer,
                             uint32_t     delayMs,
                             iAP2TimeCB_t callback)
{
	//g_message("%s\n",__func__);

	timeoutparam *_param	= g_new( timeoutparam, 1 );
	_param->timer_t 		= timer;
	_param->callback_t		= callback;

	timeout_Source	=	g_timeout_source_new( delayMs );
	g_source_set_callback( timeout_Source, ack_timeout, _param, g_free );
	mh_io_dispatch( MH_IO( ((iAP2GlobalInfo *)_iAP2GlobalInfolist->data)->piAP2Object ), timeout_Source );

	return TRUE;
}      /*  -----  end of static function _iAP2TimeCallbackAfter  ----- */ 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _iAP2TimePerformCallback
 *  Description:
 * =====================================================================================
 */
void _iAP2TimePerformCallback (iAP2Timer_t* timer,
		                               iAP2TimeCB_t callback)
{
	g_message("%s\n",__func__);
	timeoutparam *_param	= g_new( timeoutparam, 1 );
	_param->timer_t			= timer;
	_param->callback_t		= callback;
//
//	timeout_id = g_timeout_add( iAP2TimeGetCurTimeMs(), ( GSourceFunc )timeoutcallback, timer );
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, ack_timeout, _param, g_free );

	mh_io_dispatch( MH_IO( ((iAP2GlobalInfo *)_iAP2GlobalInfolist->data)->piAP2Object ), _source );

	g_source_unref( _source );
}      /*  -----  end of static function _iAP2TimePerformCallback  ----- */ 

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _iAP2TimeCleanupCallback
 *  Description:
 * =====================================================================================
 */
void _iAP2TimeCleanupCallback (iAP2Timer_t* timer)
{	
	g_message("%s\n",__func__);
	if( timeout_Source != NULL )
	{
		g_source_destroy( timeout_Source );

		g_source_unref( timeout_Source );

		timeout_Source = NULL;
	}
	else{
		g_message("%s timeout_Source is NULL!",__func__);
	}
}      /*  -----  end of static function _iAP2TimeCleanupCallback  ----- */ 

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  signalFunc
 *  Description:  
 * =====================================================================================
 */
static gboolean signalFunc ( gpointer user_data )
{
	g_rec_mutex_lock( loop_mutex_iAP2 );
	signalparam *_param = (signalparam*)user_data;
	iAP2LinkRunLoopProtectedCall( _param->plinkRunLoop, _param->arg, iAP2LinkRunLoopRunOnce);
	g_rec_mutex_unlock(loop_mutex_iAP2);

	return G_SOURCE_REMOVE;
}		/* -----  end of static function signalFunc  ----- */

void iAP2LinkRunLoopSignal (iAP2LinkRunLoop_t* linkRunLoop, void* arg)
{
	GSList *iterator = NULL;
	MHDevIap2 * _iAP2Object = NULL;
	
	signalparam *_param	= g_new( signalparam, 1 );
	_param->plinkRunLoop 		= linkRunLoop;
	_param->arg		= arg;

	for (iterator = _iAP2GlobalInfolist; iterator; iterator = iterator->next) 
	{
		if (linkRunLoop == ((iAP2GlobalInfo *)iterator->data)->plinkRunLoop)
		{
			_iAP2Object = ((iAP2GlobalInfo *)iterator->data)->piAP2Object;
			break;
		}
	}

	if( _iAP2Object != NULL )
	{
		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, signalFunc, _param, NULL );

		mh_io_dispatch( MH_IO( _iAP2Object ), _source );

		g_source_unref( _source );
	}
	else
	{
		g_message("iAP2LinkRunLoopSignal, not find _iAP2Object [linkRunLoop = %p]", linkRunLoop);
	}
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  iAP2InitGetLink
 *  Description:  
 * =====================================================================================
 */
iAP2Link_t * iAP2InitGetLink ()
{
	//return linkRunLoop->link;
	return NULL;
}		/* -----  end of function iAP2InitGetLink  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  setResample
 *  Description:  
 * =====================================================================================
 */
static gboolean setResample( gpointer user_data )
{
	MHDevIap2 * _iap2	=	( MHDevIap2 * )user_data;
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _iap2 );
	g_source_set_ready_time( _priv->source, -1 );
	gint32 _ret;

	gst_element_set_state( _iap2->pb->mh_player->playbin2, GST_STATE_READY );
	pipeline_status = READY_STATUS;
	_iap2->sample_rate	=	_iap2->sample_rate_num;

//	GstCaps * _caps;
//
//	_caps   =   gst_caps_new_simple( "audio/x-raw-int",
//					"endianness", G_TYPE_INT, 1234,
//					"signed", G_TYPE_BOOLEAN, TRUE,
//					"width", G_TYPE_INT, 16,
//					"depth", G_TYPE_INT, 16,
//					"rate", G_TYPE_INT, iAP2Object->sample_rate,
//					"channels", G_TYPE_INT, 2,
//					NULL );
//
//	g_object_set( appsrc, "caps", _caps, NULL );
//
//	gst_caps_unref( _caps );

	if( iAP2_pcm_handle	!= NULL )
	{
		_ret	=	snd_pcm_drop( iAP2_pcm_handle );

		if ( _ret < 0 )
		{
			g_message( "snd_pcm_drop, failed: %s\n", snd_strerror( _ret ));
		}

		_ret	=	snd_pcm_set_params( iAP2_pcm_handle,
				SND_PCM_FORMAT_S16_LE,
				SND_PCM_ACCESS_RW_INTERLEAVED,
				IAP2_PCM_CHANNEL_NUM,
				_iap2->sample_rate,
				1,
				IAP2_PCM_LATENCY_US );

		if ( _ret < 0 )
		{
			g_message( "snd_pcm_set_params, failed: %s\n", snd_strerror( _ret ));
			return FALSE;
		}

		_ret	=	snd_pcm_prepare( iAP2_pcm_handle );

		if ( _ret < 0 )
		{
			g_message("snd_pcm_prepare Failed! %s\n", snd_strerror( _ret ));
			return FALSE;
	}

		_ret = snd_pcm_start( iAP2_pcm_handle );

		if ( _ret < 0 )
		{
			g_message("snd_pcm_start Failed! %s\n", snd_strerror( _ret ));
			return FALSE;
		}
	}

	_priv->clock	=	UpTicks() + 100000000;

//	if( iAP2Object->sample_rate == 32000 )
//	{
//		_priv->running	=	160000000;
//	}else{
//		_priv->running	=	80000000;
//	}
//	
//	gst_element_set_state( iAP2Object->pb->mh_player->playbin2, GST_STATE_PLAYING );
	g_source_set_ready_time( _priv->source, _priv->clock / 1000 );

	return FALSE;
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _setResample
 *  Description:  
 * =====================================================================================
 */
static gboolean _setResample( gpointer user_data )
{
	MHDevIap2 * _iap2	=	( MHDevIap2 * )user_data;
	MHDevIap2Private * _priv	=	mh_dev_iap2_get_instance_private( _iap2 );

	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, setResample, _iap2, NULL );

	g_source_attach( _source, _priv->context );

	g_source_unref( _source );

	return	FALSE;	
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  iAP2SetResample
 *  Description:  
 * =====================================================================================
 */
void iAP2SetResample (MHDevIap2 * _iAP2Object)
{
	if(( _iAP2Object != NULL )&&( _iAP2Object->pb != NULL )&&(_iAP2Object->pb->mhDev != NULL ))
	{
		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, _setResample, _iAP2Object, NULL );

		mh_io_dispatch( MH_IO( _iAP2Object ), _source );

		g_source_unref( _source );
	}else{
		_iAP2Object->sample_rate	=	_iAP2Object->sample_rate_num;
		g_message("%s sample_rate = [%d]",__func__,_iAP2Object->sample_rate);
	}
}      /*  -----  end of static function iAP2SetResample  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _stopTimeout
 *  Description:  
 * =====================================================================================
 */
static gboolean _stopTimeout(gpointer user_data)
{
	if(	timeout_source != NULL ) 
	{
		g_source_destroy( timeout_source );
		timeout_source = NULL;
	}

	g_message("%s\n",__func__);

	return FALSE;
}      /*  -----  end of static function _stopTimeout  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  iAP2StopMediaLibraryUpdateTimeout
 *  Description:  
 * =====================================================================================
 */
void iAP2StopMediaLibraryUpdateTimeout (MHDevIap2 * _iAP2Object)
{
	if(( _iAP2Object != NULL )&&( timeout_source != NULL ))
	{
		GSource * _source	=	g_idle_source_new();

		g_source_set_callback( _source, _stopTimeout, NULL, NULL );

		mh_io_dispatch( MH_IO( _iAP2Object ), _source );

		g_source_unref( _source );
	}
}      /*  -----  end of static function iAP2StopMediaLibraryUpdateTimeout  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _timeout
 *  Description:  
 * =====================================================================================
 */
static gboolean _timeout(gpointer user_data)
{
	MHDevIap2 * _iap2	=	( MHDevIap2 * )user_data;

	g_signal_emit_by_name( MH_DEV( _iap2 ), "dev_events", MH_DEV_FINISH, MH_ITEM_NONE, 0, 0);

	if(	timeout_source != NULL ) 
	{
		g_source_destroy( timeout_source );
		timeout_source = NULL;
	}

	g_message("%s\n",__func__);

	return FALSE;
}      /*  -----  end of static function _timeout  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  iAP2StartMediaLibraryUpdateTimeout
 *  Description:  
 * =====================================================================================
 */
void iAP2StartMediaLibraryUpdateTimeout (MHDevIap2 * _iAP2Object)
{
	if( _iAP2Object != NULL )
	{
		timeout_source =	g_timeout_source_new( IAP2_MEDIA_LIBRARY_UPDATE_TIMEOUT ); 

		g_source_set_callback( timeout_source, _timeout, _iAP2Object, NULL );

		mh_io_dispatch( MH_IO( _iAP2Object ), timeout_source );

		g_source_unref(timeout_source);
	}
}      /*  -----  end of static function iAP2StartMediaLibraryUpdateTimeout  ----- */
