/*
 * Generated by object-codegen.
 */
#include <stdio.h>
#include <glib.h>
#include <mh_core.h>

#include <sys/poll.h>
#include <libudev.h>
#include <sys/mount.h>
#include <sys/wait.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

#include "dev_mtp.h"

static struct udev * udevCtx;
static GPollFD udevFd;
static struct udev_monitor * udevMonitor;
const gchar * vendorId, * productId;

extern MHDevMtp * mtpObj;
extern libusb_context * usbCtx;
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _is_mtp
 *  Description:  
 * =====================================================================================
 */
static gboolean _is_mtp( struct udev_list_entry * properties )
{
	struct udev_list_entry * _entry, * _model;

	_model	=	udev_list_entry_get_by_name( properties, "ID_MTP_DEVICE" );

	if( _model != NULL &&  g_strcmp0( udev_list_entry_get_value( _model ), "1" ) == 0 )
	{
		return TRUE;
	}

	return FALSE;
}		/* -----  end of static function _is_mtp  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _mount_mtp
 *  Description:  
 * =====================================================================================
 */
static MHDevMtp * _mount_mtp( struct udev_list_entry * properties )
{
	struct udev_list_entry * _model;
	const gchar * _devNode, * _serial, * _type;
	pid_t _pid;
	int _status, _retStat;
	MHDevMtp * _ret;

	_model	=	udev_list_entry_get_by_name( properties, "ID_VENDOR_ID" );
	vendorId	=	udev_list_entry_get_value( _model );

	_model	=	udev_list_entry_get_by_name( properties, "ID_MODEL_ID" );
	productId	=	udev_list_entry_get_value( _model );

	_model	=	udev_list_entry_get_by_name( properties, "ID_SERIAL_SHORT" );
	_serial	=	udev_list_entry_get_value( _model );

	_ret	=	g_object_new( MH_TYPE_DEV_MTP, "io-name", "mtp", NULL );

	MH_DEV( _ret )->serial	=	g_strdup( _serial );

	return _ret;
}		/* -----  end of static function _mount_mtp  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _serial_compare
 *  Description:  
 * =====================================================================================
 */
static gint _serial_compare( gconstpointer a, gconstpointer b )
{
	return g_strcmp0( MH_DEV(a)->serial, b );
}		/* -----  end of static function _serial_compare  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _parse_events
 *  Description:  
 * =====================================================================================
 */
static gboolean _parse_events( gpointer user_data )
{
	MHCore * _core	=	MH_CORE( user_data );
	struct udev_device * _udevDev;
	struct udev_list_entry * _properties;

	_udevDev	=	udev_monitor_receive_device( udevMonitor );

	if( _udevDev )
	{
		const gchar * _udevAction;

		_udevAction	=	udev_device_get_action( _udevDev );

		_properties	=	udev_device_get_properties_list_entry( _udevDev );

		if( _is_mtp( _properties ))
		{
			if( g_strcmp0( _udevAction, "add" ) == 0 )
			{
				MHDevMtp * _mtp;

				/* create a new device node if the mtp is mountable */
				if(( _mtp = _mount_mtp( _properties )) != NULL )
				{
				}
				else
				{
					g_warning( "mount mtp failed" );
				}
			}
			else
			if( g_strcmp0( _udevAction, "remove" ) == 0 )
			{
				const gchar * _serial;
				struct udev_list_entry * _model;
				MHDevMtp * _dev;

				_model	=	udev_list_entry_get_by_name( _properties, "ID_SERIAL_SHORT" );
				_serial	=	udev_list_entry_get_value( _model );

				_dev	=	MH_DEV_MTP( mh_core_find_dev_custom( _serial, _serial_compare ));

				if( _dev != NULL )
				{
					gboolean _ret;

					mh_core_detach_dev( MH_DEV( _dev ));

					g_object_unref( _dev );
				}
				else
				{
					if( mtpObj != NULL )
					{
						g_object_unref( mtpObj );

						mtpObj	=	NULL;
					}
					else
						g_warning( "serial %s not found", _serial );
				}
			}
			else
			{
				g_warning( "Unknown udev action( %s ) received", _udevAction );
			}
		}

		udev_device_unref( _udevDev );
	}

	return G_SOURCE_CONTINUE;
}		/* -----  end of static function _parse_events  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _prepare
 *  Description:  
 * =====================================================================================
 */
static gboolean _prepare( GSource * source, gint * timeout )
{
	* timeout	=	-1;
	
	return FALSE;
}		/* -----  end of static function _prepare  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _check
 *  Description:  
 * =====================================================================================
 */
static gboolean _check( GSource * source )
{
	gboolean _ret	=	FALSE;

	if( udevFd.revents != 0 )
	{
		_ret	=	TRUE;
	}

	return _ret;
}		/* -----  end of static function _check  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _dispatch
 *  Description:  
 * =====================================================================================
 */
static gboolean _dispatch( GSource * source, GSourceFunc callback, gpointer user_data )
{
	return callback( user_data );
}		/* -----  end of static function _dispatch  ----- */

static GSourceFuncs _funcs	=	
{
	.prepare	=	_prepare,
	.check		=	_check,
	.dispatch	=	_dispatch
};

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _scan_mtp
 *  Description:  
 * =====================================================================================
 */
static gboolean _scan_mtp()
{
	struct udev_enumerate * _enum;
	struct udev_list_entry * _mtp, * _entry, * _properties;
	struct udev_device * _udevDev;

	_enum	=	udev_enumerate_new( udevCtx );

	if( _enum == NULL )
	{
		g_warning( "udev_enumerate_new failed" );

		return FALSE;
	}

	udev_enumerate_add_match_subsystem( _enum, "usb" );

	udev_enumerate_scan_devices( _enum );

	_mtp	=	udev_enumerate_get_list_entry( _enum );

	udev_list_entry_foreach( _entry, _mtp )
	{
		const gchar * _path	=	udev_list_entry_get_name( _entry );
		struct udev_list_entry * _entry1;

		_udevDev	=	udev_device_new_from_syspath( udevCtx, _path );

		_properties	=	udev_device_get_properties_list_entry( _udevDev );

		if( _is_mtp( _properties ))
		{
			MHDevMtp * _mtp	=	NULL;

			if(( _mtp = _mount_mtp( _properties )) != NULL )
			{
			}
			else
			{
				g_warning( "mount mtp failed" );
			}
		}

		udev_device_unref( _udevDev );
	}

	udev_enumerate_unref( _enum );

	return TRUE;
}		/* -----  end of static function _scan_mtp  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _register_monitor
 *  Description:  
 * =====================================================================================
 */
static gboolean _register_monitor()
{
	GSource * _source	=	NULL;
	udevMonitor	=	udev_monitor_new_from_netlink( udevCtx, "udev" );

	if( udevMonitor == NULL )
	{
		g_warning( "udev_monitor_new_from_netlink failed" );

		goto NEED_FREE_CTX;
	}

	/* NOTE: we treat the mtp devices as a usb device now */
	if( udev_monitor_filter_add_match_subsystem_devtype( udevMonitor, "usb", 0 ) < 0 )
	{
		g_warning( "udev_monitor_filter_add_match_subsystem_devtype failed" );

		goto NEED_FREE_MONITOR;
	}

	if ( udev_monitor_enable_receiving( udevMonitor ) < 0 )
	{
		g_warning( "udev_monitor_enable_receiving failed" );

		goto NEED_FREE_MONITOR;
	}

	udevFd.fd	=	udev_monitor_get_fd( udevMonitor );

	if( udevFd.fd > 0 )
	{
		udevFd.events	=	POLLIN;

		_source	=	g_source_new( &_funcs, sizeof( GSource ));

		g_source_add_poll( _source, &udevFd );

		g_source_set_callback( _source, _parse_events, mh_core_instance(), NULL );

		mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

		g_source_unref( _source );
	}
	else
	{
		g_warning( "udev_monitor_get_fd faild" );

		goto NEED_FREE_MONITOR;
	}

	return TRUE;

NEED_FREE_MONITOR:
	udev_monitor_unref( udevMonitor );
NEED_FREE_CTX:
	udev_unref( udevCtx );

	return FALSE;
}		/* -----  end of static function _register_monitor  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _init
 *  Description:  
 * =====================================================================================
 */
static gboolean _init( gpointer user_data )
{
	libusb_init( &usbCtx );

	udevCtx	=	udev_new();

	if( udevCtx == NULL)
	{
		g_warning( "udev_new failed" );

		goto RETURN; 
	}
	/* Scanning the connected mtp devics */
	if( !_scan_mtp())
	{
		g_warning( "_scan_mtp failed" );

		goto RETURN; 
	}

	/* Registering udev event monitor */
	if( !_register_monitor())
	{
		g_warning( "_register_monitor failed" );

		goto RETURN; 
	}

RETURN:
	return G_SOURCE_REMOVE;
}		/* -----  end of static function _init  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_plugin_instance
 *  Description:  
 * =====================================================================================
 */
gboolean mh_plugin_instance()
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, _init, NULL, NULL );

	mh_io_dispatch( MH_IO( mh_core_instance() ), _source );

	g_source_unref( _source );

	return TRUE;
}		/* -----  end of function mh_plugin_instance  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_plugin_find_dev
 *  Description:  
 * =====================================================================================
 */
gboolean mh_plugin_find_dev()
{	
	return TRUE;
}		/* -----  end of function mh_plugin_find_dev  ----- */
