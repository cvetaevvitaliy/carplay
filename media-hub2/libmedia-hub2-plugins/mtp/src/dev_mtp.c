/*
 * Generated by object-codegen.
 */
#include <glib.h>
#include "dev_mtp.h"
#include <stdlib.h>
#include <string.h>
#include <mh_music.h>
#include <mh_movie.h>
#include <mh_contents.h>
#include <mh_pb.h>
#include <mh_playlist.h>
#include <gst/gst.h>
#include <gst/app/gstappsrc.h>
#include <mh_core.h>
#include <mh_misc.h>
#include <mh_folder.h>
#include <mh_item.h>
#define MTP_TIME_BEGIN() \
{ \
	struct timeval _start = {0, 0}, _current = {0, 0}, _result = {0, 0}; \
	float _max = 0, _min = 10000, _avg = 0; \
	int count = 0; \
	float _tmp; \
	printf("**********TIME MEASURING BEGIN**********\n");

#define MTP_TIME_DUR_BEGIN() \
	gettimeofday(&_start, NULL);

#define MTP_TIME_DUR_END() \
	gettimeofday(&_current, NULL); \
	timersub(&_current, &_start, &_result); \
	{ \
		_tmp    =   _result.tv_sec + (float)_result.tv_usec / 1000000; \
		if(_tmp > _max) _max =   _tmp; \
		if(_tmp < _min) _min =   _tmp; \
		_avg    +=  (_tmp - _avg) / ( ++ count); \
		fprintf(stdout, "***CNT:%d MAX:%03fs MIN:%03fs AVG:%03fs CUR:%03f\n", count, _max, _min, _avg, _tmp); \
	}

#define MTP_TIME_END() \
	printf("***********TIME MEASURING END (%d)***********\n", count); \
}

typedef struct _MHDevMtpPrivate MHDevMtpPrivate;

struct _MHDevMtpPrivate
{
	GRecMutex * mutex;
};

typedef struct _MTPObject 
{
	guint32 handle;
	guint32 offset;
} MTPObject;				/* ----------  end of struct MTPObject  ---------- */


G_DEFINE_TYPE_WITH_PRIVATE( MHDevMtp, mh_dev_mtp, MH_TYPE_DEV )

#define MTP_DEFAULT_SESSION_ID	2
#define CACHE_BLOCK_SIZE	0x10000
#define CACHE_NEED_EXTEND	5
#define CACHE_MAX_BLOCK		20
enum
{
	PROP_0,

	PROP_DEV_MTP_ROOT,
	
	MTP_N_PROPERTIES
};

static GParamSpec * devMtpProperties[ MTP_N_PROPERTIES ] = { NULL,};
libusb_context * usbCtx;
static unsigned int transactionId;
MHDevMtp * mtpObj;

static gsize objectOffset;
static guint8 intBuff[1024];

extern const gchar * vendorId, * productId;

GHashTable * cacheHt;
GQueue * dirtyQ;

static void getObjectPropDesc( MHMTPPropInfos * infos, uint32_t format_code);
/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _stop
 *  Description:
 * =====================================================================================
 */
static void _stop( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _stop  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play
 *  Description:
 * =====================================================================================
 */
static void _play( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _play  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _pause
 *  Description:
 * =====================================================================================
 */
static void _pause( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_pause
 *  Description:
 * =====================================================================================
 */
static void _play_pause( MHDev * self )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _play_pause  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _resume
 *  Description:
 * =====================================================================================
 */
static void _resume( MHDev * self )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _resume  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward
 *  Description:
 * =====================================================================================
 */
static void _forward( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _forward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _forward_done
 *  Description:
 * =====================================================================================
 */
static void _forward_done( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _forward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward
 *  Description:
 * =====================================================================================
 */
static void _backward( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _backward  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _backward_done
 *  Description:
 * =====================================================================================
 */
static void _backward_done( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _backward_done  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_index
 *  Description:
 * =====================================================================================
 */
static void _set_index( MHDev * self, MHPb * pb, uint32_t index ) 
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_index  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_speed
 *  Description:
 * =====================================================================================
 */
static void _set_speed( MHDev * self, guint speed )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_speed  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_repeat
 *  Description:
 * =====================================================================================
 */
static void _set_repeat( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_repeat  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_shuffle
 *  Description:
 * =====================================================================================
 */
static void _set_shuffle( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_shuffle  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _set_buffer_time
 *  Description:
 * =====================================================================================
 */
static void _set_buffer_time( MHDev * self )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _set_buffer_time  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  sendData
 *  Description:  
 * =====================================================================================
 */
static gboolean sendData( mtpContainer * container, void * params )
{
	MHDevMtpPrivate * _priv	=	mh_dev_mtp_get_instance_private( MH_DEV_MTP( mtpObj ));
	g_rec_mutex_lock( _priv->mutex );
//	g_message("sendData: code:%X,transactionId:%d", container->code, container->transactionId);
	guint8 _buf[ container->length ];
	int _offset	=	0, _len;
	int _ret;

	if( mtpObj == NULL )
		return FALSE;

	memcpy( _buf, ( void * )container, sizeof( mtpContainer ));

	if( params != NULL )
	{
		_offset	+=	sizeof( mtpContainer );
		guint32	* _a	=	(guint32 *)params;
		memcpy( _buf + _offset, params, container->length - sizeof( mtpContainer ) );
	}

	_ret	=	libusb_bulk_transfer( mtpObj->handle, mtpObj->bulkOutEp, _buf, container->length, &_len, 0 );

	if( _ret != 0 )
		g_warning( "%s %d: %s", __func__, __LINE__, libusb_strerror( _ret ));

	return _ret == 0;
}		/* -----  end of static function sendData  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getData
 *  Description:  
 * =====================================================================================
 */
static guint8 * getData( guint16 oc, guint32 ti )
{

	MHDevMtpPrivate * _priv	=	mh_dev_mtp_get_instance_private( MH_DEV_MTP( mtpObj ));
//	g_message("getData:code:%X,transactionId:%d",oc, ti);
	mtpContainer * _container;
	guint8 * _header	=	g_malloc0( mtpObj->maxPacketSize );
	int _len;
	int _ret;

	if( mtpObj == NULL )
		return NULL;

	_ret	=	libusb_bulk_transfer( mtpObj->handle, mtpObj->bulkInEp, _header, mtpObj->maxPacketSize, &_len, 0 );

	if( _ret == 0 )
	{
		_container	=	( mtpContainer *)_header;

		if( _container->code == oc && _container->transactionId == ti )
		{
			if( _container->length > mtpObj->maxPacketSize )
			{
				_header	=	g_realloc( _header, _container->length );

				_container	=	( mtpContainer *)_header;

				_ret	=	libusb_bulk_transfer( mtpObj->handle, mtpObj->bulkInEp, _header + mtpObj->maxPacketSize, 
						_container->length - mtpObj->maxPacketSize, &_len, 0 );

				if( _ret != 0 )
				{
					g_warning( "%s %d: %s", __func__, __LINE__, libusb_strerror( _ret ));

					g_free( _header );

					_header	=	NULL;
				}
			}
		}
		else
		{
			g_warning( "Operation Code or Transaction Id mismatch, expect( %04X/%08X ) got ( %04X/%08X ))", 
					oc, ti, _container->code, _container->transactionId );

			g_free( _header );

			_header	=	NULL;
		}
	}
	else
	{
		g_warning( "%s %d: %s", __func__, __LINE__, libusb_strerror( _ret ));

		g_free( _header );

		_header	=	NULL;
	}
	if( oc == RC_OK )
		g_rec_mutex_unlock( _priv->mutex );
	return _header;
}		/* -----  end of static function getData  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  openSession
 *  Description:  
 * =====================================================================================
 */
gboolean openSession( guint32 sessionId )
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response;

	_container->length	=	sizeof( mtpContainer ) + sizeof( guint32 );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_OPENSESSION;
	_container->transactionId	=	transactionId ++;

	sendData( _container, &sessionId );

	_response	=	getData( RC_OK, _container->transactionId );

	_container	=	( mtpContainer * )_response;

	if( _container != NULL )
	{
		g_free( _container );
	}

	return _container != NULL;
}		/* -----  end of static function openSession  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  decodeDeviceInfo
 *  Description:  
 * =====================================================================================
 */
static MHMTPDevInfo * decodeDeviceInfo( guint8 * buf )
{
	MHMTPDevInfo * _info	=	g_new0( MHMTPDevInfo, 1 );
	int _offset	=	0;
	gsize _read, _write;

	_info->standardVersion	=	*( guint16 * )buf;
	_offset	+=	2;

	_info->mtpVendorExtId	=	*( guint32 * )( buf + _offset );
	_offset	+=	4;

	_info->mtpVersion		=	*( guint16 * )( buf + _offset );
	_offset	+=	2;

	_info->mtpExtensions	=	g_convert( buf + _offset + 1, buf[ _offset ] * 2, "utf-8",
			"utf-16le", &_read, &_write, NULL );
	_offset	+=	buf[ _offset ] * 2 + 1;

	_info->functionalMode	=	*( guint16 * )( buf + _offset );
	_offset	+=	2;

	/* Zero terminated array */
	//DEBUG_HEX_DISPLAY( buf + _offset + 4, *( guint32 *)( buf + _offset ) * 2);
	_info->operationSupported	=	g_malloc0( (*( guint32 *)( buf + _offset ) + 1 ) * 2 );
	memcpy( _info->operationSupported, buf + _offset + 4, *( guint32 *)( buf + _offset ) * 2 );
	_offset	+=	*( guint32 *)( buf + _offset ) * 2 + 4;

	/* Zero terminated array */
	_info->eventsSupported	=	g_malloc0( (*( guint32 *)( buf + _offset ) + 1 ) * 2 );
	memcpy( _info->eventsSupported, buf + _offset + 4, *( guint32 *)( buf + _offset ) * 2 );
	_offset	+=	*( guint32 *)( buf + _offset ) * 2 + 4;

	/* Zero terminated array */
	_info->devicePropertiesSupported	=	g_malloc0( (*( guint32 *)( buf + _offset ) + 1 ) * 2 );
	memcpy( _info->devicePropertiesSupported, buf + _offset + 4, *( guint32 *)( buf + _offset ) * 2 );
	_offset	+=	*( guint32 *)( buf + _offset ) * 2 + 4;

	/* Zero terminated array */
	_info->captureFormats	=	g_malloc0( (*( guint32 *)( buf + _offset ) + 1 ) * 2 );
	memcpy( _info->captureFormats, buf + _offset + 4, *( guint32 *)( buf + _offset ) * 2 );
	_offset	+=	*( guint32 *)( buf + _offset ) * 2 + 4;

	//DEBUG_HEX_DISPLAY( buf + _offset, *( guint32 *)( buf + _offset ) * 2 );
	/* Zero terminated array */
	_info->playbackFormats	=	g_malloc0( (*( guint32 *)( buf + _offset ) + 1 ) * 2 );
	memcpy( _info->playbackFormats, buf + _offset + 4, *( guint32 *)( buf + _offset ) * 2 );
	_offset	+=	*( guint32 *)( buf + _offset ) * 2 + 4;

	_info->manufacturer	=	g_convert( buf + _offset + 1, buf[ _offset ] * 2, "utf-8",
			"utf-16le", &_read, &_write, NULL );
	_offset	+=	buf[ _offset ] * 2 + 1;

	_info->model	=	g_convert( buf + _offset + 1, buf[ _offset ] * 2, "utf-8",
			"utf-16le", &_read, &_write, NULL );
	_offset	+=	buf[ _offset ] * 2 + 1;

	_info->deviceVersion	=	g_convert( buf + _offset + 1, buf[ _offset ] * 2, "utf-8",
			"utf-16le", &_read, &_write, NULL );
	_offset	+=	buf[ _offset ] * 2 + 1;

	_info->serialNumber	=	g_convert( buf + _offset + 1, buf[ _offset ] * 2, "utf-8",
			"utf-16le", &_read, &_write, NULL );
	_offset	+=	buf[ _offset ] * 2 + 1;

	return _info;
}		/* -----  end of static function decodeDeviceInfo  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  decodeMediaInfo
 *  Description:  
 * =====================================================================================
 */
static void decodeMediaInfo( MHItem * item, MHMTPPropInfo * info, guint8 * buf) 
{
	gsize _read, _write;
	switch( item->type )
	{
		case MH_ITEM_MUSIC:
		{
			MHMusic * _music	=	MH_MUSIC( item );
			switch( info->prop_code)
			{
			

				case OPC_Artist:
					if( info->datatype == DTC_STR)
					{
						_music->artist	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );

					}
					break;

				case OPC_Duration:
					if( info->datatype == DTC_UINT32)
					{
						_music->duration = *( guint32 *)buf;
					}
					break;
				case OPC_Rating:
					if( info->datatype == DTC_UINT16)
					{
						_music->rating	=	*(guint16 *)buf;
					}
					break;
				case OPC_Track:
					if( info->datatype == DTC_UINT16)
					{
						_music->track	=	*(guint16 *)buf;
					}
					break;
				case OPC_Genre:
					if( info->datatype == DTC_STR)
					{
						_music->genre	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );

					}
					break;
				case OPC_Composer:
					if( info->datatype == DTC_STR)
					{
						_music->composer	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );

					}
					break;

				case OPC_Subtitle:
					if( info->datatype == DTC_STR)
					{
						_music->title	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
					}
					break;
 		
				case OPC_AlbumName:
					if( info->datatype == DTC_STR)
					{
						
						_music->album_title	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
					}
					break;
				case OPC_AlbumArtist:
					if( info->datatype	==	DTC_STR)
					{
						_music->album_artist =	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );

					}
					break;
				default:
					break;
			}

		}
			break;
		case MH_ITEM_MOVIE:
		{
			MHMovie * _movie	=	MH_MOVIE( item );
			switch( info->prop_code)
			{
			

				case OPC_Genre:
					if( info->datatype == DTC_STR)
					{
						_movie->genre	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );

					}
					break;
				case OPC_Width:
					if( info->datatype == DTC_UINT32)
					{
						_movie->xres	=	*(guint32 *)buf;

					}
					break;

				case OPC_Height:
					if( info->datatype == DTC_UINT32)
					{
						_movie->yres	=	*(guint32 *)buf;

					}
					break;
 				case OPC_Duration:
					if( info->datatype == DTC_UINT32)
					{
						_movie->duration	=	*(guint32 *)buf;

					}

					break;
				default:
					break;
				}
		}
			break;
		case MH_ITEM_PICTURE:
		{	
			MHPicture * _picture	=	MH_PICTURE( item);
			switch( info->prop_code)
			{
				case OPC_Width:
					if( info->datatype == DTC_UINT32)
					{
						_picture->width	=	*(guint32 *)buf;

					}
					break;

				case OPC_Height:
					if( info->datatype == DTC_UINT32)
					{
						_picture->height	=	*(guint32 *)buf;

					}
					break;
			}
		}
			break;

	}
}		/* -----  end of static function decodeMediaInfo  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  decodeMusicInfo
 *  Description:  
 * =====================================================================================
 */
static void decodeMusicInfo( MHMusic * music, guint8 * buf, MHMTPPropInfo * info)
{
}		/* -----  end of static function decodeMusicInfo  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  decodeMovieInfo
 *  Description:  
 * =====================================================================================
 */
static void decodeMovieInfo( MHMovie * movie, guint8 * buf, MHMTPPropInfo * info)
{
}		/* -----  end of static function decodeMovieInfo  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  decodePictureInfo
 *  Description:  
 * =====================================================================================
 */
static void decodePictureInfo( MHPicture * picture, guint8 * buf, MHMTPPropInfo * info)
{
}		/* -----  end of function decodePictureInfo  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getDeviceInfo
 *  Description:  
 * =====================================================================================
 */
MHMTPDevInfo * getDeviceInfo()
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response;
	MHMTPDevInfo * _devInfo	=	NULL;

	_container->length	=	sizeof( mtpContainer );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_GETDEVICEINFO;
	_container->transactionId	=	transactionId ++;

	sendData( _container, NULL );

	_response	=	getData( OC_GETDEVICEINFO, _container->transactionId );

	if( _response != NULL )
	{
		_devInfo	=	decodeDeviceInfo( _response + sizeof( mtpContainer ));

		g_message( "Find a MTP device: %s %s, %s, %s", _devInfo->manufacturer, _devInfo->model,
				_devInfo->deviceVersion, _devInfo->serialNumber );

		_container	=	( mtpContainer * )_response;

		_response	=	getData( RC_OK, _container->transactionId );

		g_free( _container );

		_container	=	( mtpContainer * )_response;

		if( _container != NULL )
		{
			g_free( _container );
		}
	}

	return _devInfo;
}		/* -----  end of static function getDeviceInfo  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  checkCompatibility
 *  Description:  
 * =====================================================================================
 */
static gboolean checkCompatibility( MHMTPDevInfo * devInfo )
{
	gboolean _ret	=	FALSE;
	guint16 * _oc;

	if( devInfo == NULL )
		return _ret;

	for( _oc = ( guint16 * )devInfo->operationSupported; *_oc != 0; _oc ++ )
	{
		if( *_oc == 0x101B )
			_ret	=	TRUE;
	}

	return _ret;
}		/* -----  end of static function checkCompatibility  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  closeSession
 *  Description:  
 * =====================================================================================
 */
static void closeSession()
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response;

	_container->length	=	sizeof( mtpContainer );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_CLOSESESSION;
	_container->transactionId	=	transactionId ++;

	sendData( _container, NULL );

	_response	=	getData( RC_OK, _container->transactionId );

	_container	=	( mtpContainer * )_response;

	if( _container != NULL )
	{
		g_free( _container );
	}

	g_free( _response );
}		/* -----  end of static function closeSession  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getStorageIDs
 *  Description:  
 * =====================================================================================
 */
MHMTPStorageIDs * getStorageIDs()
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response;
	guint32 _count;
	int i;
	MHMTPStorageIDs * _ids	=	NULL;

	_container->length	=	sizeof( mtpContainer );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_GETSTORAGEIDS;
	_container->transactionId	=	transactionId ++;

	sendData( _container, NULL );

	_response	=	getData( OC_GETSTORAGEIDS, _container->transactionId );

	if( _response != NULL )
	{
		_container	=	( mtpContainer * )_response;

		_count	=	*( guint32 * )( _response + sizeof( mtpContainer ));

		g_message( "MTP device contains %d storage ids", _count );

		for( i = 0; i < _count; i ++ )
		{
			g_message( "StorageID: 0x%08X", *( guint32 *)(_response + sizeof( mtpContainer ) + 4 + i * sizeof( guint32 )));
		}

		_ids	=	g_new0( MHMTPStorageIDs, 1 );

		_ids->count	=	_count;
		_ids->ids	=	g_new0( guint32, _count );

		g_message( "--->%d %p", _ids->count, _ids->ids );

		memcpy( _ids->ids, _response + sizeof( mtpContainer ) + 4, _count * sizeof( guint32 ));

		_response	=	getData( RC_OK, _container->transactionId );

		g_free( _container );

		_container	=	( mtpContainer * )_response;

		if( _container != NULL )
		{
			g_free( _container );
		}
	}

	return _ids;
}		/* -----  end of static function getStorageIDs  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  decodeStorageInfo
 *  Description:  
 * =====================================================================================
 */
static MHMTPStorageInfo * decodeStorageInfo( guint8 * buf )
{
	MHMTPStorageInfo * _info	=	g_new0( MHMTPStorageInfo, 1 );
	int _offset	=	0;
	gsize _read, _write;

	_info->storageType	=	*( guint16 * )buf;
	_offset	+=	2;

	_info->fsType	=	*( guint16 *)( buf + _offset );
	_offset	+=	2;

	_info->accessCapability	=	*( guint16 *)( buf + _offset );
	_offset	+=	2;

	_info->maxCapability	=	*( guint16 *)( buf + _offset );
	_offset	+=	8;

	_info->freeSpaceInBytes	=	*( guint16 *)( buf + _offset );
	_offset	+=	8;
	_offset +=	4;
//	DEBUG_HEX_DISPLAY( buf + _offset + 1, buf[ _offset ] * 2 );
	_info->storageDescription	=	g_convert( buf + _offset + 1, buf[ _offset ] * 2, "utf-8",
			"utf-16le", &_read, &_write, NULL );
	_offset	+=	buf[ _offset ] * 2 + 1;

	g_message( "storageDescription %s", _info->storageDescription );

	_info->volumeLable	=	g_convert( buf + _offset + 1, buf[ _offset ] * 2, "utf-8",
			"utf-16le", &_read, &_write, NULL );
	_offset	+=	buf[ _offset ] * 2 + 1;
	g_message( "volumeLable %s", _info->volumeLable );

	return _info;
}		/* -----  end of static function decodeStorageInfo  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getStorageInfo
 *  Description:  
 * =====================================================================================
 */
static MHMTPStorageInfo * getStorageInfo( guint32 storageId )
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response;
	guint32 _idLen;
	MHMTPStorageInfo * _info;
	int i;

	g_message( "Get storage id info %08X", storageId );

	_container->length	=	sizeof( mtpContainer ) + sizeof( guint32 );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_GETSTORAGEINFO;
	_container->transactionId	=	transactionId ++;

	sendData( _container, &storageId );

	_response	=	getData( OC_GETSTORAGEINFO, _container->transactionId );

	if( _response != NULL )
	{

		//DEBUG_HEX_DISPLAY( _response, *(guint32 *)_response);
		_info	=	decodeStorageInfo( _response + sizeof( mtpContainer ));

		_container	=	( mtpContainer * )_response;

		_response	=	getData( RC_OK, _container->transactionId );

		g_free( _container );

		_container	=	( mtpContainer * )_response;

		if( _container != NULL )
		{
			g_free( _container );
		}
	}

	return _info;
}		/* -----  end of static function getStorageInfo  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getNumObjects
 *  Description:  
 * =====================================================================================
 */
static guint32 getNumObjects( guint32 objectType )
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response;
	guint32 _idLen;
	MHMTPStorageInfo * _info;
	guint32 _params[3]	=	{ 0 };
	guint32 _num;
	int i;

	_params[0]	=	0xFFFFFFFF;
	_params[1]	=	objectType;

	_container->length	=	sizeof( mtpContainer ) + sizeof( _params );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_GETNUMOBJECTS;
	_container->transactionId	=	transactionId ++;

	sendData( _container, _params );

	_response	=	getData( RC_OK, _container->transactionId );

	if( _response != NULL )
	{
		_num	=	*( guint32 * )( _response + sizeof( mtpContainer ));


		_container	=	( mtpContainer * )_response;

		g_free( _container );
	}

	return _num;
}		/* -----  end of static function getNumObjects  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getPartialObject
 *  Description:  
 * =====================================================================================
 */
static guint8 * getPartialObject( guint32 objectHandle, guint32 offset, guint32 size )
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response, * _data;
	guint32 _idLen;
	MHMTPStorageInfo * _info;
	gsize _read, _write;
	int i;
	guint32 _params[3];

	_params[0]	=	objectHandle;
	_params[1]	=	offset;
	_params[2]	=	size;

	_container->length	=	sizeof( mtpContainer ) + sizeof( guint32 ) * 3;
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_GETPARTIALOBJECT;
	_container->transactionId	=	transactionId ++;

	sendData( _container, _params );

	_data	=	getData( OC_GETPARTIALOBJECT, _container->transactionId );

	if( _data != NULL )
	{
		_response	=	getData( RC_OK, _container->transactionId );

		_container	=	( mtpContainer * )_response;

		if( _container != NULL )
		{
			g_free( _container );
		}
	}

	return _data;
}		/* -----  end of static function getPartialObject  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getObjectInfo
 *  Description:  
 * =====================================================================================
 */
static MHItem * getObjectInfo( guint32 objectHandle, MHFolder * root, MHItemType type )
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response;
	guint32 _idLen;
	MHMTPStorageInfo * _info;
	gsize _read, _write;
	guint32 _parent_handle;
	guint16 _association;
	int i;
	guint32 _size;
	MHItem * _item	=	NULL;
	char * _name;
	MHItemType _type;
	guint32 _storage_id;
	MHFolder * _parent_folder;
	_container->length	=	sizeof( mtpContainer ) + sizeof( guint32 );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_GETOBJECTINFO;
	_container->transactionId	=	transactionId ++;

	sendData( _container, &objectHandle );

	_response	=	getData( OC_GETOBJECTINFO, _container->transactionId );
//	_response	=	getData( RC_OK, _container->transactionId);
	if( _response != NULL )
	{
	//	DEBUG_HEX_DISPLAY( _response, *(guint32 *)_response);
		_storage_id	=	*(guint32 *)( _response + sizeof( mtpContainer ));
		_parent_handle	=	*(guint32 *)( _response + sizeof( mtpContainer ) + 38);
		_association	=	*(guint16 *)( _response + sizeof( mtpContainer ) + 42);
		_size	=	*( guint32 * )( _response + sizeof( mtpContainer ) + 8 );
		_name	=	g_convert( _response + sizeof( mtpContainer ) + 52 + 1, 
				_response[ sizeof( mtpContainer ) + 52 ] * 2, "utf-8",
				"utf-16le", &_read, &_write, NULL );
		_response	=	getData( RC_OK, _container->transactionId );

		_container	=	( mtpContainer * )_response;

		if( _container != NULL )
		{
			g_free( _container );
		}



		if( type == MH_ITEM_FOLDER)
		{
			MHFolder * _folder;
			_folder	=	g_object_new( MH_TYPE_FOLDER, NULL);
			_item	=	MH_ITEM( _folder );
			_item->type	=	type;
			_item->tagId	=	objectHandle;
			_item->dev	=	MH_DEV( mtpObj);
			_folder->scanned = TRUE;

		}
		else 
		{
			_type	=	mh_misc_get_file_type( _name );
			switch( _type )
			{
				case MH_ITEM_MUSIC:
				{
					MHMusic * _music;
					_music	=	g_object_new( MH_TYPE_MUSIC, NULL);
					_item	=	MH_ITEM( _music );
					_item->dev	=	MH_DEV( mtpObj);
					_item->type	=	_type;
				}
				break;
							
				case MH_ITEM_MOVIE:
				{
					MHMovie * _movie;	
					_movie	=	g_object_new( MH_TYPE_MOVIE, NULL);
					_item	=	MH_ITEM( _movie );
					_item->dev	=	MH_DEV( mtpObj );
					_item->type	=	_type;
				}
				break;

				case MH_ITEM_PICTURE:
				{
					MHPicture * _picture;
					_picture	=	g_object_new( MH_TYPE_PICTURE, NULL);
					_item	=	MH_ITEM( _picture );
					_item->dev	=	MH_DEV( mtpObj );
					_item->type	=	_type;
			    }
			    break;

				case MH_ITEM_PLAYLIST:

					_item	=	g_object_new( MH_TYPE_ITEM, NULL);
					_item->dev	=	MH_DEV( mtpObj);
					_item->type	=	_type;
				break;
				

				default:
					_item	=	NULL;	
					g_message("%s:error,name:%s",__func__,_name );	
				break;
			}
		
		}
		if( _item != 	NULL)
		{
			_item->node	 =	g_node_new(_item);
			_item->dev	=	MH_DEV(mtpObj);
			_item->tagId	=	objectHandle;

			_item->size		=	_size;
			_item->name		=	_name;
			//	_container	=	( mtpContainer * )_response;

			if( _parent_handle != 0)
			{
				gpointer _value	=	g_hash_table_lookup( mtpObj->MtpHash, &_parent_handle);
				if( _value !=	NULL)
				{
					_parent_folder	=	MH_FOLDER( _value );
				}
				else
				{
					_parent_folder 	=	MH_FOLDER(getObjectInfo( _parent_handle,root, MH_ITEM_FOLDER)); 
				}
				g_node_append( MH_ITEM( _parent_folder )->node, _item->node);
				
			}
			else
			{
				g_node_append( MH_ITEM( root )->node, _item->node);
				_parent_folder	=	root;
			}
			mh_folder_add_type_count( MH_FOLDER( _parent_folder), _type);
			if( (_type == MH_ITEM_MUSIC) && (mtpObj->first_music_flag == false ))
			{
				mtpObj->first_music_flag	=	true;
				g_signal_emit_by_name( MH_DEV(mtpObj) , "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_MUSIC,  _parent_folder, 0);

			}
			if( (_type == MH_ITEM_MOVIE) && (mtpObj->first_movie_flag == false ))
			{
				mtpObj->first_movie_flag	=	true;
				g_signal_emit_by_name( MH_DEV(mtpObj) , "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_MOVIE,  _parent_folder, 0);

			}
			if( (_type == MH_ITEM_PICTURE) && (mtpObj->first_picture_flag == false ))
			{
				mtpObj->first_picture_flag	=	true;
				g_signal_emit_by_name( MH_DEV(mtpObj) , "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_PICTURE,  _parent_folder, 0);

			}


			g_hash_table_insert(mtpObj->MtpHash, &( _item->tagId), _item );	
		}

	
	}
	return _item;
}		/* -----  end of static function getObjectInfo  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getObjectHandles
 *  Description:  
 * =====================================================================================
 */
static MHMTPObjHandles * getObjectHandles( guint32 storageId, guint32 objectType )
{
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response, * _data;
	guint32 _idLen;
	MHMTPStorageInfo * _info;
	guint32 _params[3]	=	{ 0 };
	int i;
	MHMTPObjHandles * _res	=	(MHMTPObjHandles *)g_malloc0(sizeof( MHMTPObjHandles));
	_params[0]	=	storageId;
	_params[1]	=	objectType;

	_container->length	=	sizeof( mtpContainer ) + sizeof( _params );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_GETOBJECTHANDLES;
	_container->transactionId	=	transactionId ++;

	sendData( _container, _params );

	_data	=	getData( OC_GETOBJECTHANDLES, _container->transactionId );

	if( _data != NULL )
	{
		_res->size  = *(guint32 *)( _data + sizeof(mtpContainer));
		_res->handles	=	(guint32 *)g_malloc0( sizeof( guint32 ) * _res->size);
		for( i=0; i < _res->size; i++)
		{
			_res->handles[ i ] = *(guint32 *)(_data + sizeof( mtpContainer) + 4 + i*4);
		}
//		g_message("-------------------------------------------------------------------------------");
//		DEBUG_HEX_DISPLAY( _data, *(guint32 *)_data);
//		g_message("--------------------------------------------------------------------------------");
		_response	=	getData( RC_OK, _container->transactionId );

		_container	=	( mtpContainer * )_response;

		if( _container != NULL )
		{
			g_free( _container );
		}
	}

	return _res;
}		/* -----  end of static function getObjectHandles  ----- */

static guint32 _prop_size;
static guint16 _prop_data[20];

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getObjectPropsSupported
 *  Description:  
 * =====================================================================================
 */
static MHMTPPropInfos *  getObjectPropsSupported( uint32_t objectType,MHItemType type )
{
	MHMTPPropInfos *_infos;
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	guint8 * _response, * _data;
	guint32 _idLen;
	MHMTPStorageInfo * _info;
	guint32 _params[3]	=	{ 0 };
	int i;
	MHItem * _item;
	guint16  _store;
	guint16 _tmp[15];
	guint32 _size	=	0;
	_params[0]	=	objectType;

	_container->length	=	sizeof( mtpContainer ) + sizeof( _params );
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	OC_GETOBJECTPROPSSUPPORTED;
	_container->transactionId	=	transactionId ++;

	sendData( _container, _params );

	_data	=	getData( OC_GETOBJECTPROPSSUPPORTED, _container->transactionId );
	_infos	=	(MHMTPPropInfos*)g_malloc0( sizeof( MHMTPPropInfos));
	_infos->size = 0;
	if( _data != NULL )
	{
		//DEBUG_HEX_DISPLAY( _data, *(guint32*)_data);
		guint32 _count	=	*(guint32 *)(_data + sizeof(mtpContainer));
		for(i = 0; i < _count; i++)
		{
			_store = *(guint16 *)(_data + sizeof( mtpContainer ) + 4 + i*2);
			if( type ==	MH_ITEM_MUSIC)
			{
				switch( _store )
				{
					case OPC_Artist:
					case OPC_Duration:
					case OPC_Rating:
					case OPC_Track:
					case OPC_Genre:
					case OPC_Composer:
					case OPC_Subtitle:
 					case OPC_AlbumName:
					case OPC_AlbumArtist:
					_tmp[_size]	=	_store;
					_size++;
					break;
				default:
					break;
				}
			}
			else if( type == MH_ITEM_MOVIE)
			{
				switch( _store)
				{
					case OPC_Subtitle:
					case OPC_Genre:
					case OPC_Width:
					case OPC_Height:
					case OPC_Duration:
						_tmp[_size]	=	_store;
						_size++;
						break;
					default:
						break;
				}
			}
			else if( type == MH_ITEM_PICTURE)
			{
				switch( _store)
				{
					case OPC_Width:
					case OPC_Height:
						_tmp[_size]	=	_store;
						_size++;
						break;
					default:
						break;
				}
			}
			else
			{
				g_message("not music, movie, picture");
			}
		}
		_infos->info	=	(MHMTPPropInfo *)g_malloc0( sizeof(MHMTPPropInfo) * _size);
		_infos->size	=	_size;
		for(i = 0;i < _size; i++)
		{
			_infos->info[i].prop_code	=	_tmp[i];
		}
		_container	=	( mtpContainer * )_data;

		_response	=	getData( RC_OK, _container->transactionId );


		_container	=	( mtpContainer * )_response;

		if( _container != NULL )
		{
			g_free( _container );
		}

	}
	return _infos;
}		/* -----  end of static function getObjectPropsSupported  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getObjectPropDesc
 *  Description:  
 * =====================================================================================
 */
 static void getObjectPropDesc( MHMTPPropInfos * infos, uint32_t format_code)
{
	guint8 * _response, * _data;
	guint32 _idLen;
	MHMTPStorageInfo * _info;
	guint32 _params[3]	=	{ 0 };
	int i;
	_params[1]	=	format_code;

//	g_message("_info->size:%d",infos->size);
	for( i = 0; i < infos->size; i++)
	{
		mtpContainer * _container	=	alloca( sizeof( mtpContainer ));

		_params[0]	=	infos->info[i].prop_code;
		_params[1]	=	format_code;

		_container->type		=	USB_CONTAINER_COMMAND;
		_container->code		=	OC_GETOBJECTPROPDESC;
		_container->length	=	sizeof( mtpContainer ) + sizeof( _params );
		_container->transactionId	=	transactionId ++;
	
		sendData( _container, _params );
		_data	=	getData( OC_GETOBJECTPROPDESC, _container->transactionId );

		if( _data != NULL )
		{
	//		DEBUG_HEX_DISPLAY( _data ,  *(guint32*)(_data));
			infos->info[i].datatype	=	*( guint16 *)(_data + sizeof( mtpContainer) + 2);
			infos->info[i].get_set	=	*( guint8 *)( _data + sizeof( mtpContainer) + 4);
			g_free(_data);

			_response	=	getData( RC_OK, _container->transactionId );

			_container	=	( mtpContainer * )_response;

			if( _response != NULL )
			{
				g_free( _response );
			}
		}
	}

//	return _data;
}		/* -----  end of static function getObjectPropDesc  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getObjectPropValue
 *  Description:  
 * =====================================================================================
 */
static void getObjectPropValue(guint32 objectHandle, MHMTPPropInfos * infos, MHItem * item  )
{
	g_message("objectHandle:%X,type:%d",objectHandle, item->type);
	guint32 i;
	guint32 _params[2];
	guint8 * _response;
	guint8 * _data;
	gsize _read, _write;
	MHMusic * _music;
	MHMovie * _movie;
	MHMovie * _picture;
	for( i=0; i < infos->size; i++)
	{
		mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
		_params[0]  =   objectHandle;
		_params[1]	=	infos->info[i].prop_code;
					//infos->info[i].prop_code;
	//	g_message("infos->info[%d]:%X    infos->info[%d]:%X",i,infos->info[i].prop_code, i, infos->info[i].datatype);
		_container->length	=	sizeof( mtpContainer ) + sizeof( _params ) ;
		_container->type		=	USB_CONTAINER_COMMAND;
		_container->code		=	OC_GETOBJECTPROPVALUE;	
		_container->transactionId	=	transactionId ++;

		sendData( _container, _params );
		_response	=	getData( OC_GETOBJECTPROPVALUE, _container->transactionId );
		if( _response != NULL )
		{
			_data	=	_response + sizeof( mtpContainer);
//			DEBUG_HEX_DISPLAY( _response, *(guint32 *)_response);
			decodeMediaInfo(item, &(infos->info[i]), _data);
			g_free( _response);
			_response	=	getData( RC_OK, _container->transactionId );
			_container	=	( mtpContainer * )_response;
	
			if( _container != NULL )
			{
				g_free( _container );
			}

		}
	}


}		/* -----  end of static function getObjectPropValue  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  decodeMediaInfos
 *  Description:  
 * =====================================================================================
 */
static void decodeMediaInfos( MHItem * item, guint8 * buf)
{
//	gsize _read, _write;
//	switch( item->type )
//	{
//		
//		case MH_ITEM_MUSIC:
//		{
//			MHMusic * _music	=	MH_MUSIC( item );
//			g_message("decodeMediaInfo--->music");
//			switch( info->prop_code)
//			{
//			
//
//				case OPC_Artist:
//					if( info->datatype == DTC_STR)
//					{
//						_music->artist	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
//
//					}
//					break;
//
//				case OPC_Duration:
//					if( info->datatype == DTC_UINT32)
//					{
//						_music->duration = *( guint32 *)buf;
//					}
//					break;
//				case OPC_Rating:
//					if( info->datatype == DTC_UINT16)
//					{
//						_music->rating	=	*(guint16 *)buf;
//					}
//					break;
//				case OPC_Track:
//					if( info->datatype == DTC_UINT16)
//					{
//						_music->track	=	*(guint16 *)buf;
//					}
//					break;
//				case OPC_Genre:
//					if( info->datatype == DTC_STR)
//					{
//						_music->genre	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
//
//					}
//					break;
//				case OPC_Composer:
//					if( info->datatype == DTC_STR)
//					{
//						_music->composer	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
//
//					}
//					break;
//
//				case OPC_Subtitle:
//					if( info->datatype == DTC_STR)
//					{
//						_music->title	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
//						g_message("_music->title:%s", _music->title);
//					}
//					break;
// 		
//				case OPC_AlbumName:
//					if( info->datatype == DTC_STR)
//					{
//						
//						_music->album_title	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
//					}
//					break;
//				case OPC_AlbumArtist:
//					if( info->datatype	==	DTC_STR)
//					{
//						_music->album_artist =	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
//
//					}
//					break;
//				default:
//					break;
//			}
//
//		}
//			break;
//		case MH_ITEM_MOVIE:
//		{
//			MHMovie * _movie	=	MH_MOVIE( item );
//			switch( info->prop_code)
//			{
//			
//
//				case OPC_Genre:
//					if( info->datatype == DTC_STR)
//					{
//						_movie->genre	=	g_convert( buf + 1, (*(guint8 *)buf)*2, "utf-8","utf-16le", &_read, &_write, NULL );
//
//					}
//					break;
//				case OPC_Width:
//					if( info->datatype == DTC_UINT32)
//					{
//						_movie->xres	=	*(guint32 *)buf;
//
//					}
//					break;
//
//				case OPC_Height:
//					if( info->datatype == DTC_UINT32)
//					{
//						_movie->yres	=	*(guint32 *)buf;
//
//					}
//					break;
// 				case OPC_Duration:
//					if( info->datatype == DTC_UINT32)
//					{
//						_movie->duration	=	*(guint32 *)buf;
//
//					}
//
//					break;
//				default:
//					break;
//				}
//		}
//			break;
//		case MH_ITEM_PICTURE:
//		{	
//			MHPicture * _picture	=	MH_PICTURE( item);
//			switch( info->prop_code)
//			{
//				case OPC_Width:
//					if( info->datatype == DTC_UINT32)
//					{
//						_picture->width	=	*(guint32 *)buf;
//
//					}
//					break;
//
//				case OPC_Height:
//					if( info->datatype == DTC_UINT32)
//					{
//						_picture->height	=	*(guint32 *)buf;
//
//					}
//					break;
//			}
//		}
//			break;
//
//	}
}		/* -----  end of static function decodeMediaInfos  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  mtp_unpack_value
 *  Description:  
 * =====================================================================================
 */
static guint8 * mtp_unpack_value( guint8 * data, guint16 propType )
{
	guint32 _arraySize;
	switch(	propType )
	{
		case DTC_INT8:
			data += 1;
			break;
		case DTC_UINT8:
			data += 1;
			break;
		case DTC_INT16:
			data += 2;
			break;
		case DTC_UINT16:
			data += 2;
			break;
		case DTC_INT32:
			data += 4;
			break;
		case DTC_UINT32:
			data += 4;
			break;
		case DTC_INT64:
			data += 8;
			break;
		case DTC_UINT64:
			data += 8;
			break;
		case DTC_INT128:
			data += 16;
			break;
		case DTC_UINT128:
			data += 16;
			break;
		case DTC_STR:
			data = data + 1 + ( * ( guint8 * ) data ) * 2;
			break;
		case DTC_AINT8:
		case DTC_AUINT8:
			_arraySize	=	*(guint32 *)data;
			data = data + 4 + _arraySize;
			break;
		case DTC_AINT16:
		case DTC_AUINT16:
			_arraySize 	=  *( guint32 *)data;
			data	=	data + 4 + _arraySize *2;
			break;
		case DTC_AINT32:
		case DTC_AUINT32:
			_arraySize = *( guint32 *)data;
			data =	data + 4 + _arraySize * 4;
			break;
		case DTC_AINT64:
		case DTC_AUINT64:
			_arraySize = *(guint32 *)data;
			data = data + 4 + _arraySize * 8;
			break;
		case DTC_AINT128:
		case DTC_AUINT128:
			_arraySize = *(guint32 *)data;
			data = data + 4 + _arraySize * 16;
			break;
	}
	return data;

}		/* -----  end of static function mtp_unpack_value  ----- */
static int count =0;
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  getObjectPropList
 *  Description:  
 * =====================================================================================
 */
static MHItem *  getObjectPropList(guint32 objectHandle, MHFolder * root, guint32 formatCode, MHItemType type )
{
//	if( type != MH_ITEM_FOLDER)
//	{
//		g_message("%d",count++);
//	}
	guint32 i;
	guint32 _params[5] = { 0 };
	guint8 * _response;
	guint8 * _data;
	gsize _read, _write;

	MHMusic * _music;
	MHMovie * _movie;
	MHPicture * _picture;
	MHFolder * _folder;
	MHItem * _item;

	guint16 _propCode;
	guint16 _propType;
	guint32 _arraySize;
	guint32 _count;
	guint32 _objHandle;
	guint32 _lastHandle;

	MHContents * _contents;
	
	_contents	=	mh_contents_instance();
	
	switch( type )
	{
		case MH_ITEM_MUSIC:
			_music	=	g_object_new( MH_TYPE_MUSIC, NULL);
			_item	=	MH_ITEM( _music );
			break;

		case MH_ITEM_MOVIE:
			_movie	=	g_object_new( MH_TYPE_MOVIE, NULL);
			_item	=	MH_ITEM( _movie );
			break;

		case MH_ITEM_PICTURE:
			_picture	=	g_object_new( MH_TYPE_PICTURE, NULL);
			_item	=	MH_ITEM( _picture );
			break;

		case MH_ITEM_FOLDER:
			_folder	=	g_object_new( MH_TYPE_FOLDER, NULL);
			_item	=	MH_ITEM( _folder);
			_folder->scanned	=	TRUE;
			break;

		default:
			g_warning("type error");
			return NULL;

	}
	_item->dev	=	MH_DEV( mtpObj );
	_item->type	=	type;
	_item->node	=	g_node_new( _item);
	*(guint32 *)&(_item->tagId)	=	objectHandle;
	mtpContainer * _container	=	alloca( sizeof( mtpContainer ));
	_params[0]  =   objectHandle;
	_params[2]	=	0xFFFFFFFF;
	//	g_message("infos->info[%d]:%X    infos->info[%d]:%X",i,infos->info[i].prop_code, i, infos->info[i].datatype);
	_container->length	=	sizeof( mtpContainer ) + sizeof( _params ) ;
	_container->type		=	USB_CONTAINER_COMMAND;
	_container->code		=	EOC_GETOBJECTPROPLIST;	
	_container->transactionId	=	transactionId ++;

	sendData( _container, _params );
	_response	=	getData( EOC_GETOBJECTPROPLIST, _container->transactionId );
	if( _response != NULL )
	{
	
//		DEBUG_HEX_DISPLAY( _response, *(guint32 *)_response);
		_data	=	_response + sizeof( mtpContainer);
		_count	=	*( guint32* )_data;
		_data += 4;

		for( i = 0; i < _count; i++)
		{
			_propCode	=	*(guint16 *)(_data + 4);
			_propType	=	*(guint16 *)(_data + 6);
			_data	+= 8;
			if( _item != NULL && _item->type ==	MH_ITEM_FOLDER)
			{
				_folder	=	MH_FOLDER( _item );
				switch( _propCode )
				{
					case OPC_ObjectFileName:
						if( _propType == DTC_STR)
						{
							_item->name	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data	=	_data + 1 + (*(guint8 *)_data)*2;
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_ParentObject:
						if( _propType ==	DTC_UINT32)
						{
							*((guint32 *)(&(_item->tagId))+ 1)=*(guint32 *)_data;
						
							_data += 4;
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_ObjectSize:
						if( _propType == DTC_UINT64)
						{
							_item->size	=	*(guint64 *)_data;
							_data += 8;
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType );
						}
						break;
					default:
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;

				}
			}
			else if( _item != 	NULL && _item->type == MH_ITEM_MUSIC )
			{
				_music	=	MH_MUSIC( _item );
				switch( _propCode )
				{
					case OPC_ObjectFileName:
						if( _propType == DTC_STR)
						{
							_item->name	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data	=	_data + 1 + (*(guint8 *)_data)*2;
	
							if( mh_misc_get_file_type( _item->name )!= _item->type )
							{
								g_object_unref( _music );
								_item =	NULL;
							}
						
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_ParentObject:
						if( _propType ==	DTC_UINT32)
						{
							*((guint32 *)(&(_item->tagId))+ 1)=*(guint32 *)_data;
							_data += 4;

						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_ObjectSize:
						if( _propType == DTC_UINT64)
						{
							_item->size	=	*(guint64 *)_data;
							_data += 8;
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType );
						}
						break;

					case OPC_Artist:
						if( _propType == DTC_STR)
						{
							_music->artist	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data = _data + 1 + (*(guint8 *)_data)*2;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_Duration:
						if( _propType == DTC_UINT32)
						{
							_music->duration = *( guint32 *)_data;
							_data += 4;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_Rating:
						if( _propType == DTC_UINT16)
						{
							_music->rating	=	*(guint16 *)_data;
							_data += 2;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_Track:
						if( _propType == DTC_UINT16)
						{
							_music->track	=	*(guint16 *)_data;
							_data += 2;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_Genre:
						if( _propType == DTC_STR)
						{
							_music->genre	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );

							_data = _data + 1 + (*(guint8 *)_data)*2;

						}
						break;
					case OPC_Composer:
						if( _propType == DTC_STR)
						{
							_music->composer	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data = _data + 1 + (*(guint8 *)_data)*2;

						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_Subtitle:
						if( _propType == DTC_STR)
						{
							_music->title	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data = _data + 1 + (*(guint8 *)_data)*2;
						}
						break;
					case OPC_AlbumName:
						if( _propType == DTC_STR)
						{
						
							_music->album_title	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data = _data + 1 + (*(guint8 *)_data)*2;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_AlbumArtist:
						if( _propType	==	DTC_STR)
						{
							_music->album_artist =	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data = _data + 1 + (*(guint8 *)_data)*2;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					default:
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
				}
			}
			else if( _item != 	NULL && _item->type == MH_ITEM_MOVIE )
			{
				_movie	=	MH_MOVIE( _item );
				switch( _propCode )
				{
					case OPC_ObjectFileName:
						if( _propType == DTC_STR)
						{
							_item->name	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data	=	_data + 1 + (*(guint8 *)_data)*2;

							if( mh_misc_get_file_type( _item->name )!= _item->type )
							{
								g_object_unref( _movie );
								_item =	NULL;
							}
			
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_ParentObject:
						if( _propType ==	DTC_UINT32)
						{
							*((guint32 *)(&(_item->tagId))+ 1)=*(guint32 *)_data;
							_data += 4;

						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_ObjectSize:
						if( _propType == DTC_UINT64)
						{
							_item->size	=	*(guint64 *)_data;
							_data += 8;
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType );
						}
						break;

					case OPC_Subtitle:
						if( _propType	==	DTC_STR)
						{
							_movie->title =	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data = _data + 1 + (*(guint8 *)_data)*2;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_Genre:
						if( _propType	==	DTC_STR)
						{
							_movie->genre =	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data = _data + 1 + (*(guint8 *)_data)*2;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;

					case OPC_Width:
						if( _propType	==	DTC_UINT32)
						{
							_movie->xres	=	*(guint32 *)_data;
							_data += 4;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;

					case OPC_Height:
						if( _propType	==	DTC_UINT32)
						{
							_movie->yres	=	*(guint32 *)_data;
							_data += 4;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;

					case OPC_Duration:
						if( _propType	==	DTC_UINT32)
						{
							_movie->duration	=	*(guint32 *)_data;
							_data += 4;
						}
						else
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					default:
						_data	=	mtp_unpack_value( _data, _propType);
						break;
				}
			
			}
			else if( _item != NULL && _item->type == MH_ITEM_PICTURE )
			{
				_picture	=	MH_PICTURE( _item );
				switch( _propCode )
				{
					case OPC_ObjectFileName:
						if( _propType == DTC_STR)
						{
							_item->name	=	g_convert( _data + 1, (*(guint8 *)_data)*2, "utf-8","utf-16le", &_read, &_write, NULL );
							_data	=	_data + 1 + (*(guint8 *)_data)*2;

							if( mh_misc_get_file_type( _item->name )!= _item->type )
							{
								g_object_unref( _picture );
								_item =	NULL;
							}
		
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_ParentObject:
						if( _propType ==	DTC_UINT32)
						{
							*((guint32 *)(&(_item->tagId))+ 1)=*(guint32 *)_data;
							_data += 4;

						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_ObjectSize:
						if( _propType == DTC_UINT64)
						{
							_item->size	=	*(guint64 *)_data;
							_data += 8;
						}
						else
						{
							g_message("-------------------------------->%d",__LINE__);
							_data	=	mtp_unpack_value( _data, _propType );
						}
						break;

					case OPC_Width:
						if( _propType == DTC_UINT32)
						{
							_picture->width	=	*(guint32 *)_data;
							_data += 4;
						}
						else 
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					case OPC_Height:
						if( _propType == DTC_UINT32)
						{
							_picture->height	=	*(guint32 *)_data;
							_data += 4;
						}
						else 
						{
							_data	=	mtp_unpack_value( _data, _propType);
						}
						break;
					default:
						_data	=	mtp_unpack_value( _data, _propType);
						break;

				}
			}
			else
			{
				_data	=	mtp_unpack_value( _data, _propType);
			}
		}
		g_free( _response);
		_response	=	getData( RC_OK, _container->transactionId );
		_container	=	( mtpContainer * )_response;
	
		if( _container != NULL )
		{
			g_free( _container );
		}

	}
	return _item;
}		/* -----  end of static function getObjectPropList  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  hash_foreach
 *  Description:  
 * =====================================================================================
 */
static void hash_foreach(gpointer key, gpointer value, gpointer user_data)
{
	g_message("key:%X,value:%p",*(guint16*)key, value);
}		/* -----  end of static function hash_foreach  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  data_manage
 *  Description:  
 * =====================================================================================
 */
static void data_manage( MHDevMtp * mtp, guint32 storageId, MHFolder * root, uint32_t type_code, MHItemType item_type, MHDevScanType scan_type)
{
	int j;
	guint32 * _parentTagId;
	MHItem * _parentItem;
	MHItem * _sonItem;
	MHItem * _item;
	MHContents * _contents;
	guint8 * _support;
	_contents	=	mh_contents_instance();

	MHMTPPropInfos *_infos;

	MHMTPObjHandles * _obj_handles; 

//	_infos 	=	getObjectPropsSupported( type_code, item_type);

//	getObjectPropDesc( _infos, type_code );
	_obj_handles	=	getObjectHandles( storageId, type_code );

	if( _obj_handles != NULL && scan_type 	==	SCAN_FOLDER )
	{
		for( j = 0; j < _obj_handles->size; j++)
		{
			_item	=	getObjectInfo( _obj_handles->handles[j], root, MH_ITEM_NONE );
		}
	}
//	else if( scan_type	==	SCAN_TAG)
//	{
//
//		for( j = 0; j < _obj_handles->size; j++)
//	}
	else if( _obj_handles !=	NULL && scan_type	==	SCAN_TAG)
	{
//		_infos	=	getObjectPropsSupported( type_code, item_type);	
		for( j = 0; j < _obj_handles->size; j++)
		{
			_item	=	getObjectPropList( _obj_handles->handles[j], root, type_code, item_type);		
			if( _item != NULL)
			{

				_item->uniqueId	= mh_contents_add_node( _contents, MH_DEV( mtp)->uniqueId, _item);
				g_hash_table_insert( MH_DEV( mtpObj)->itemsHash, &(_item->uniqueId), _item );
				g_hash_table_insert( mtpObj->MtpHash, (guint32 *)&(_item->tagId), _item );
				switch( item_type)
				{
					case MH_ITEM_MUSIC:
						MH_MUSIC( _item )->last_chgtime  = 0;//compare by lastchangtime 
						mh_contents_add_music( _contents, MH_MUSIC( _item ), MH_DEV( mtp)->uniqueId); //del db by deviceId
						break;
					case MH_ITEM_MOVIE:
						mh_contents_add_movie( _contents, MH_MOVIE( _item ), MH_DEV( mtp)->uniqueId); //del db by deviceId
						break;
					case MH_ITEM_PICTURE:
						mh_contents_add_picture( _contents, MH_PICTURE( _item ), MH_DEV( mtp)->uniqueId); //del db by deviceId
				}

				_parentTagId	= ((guint32 *)&( _item->tagId)) + 1;
				_sonItem	=	_item;
				gpointer _value =	g_hash_table_lookup( mtpObj->MtpHash, _parentTagId);
				if( _value !=	NULL)
				{
					_parentItem	=	MH_ITEM( _value );
					g_node_append( _parentItem->node, _item->node );
				}
				else 
				{
					while( _value ==	NULL)
					{
						if( *_parentTagId == 0)
						{
							g_node_append( MH_ITEM(root)->node, _sonItem->node);
							break;
						}
						else 
						{
							_parentItem	=	getObjectPropList( *_parentTagId, root, 0, MH_ITEM_FOLDER);
							g_hash_table_insert( mtpObj->MtpHash,(guint32 *)&(_parentItem->tagId), _parentItem);
							g_node_append( _parentItem->node, _sonItem->node);
							_sonItem	=	_parentItem;
							_parentTagId	=	((guint32*)&(_sonItem->tagId))+1;
							_value	=	g_hash_table_lookup( mtpObj->MtpHash, _parentTagId);
							if( _value !=	NULL)
							{
								g_node_append( MH_ITEM( _value)->node, _sonItem->node );
							}
						}
					}
				}
				mh_folder_add_type_count( (MHFolder *)(_item->node->parent->data),item_type );
				if( (item_type == MH_ITEM_MUSIC) && (mtpObj->first_music_flag == false ))
				{
					mtpObj->first_music_flag	=	true;
					g_signal_emit_by_name( MH_DEV(mtpObj) , "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_MUSIC, _item->node->parent->data, 0);

				}
				if( (item_type == MH_ITEM_MOVIE) && (mtpObj->first_movie_flag == false ))
				{
					mtpObj->first_movie_flag	=	true;
					g_signal_emit_by_name( MH_DEV(mtpObj) , "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_MOVIE,  _item->node->parent->data, 0);

				}
				if( (item_type == MH_ITEM_PICTURE) && (mtpObj->first_picture_flag == false ))
				{
					mtpObj->first_picture_flag	=	true;
					g_signal_emit_by_name( MH_DEV(mtpObj) , "dev_events", MH_DEV_FIRST_FILE, MH_ITEM_PICTURE,  _item->node->parent->data, 0);

				}
			}
		
		}
	}
	

}		/* -----  end of static function data_manage  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  String_to_OFC_MTP
 *  Description:  
 * =====================================================================================
 */
static guint16 String_to_OFC_MTP( char * str)
{
	guint16 _res	=	0x0000;
	if( g_strcmp0(str, "mp3") == 0)
		_res	=	OFC_MP3;
	else if( g_strcmp0(str, "wma") == 0)
		_res	=	OFC_MTP_WMA;
	else if( g_strcmp0( str, "aac") == 0)
		_res	=	OFC_MTP_AAC;
	else if( g_strcmp0( str, "wav") == 0)
		_res	=	OFC_WAV;
	else if( g_strcmp0(str, "ogg") == 0)
		_res	=	OFC_MTP_OGG;
	else if( g_strcmp0(str, "mp2") == 0)
		_res	=	OFC_MTP_MP2;
	
	else if( g_strcmp0(str, "mp4") == 0)
		_res	=	OFC_MTP_MP4;
	else if( g_strcmp0(str, "3gp") == 0)
		_res	=	OFC_MTP_3GP;
	else if( g_strcmp0(str, "avi") == 0)
		_res	=	OFC_AVI;
//	else if( g_strcmp0(str, "mkv") == 0)
//		_res	=	OFC_MTP_WMA;
//	else if( g_strcmp0(str, "mpg") == 0)
//		_res	=	OFC_MTP_WMA;
	else if( g_strcmp0(str, "mpeg") == 0)
		_res	=	OFC_MPEG;
	else if( g_strcmp0(str, "wmv") == 0)
		_res	=	OFC_MTP_WMV;
//	else if( g_strcmp0(str, "vob") == 0)
//		_res	=	OFC_MTP_WMA;
//	else if( g_strcmp0(str, "flv") == 0)
//		_res	=	OFC_MTP_WMA;
//	else if( g_strcmp0(str, "swf") == 0)
//		_res	=	OFC_MTP_WMA;
//	else if( g_strcmp0(str, "mov") == 0)
//		_res	=	OFC_MTP_WMA;
//	else if( g_strcmp0(str, "dat") == 0)
//		_res	=	OFC_MTP_WMA;
	
//	else if( g_strcmp0(str, "jpg") == 0)
//		_res	=	OFC_MTP_WMA;
	else if( g_strcmp0(str, "png") == 0)
		_res	=	OFC_PNG;
	else if( g_strcmp0(str, "bmp") == 0)
		_res	=	OFC_BMP;
	else if( g_strcmp0(str, "jpeg") == 0)
		_res	=	OFC_EXIF_JPEG;
	else if( g_strcmp0(str, "jfif") == 0)
		_res	=	OFC_JFIF;
//	else if( g_strcmp0(str, "jpe") == 0)
//		_res	=	OFC_MTP_WMA;
//	else if( g_strcmp0(str, "ico") == 0)
//		_res	=	OFC_MTP_WMA;
	else if( g_strcmp0(str, "gif") == 0)
		_res	=	OFC_GIF;
	else if( g_strcmp0(str, "tiff") == 0)
		_res	=	OFC_TIFF;
	else
		g_message("%s is unsupport", str);
//	else if( g_strcmp0(str, "tif") == 0)
//		_res	=	OFC_MTP_WMA;



	return _res;

}		/* -----  end of static function String_to_OFC_MTP  ----- */
/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  scan_source
 *  Description:  
 * =====================================================================================
 */
static gboolean scan_source( gpointer user_data )
{
	MTP_TIME_BEGIN();
	MTP_TIME_DUR_BEGIN();
	gpointer * _user_data	=	(gpointer *)user_data;

	MHDevMtp * _mtp	=	MH_DEV_MTP( _user_data[0] );

	MHDevScanType * _type	=	(MHDevScanType *)(_user_data[1]);
	
	int i,j;
	MHContents * _contents;
	MHFilterData * _filter;
	guint16 _mtp_code;
	MHFolder * _root;
	MHFolder * _folder[mtpObj->storageIds->count];
	MHItem * _item;
	/* Append device to database */
	if( *_type 	==	SCAN_TAG)
	{
		_contents	=	mh_contents_instance();
		mh_contents_begin_transaction( _contents );

		MH_DEV( _mtp )->uniqueId	=	mh_contents_add_device( mh_contents_instance(),
			MH_DEV( _mtp )->serial );
	}
	_filter = mh_misc_get_filter();
	

	_root =	g_object_new( MH_TYPE_FOLDER, NULL);
	_item	=	MH_ITEM( _root );
	_item->dev	=	MH_DEV( mtpObj );

	_item->type	=	MH_ITEM_FOLDER;
	_item->name	=	g_strdup(".");
	_item->tagId	=	0;
	_item->node	=	g_node_new( _item );
	_root->scanned	=	TRUE;
//	g_hash_table_insert( mtpObj->MtpHash, (guint32 *)&(_item->tagId), _item );
	mtpObj->root	=	_root;
	for( i = 0; i < mtpObj->storageIds->count; i++)
	{
		_folder[i]	=	g_object_new( MH_TYPE_FOLDER, NULL);
		_item	=	MH_ITEM( _folder[i]);
		_item->dev	=	MH_DEV( mtpObj );
		_item->name	=	g_strdup( mtpObj->devInfo->storageInfos[i]->storageDescription );
		_item->type	=	MH_ITEM_FOLDER;
		_item->tagId	=	0;
		_item->node	=	g_node_new( _item );
		_folder[i]->scanned	=	TRUE;
		g_node_append( MH_ITEM( _root )->node, _item->node);
		for(j = 0 ; j < _filter->size; j++)
		{
			_mtp_code	=	String_to_OFC_MTP( _filter->data[j].filter);
			if( (_mtp_code !=	0x0000) && (getNumObjects( _mtp_code) != 0))
			{
				g_message("storageid[%d]:%X",i,mtpObj->storageIds->ids[i]);
				data_manage( _mtp, mtpObj->storageIds->ids[i], _folder[i], _mtp_code, _filter->data[j].type, *_type);
			}
		}


	}
	
	g_message( "sync completed" );
	mh_contents_commit_transaction( _contents );
	g_free( _user_data[1]);
	g_free( _user_data );
	MTP_TIME_DUR_END();
	MTP_TIME_END();
	return G_SOURCE_REMOVE;
}		/* -----  end of static function scan_source  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _needData
 *  Description:  
 * =====================================================================================
 */
static void _needData( GstAppSrc * src, guint arg0, gpointer user_data )
{
	MHPb * _pb	=	MH_PB( user_data );
	guint32 _handle;
	guint8 * _response;
	GstBuffer * _buf;
	GstFlowReturn _ret;
	gint64 _size;
	int _count;
	int _offset	=	0;
	int _length	=	arg0;
	int _cp;
	mtpContainer * _container;
	int i;
	gint _key;
	gpointer _block;
	gboolean _missed	=	FALSE;
	gint64 _objSize;

	if( mtpObj == NULL )
		return;

	_handle	=	g_array_index( _pb->playlist->array, MHItemData *, 
			_pb->playlist->seq[_pb->playlist->index])->tagId;

	_objSize	=	g_array_index( _pb->playlist->array, MHItemData *, 
			_pb->playlist->seq[_pb->playlist->index])->size;

	_buf	=	gst_buffer_new_and_alloc( arg0 );

	_count	=	1;

	if( objectOffset % CACHE_BLOCK_SIZE + arg0 > CACHE_BLOCK_SIZE )
	{
		_count	+=	( arg0 - ( CACHE_BLOCK_SIZE - objectOffset % CACHE_BLOCK_SIZE ) + CACHE_BLOCK_SIZE - 1 ) / CACHE_BLOCK_SIZE;
	}

	for( i = 0; i < _count; i ++ )
	{
		_key	=	(( objectOffset + i * CACHE_BLOCK_SIZE )& 0xFFFF0000 ) >> 16;

		if( _block = g_hash_table_lookup( cacheHt, &_key ) )
		{
			_cp	=	_length > CACHE_BLOCK_SIZE - ( objectOffset + _offset ) % CACHE_BLOCK_SIZE ?
				CACHE_BLOCK_SIZE - ( objectOffset + _offset ) % CACHE_BLOCK_SIZE : _length;

			memcpy( GST_BUFFER_DATA( _buf ) + _offset, _block + ( objectOffset + _offset ) % CACHE_BLOCK_SIZE, _cp );

			_offset	+=	_cp;

			_length	-=	_cp;
		}
		else
		{
			gint * _newKey	=	g_new0( gint, 1 );

			_block	=	g_malloc0( CACHE_BLOCK_SIZE );

			_key	=	( objectOffset + i * CACHE_BLOCK_SIZE ) & 0xFFFF0000;

			g_message( "cache missed: %d %d", objectOffset, _key );
			_response	=	getPartialObject( _handle, _key, _objSize - _key > CACHE_BLOCK_SIZE ?
					CACHE_BLOCK_SIZE : _objSize - _key );

			if( _response != NULL )
			{
				_container	=	( mtpContainer * )_response;

				_size	=	_container->length - sizeof( mtpContainer );

				if( _size > 0 )
				{
					memcpy( _block, _response + sizeof( mtpContainer ), _size );

					_cp	=	_length > CACHE_BLOCK_SIZE - ( objectOffset + _offset ) % CACHE_BLOCK_SIZE ?
						CACHE_BLOCK_SIZE - ( objectOffset + _offset ) % CACHE_BLOCK_SIZE : _length;

					memcpy( GST_BUFFER_DATA( _buf ) + _offset, _block + ( objectOffset + _offset ) % CACHE_BLOCK_SIZE, _cp );

					_offset	+=	_cp;

					_length	-=	_cp;

					_key	>>=	16;

					* _newKey	=	_key;

					g_hash_table_insert( cacheHt, _newKey, _block );

					g_queue_push_head( dirtyQ, _newKey );
				}

				g_free( _response );
			}

			_missed	=	TRUE;
		}
	}

	GST_BUFFER_OFFSET( _buf )	=	objectOffset;
	GST_BUFFER_SIZE( _buf )	=	arg0;

	g_signal_emit_by_name( src, "push-buffer", _buf, &_ret );

	gst_buffer_unref( _buf );

	objectOffset	+=	arg0;

	_key	=	( objectOffset + CACHE_BLOCK_SIZE ) & 0xFFFF0000;

	for( i = 0; i < CACHE_NEED_EXTEND && _key < _objSize; i ++ )
	{
		gint * _newKey;
		gint _hkey;

		_hkey	=	_key >> 16;

		_block	=	g_hash_table_lookup( cacheHt, &_hkey );
		
		if( _block == NULL )
		{
			_block	=	g_malloc0( CACHE_BLOCK_SIZE );

			_response	=	getPartialObject( _handle, _key ,  _objSize - _key > CACHE_BLOCK_SIZE ?
					CACHE_BLOCK_SIZE : _objSize - _key );

			if( _response != NULL )
			{
				_container	=	( mtpContainer * )_response;

				_size	=	_container->length - sizeof( mtpContainer );

				if( _size > 0 )
				{
					memcpy( _block, _response + sizeof( mtpContainer ), _size );

					_newKey	=	g_new0( gint, 1 );

					*_newKey	=	_key >> 16;

					g_hash_table_insert( cacheHt, _newKey, _block );

					g_queue_push_head( dirtyQ, _newKey );
				}

				g_free( _response );
			}
		}
		
		_key	+=	CACHE_BLOCK_SIZE;
	}

	while( dirtyQ->length > CACHE_MAX_BLOCK )
	{
		gint * _dirty	=	g_queue_pop_tail( dirtyQ );

		g_hash_table_remove( cacheHt, _dirty );
	}

	g_object_get( src, "size", &_size, NULL );

	if( objectOffset == _size )
	{
		g_message( "reached eof" );

//		g_signal_emit_by_name( src, "end-of-stream", &_ret );
	}
}		/* -----  end of static function _needData  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _enoughData
 *  Description:  
 * =====================================================================================
 */
static void _enoughData( GstElement * src, gpointer user_data )
{
	g_message( "%s", __func__ );
}		/* -----  end of static function _enoughData  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _seekData
 *  Description:  
 * =====================================================================================
 */
static gboolean _seekData( GstAppSrc * src, gint64 arg0, gpointer user_data )
{
	objectOffset	=	arg0;
	return TRUE;
}		/* -----  end of static function _seekData  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _setupSrc
 *  Description:  
 * =====================================================================================
 */
static void _setupSrc( GstElement * object, GstElement * arg0, gpointer user_data )
{
	MHPb * _pb	=	MH_PB( user_data );
	gint64 _size	=	g_array_index( _pb->playlist->array, MHItemData *, 
			_pb->playlist->seq[_pb->playlist->index])->size;

	objectOffset	=	0;

	g_object_set( arg0, "size", _size, "stream-type", GST_APP_STREAM_TYPE_RANDOM_ACCESS, NULL );

	g_signal_connect ( arg0, "need-data", G_CALLBACK( _needData ), user_data );
	g_signal_connect ( arg0, "enough-data", G_CALLBACK( _enoughData ), user_data );
	g_signal_connect ( arg0, "seek-data", G_CALLBACK( _seekData ), user_data );
}		/* -----  end of static function _setupSrc  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  createPipeline
 *  Description:  
 * =====================================================================================
 */
static GstElement * createPipeline( gpointer user_data )
{
	GstElement * _pipeline	=	NULL;
	GstElement * _video	=	NULL;

	_pipeline	=	gst_element_factory_make( "playbin2", "playbin" );
	_video	=	gst_element_factory_make( "glimagesink", "sink" );
	g_object_set( _pipeline, "video-sink", _video, NULL );
	g_signal_connect( _pipeline, "source-setup", G_CALLBACK( _setupSrc ), user_data );

	g_object_set( _pipeline, "uri", "appsrc://", NULL );

	return _pipeline;
}		/* -----  end of static function createPipeline  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _play_by_list
 *  Description:  
 * =====================================================================================
 */
static void _play_by_list( MHDev * self, MHPb * pb, MHPlaylist * playlist )
{
	pb->playlist	=	playlist;

	if( pb->pipeline == NULL )
		pb->pipeline	=	createPipeline( pb );

	gst_element_set_state( pb->pipeline, GST_STATE_PLAYING );
	gst_element_get_state( pb->pipeline, NULL, NULL, -1 );
}		/* -----  end of static function _play_by_list  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _start_scan
 *  Description:  
 * =====================================================================================
 */
static void _start_scan( MHDev * self, MHDevScanType type)
{
	GSource * _source	=	g_idle_source_new();
	
	gpointer * user_data	=	g_malloc0( sizeof ( gpointer )*2);
	MHDevScanType * _type	=	g_malloc0( sizeof( MHDevScanType));
	* _type	=	type;
	user_data[0]	=	( gpointer ) self;
	user_data[1]	=	( gpointer )_type;
	g_source_set_callback( _source, scan_source, (gpointer)user_data, NULL );

	mh_io_dispatch( MH_IO( self ), _source );

	g_source_unref( _source );
}		/* -----  end of static function _start_scan  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _next
 *  Description:
 * =====================================================================================
 */
static void _next( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _next  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _previous
 *  Description:
 * =====================================================================================
 */
static void _previous( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _previous  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _seek
 *  Description:
 * =====================================================================================
 */
static void _seek( MHDev * self, MHPb * pb, uint32_t second )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _seek  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  _restore_playlist
 *  Description:  
 * =====================================================================================
 */
static MHPlaylist * _restore_playlist( MHDev * self,gint64 playlist_id )
{
	MHPlaylist * _playlist	=	NULL;


	//Method default implement.
	g_assert_not_reached();
	return _playlist;
}		/* -----  end of static function _restore_playlist  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _attach_pb
 *  Description:
 * =====================================================================================
 */
static void _attach_pb( MHDev * self, MHPb * pb )
{

	//Method default implement.
	g_assert_not_reached();
}      /* -----  end of static function _attach_pb  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_mtp_dispose
 *  Description:
 * =====================================================================================
 */
static void mh_dev_mtp_dispose( GObject * object )
{
	MHDevMtp * _self	=	MH_DEV_MTP( object );

	libusb_close( _self->handle );

	if( mtpObj->devInfo != NULL )
	{
		g_free( mtpObj->devInfo->mtpExtensions );
		g_free( mtpObj->devInfo->operationSupported );
		g_free( mtpObj->devInfo->eventsSupported );
		g_free( mtpObj->devInfo->devicePropertiesSupported );
		g_free( mtpObj->devInfo->captureFormats );
		g_free( mtpObj->devInfo->playbackFormats );
		g_free( mtpObj->devInfo->manufacturer );
		g_free( mtpObj->devInfo->model );
		g_free( mtpObj->devInfo->deviceVersion );
		g_free( mtpObj->devInfo->serialNumber );

		g_free( mtpObj->devInfo );
	}

	if( mtpObj->storageIds != NULL )
	{
		g_free( mtpObj->storageIds->ids );
		g_free( mtpObj->storageIds );
	}

	mh_contents_delete_device( mh_contents_instance(), MH_DEV( mtpObj )->uniqueId );

	mtpObj	=	NULL;

	G_OBJECT_CLASS( mh_dev_mtp_parent_class )->dispose( object );
}

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_mtp_finalize
 *  Description:
 * =====================================================================================
 */
static void mh_dev_mtp_finalize( GObject * object )
{
	MHDevMtp * _self	=	MH_DEV_MTP( object );
	MHDevMtpPrivate * _priv	=	mh_dev_mtp_get_instance_private( _self );

	G_OBJECT_CLASS( mh_dev_mtp_parent_class )->finalize( object );
}

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  onAddPollFd
 *  Description:  
 * =====================================================================================
 */
static void onAddPollFd (int fd, short events, void *user_data)
{
	GPollFD * _gFd	=	g_new0(GPollFD, 1);
	GSource * _source	=	(GSource *)user_data;

	printf("libusb add poll fd %d %x\n", fd, events);

	_gFd->fd		=	fd;
	_gFd->events	=	events;

	mtpObj->mtpFds	=	g_list_prepend( mtpObj->mtpFds, _gFd );

	g_source_add_poll(_source, _gFd);
}		/* -----  end of static function onAddPollFd  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  onRemovePollFd
 *  Description:  
 * =====================================================================================
 */
static void onRemovePollFd (int fd, void *user_data)
{
	GSource * _source	=	(GSource *)user_data;
	GList * _item;

	printf("libusb remove poll fd %d\n", fd);

	if( mtpObj == NULL )
		return;

	for(_item = mtpObj->mtpFds; _item != NULL; _item = _item->next)
	{
		if(((GPollFD *)_item->data)->fd == fd)
		{
			g_source_remove_poll(_source, _item->data);

			mtpObj->mtpFds	=	g_list_remove( mtpObj->mtpFds, _item->data );

			break;
		}
	}
}		/* -----  end of static function onRemovePollFd  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  prepare
 *  Description:  
 * =====================================================================================
 */
static gboolean prepare(GSource * source, gint * timeout)
{
	* timeout	=	-1;

	return FALSE;
}		/* -----  end of static function prepare  ----- */


/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  check
 *  Description:  
 * =====================================================================================
 */
static gboolean check(GSource * source)
{
	int _ret	=	FALSE;
	GList * _item;

	if( mtpObj != NULL )
	{
		for(_item = mtpObj->mtpFds; _item != NULL; _item = _item->next)
		{
			if(((GPollFD *)_item->data)->revents != 0)
			{
				_ret	=	TRUE;

				break;
			}
		}
	}

	return _ret;
}		/* -----  end of static function check  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  dispatch
 *  Description:  
 * =====================================================================================
 */
static gboolean dispatch(GSource * source, GSourceFunc callback, gpointer user_data)
{
	libusb_handle_events( usbCtx );

	return TRUE;
}		/* -----  end of static function dispatch  ----- */

static GSourceFuncs usbSourceFuncs	=	{
	.prepare	=	prepare,
	.check		=	check,
	.dispatch	=	dispatch
};

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  onTransferFailed
 *  Description:  
 * =====================================================================================
 */
static void onTransferFailed ( const char * func, enum libusb_transfer_status status )
{
	switch(status)
	{
	case LIBUSB_TRANSFER_ERROR:
		printf("%s: Transfer Status(LIBUSB_TRANSFER_ERROR)\n", func);
		break;
	case LIBUSB_TRANSFER_TIMED_OUT:
		printf("%s: Transfer Status(LIBUSB_TRANSFER_TIMED_OUT)\n", func);
		break;
	case LIBUSB_TRANSFER_CANCELLED:
		printf("%s: Transfer Status(LIBUSB_TRANSFER_CANCELLED)\n", func);
		break;
	case LIBUSB_TRANSFER_STALL:
		printf("%s: Transfer Status(LIBUSB_TRANSFER_STALL)\n", func);
		break;
	case LIBUSB_TRANSFER_NO_DEVICE:
		printf("%s: Transfer Status(LIBUSB_TRANSFER_NO_DEVICE)\n", func);
		break;
	case LIBUSB_TRANSFER_OVERFLOW:
		printf("%s: Transfer Status(LIBUSB_TRANSFER_OVERFLOW)\n", func);
		break;
	default:
		printf("%s: Unknown Transfer Status %d\n", __func__, status);
		break;
	}
}		/* -----  end of static function onTransferFailed  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  eventSource
 *  Description:  
 * =====================================================================================
 */
static gboolean eventSource( gpointer user_data )
{
	int i;
	struct libusb_transfer * _xfer	=	( struct libusb_transfer * )user_data;

	if( _xfer->status == LIBUSB_TRANSFER_COMPLETED )
	{
		mtpContainer * _container	=	( mtpContainer * )_xfer->buffer;

		switch( _container->code )
		{
		case EC_UNDEFINED:
			g_message( "uncatched event: %s", "EC_UNDEFINED" );
			break;
		case EC_CANCELTRANSACTION:
			g_message( "uncatched event: %s", "EC_CANCELTRANSACTION" );
			break;
		case EC_OBJECTADDED:
			g_message( "uncatched event: %s", "EC_OBJECTADDED" );
			break;
		case EC_OBJECTREMOVED:
			g_message( "uncatched event: %s", "EC_OBJECTREMOVED" );
			break;
		case EC_STOREADDED:
			g_message( "uncatched event: %s", "EC_STOREADDED" );
			mtpObj->storageIds	=	getStorageIDs();

			for( i = 0; i < mtpObj->storageIds->count; i ++ )
			{
				if(( mtpObj->storageIds->ids[i] & 0xFFFF0000 ) != 0 )
				{
					mtpObj->unlocked	=	TRUE;

					break;
				}
			}

			if( mtpObj->unlocked )
				mh_core_attach_dev( MH_DEV( mtpObj ));
			else
				g_message( "MTP device is locked, unlock it first." );

			break;
		case EC_STOREREMOVED:
			g_message( "uncatched event: %s", "EC_STOREREMOVED" );
			break;
		case EC_DEVICEPROPCHANGED:
			g_message( "uncatched event: %s", "EC_DEVICEPROPCHANGED" );
			break;
		case EC_OBJECTINFOCHANGED:
			g_message( "uncatched event: %s", "EC_OBJECTINFOCHANGED" );
			break;
		case EC_DEVICEINFOCHANGED:
			g_message( "uncatched event: %s", "EC_DEVICEINFOCHANGED" );
			break;
		case EC_REQUESTOBJECTTRANSFER:
			g_message( "uncatched event: %s", "EC_REQUESTOBJECTTRANSFER" );
			break;
		case EC_STOREFULL:
			g_message( "uncatched event: %s", "EC_STOREFULL" );
			break;
		case EC_DEVICERESET:
			g_message( "uncatched event: %s", "EC_DEVICERESET" );
			break;
		case EC_STORAGEINFOCHANGED:
			g_message( "uncatched event: %s", "EC_STORAGEINFOCHANGED" );
			break;
		case EC_CAPTURECOMPLETE:
			g_message( "uncatched event: %s", "EC_CAPTURECOMPLETE" );
			break;
		case EC_UNREPORTEDSTATUS:
			g_message( "uncatched event: %s", "EC_UNREPORTEDSTATUS" );
			break;
		default:
			g_message( "uncached event: %X", _container->code );
			g_assert_not_reached();
			break;
		}
		g_message( "%s", __func__ );
		//DEBUG_HEX_DISPLAY( _xfer->buffer, _xfer->actual_length );

		libusb_submit_transfer( _xfer );
	}
	else
	{
		onTransferFailed( __func__, _xfer->status );

		libusb_free_transfer( _xfer );
	}

	return G_SOURCE_REMOVE;
}		/* -----  end of static function eventSource  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  onDataArrived
 *  Description:  
 * =====================================================================================
 */
static void onDataArrived( struct libusb_transfer * transfer )
{
	GSource * _source	=	g_idle_source_new();

	g_source_set_callback( _source, eventSource, transfer, NULL );

	mh_io_dispatch( MH_IO( mtpObj ), _source );

	g_source_unref( _source );
}		/* -----  end of static function onDataArrived  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_mtp_init
 *  Description:
 * =====================================================================================
 */
static void mh_dev_mtp_init( MHDevMtp * self )
{
	MHDevMtpPrivate * _priv	=	mh_dev_mtp_get_instance_private( self );
	MHDev * _dev	=	MH_DEV( self );
	struct libusb_config_descriptor * _config;
	GSource * _source	=	g_source_new( &usbSourceFuncs, sizeof( GSource ));
	int _retry	=	0;
	struct libusb_transfer * _xfer;
	int i;
	
	GRecMutex * _mutex;
	_mutex	=	g_new0( GRecMutex, 1);
	g_rec_mutex_init( _mutex );
	_priv->mutex	=	_mutex;

	mtpObj	=	self;

	self->MtpHash	=	g_hash_table_new_full( g_int_hash, g_int_equal, g_free, g_free);

	cacheHt	=	g_hash_table_new_full( g_int_hash, g_int_equal, g_free, g_free );
	dirtyQ	=	g_queue_new();

	transactionId	=	0;

	_dev->type	=	"mtp";

	libusb_set_pollfd_notifiers( usbCtx, onAddPollFd, onRemovePollFd, _source );

	do
	{
		self->handle	=	libusb_open_device_with_vid_pid( usbCtx, strtol( vendorId, NULL, 16 ), 
				strtol( productId, NULL, 16 ));

		if( self->handle == NULL )
		{
			usleep( 100000 );

			_retry ++;
		}
	} while( _retry < 3 && self->handle == NULL );

	if( self->handle != NULL )
	{
		self->device	=	libusb_get_device( self->handle );

		libusb_get_active_config_descriptor( self->device, &_config );

		for( i = 0; i < _config->bNumInterfaces; i ++ )
		{
			const struct libusb_interface_descriptor * _interface;
			gchar _string[10];
			int j;

			_interface	=	( _config->interface + i )->altsetting;

			libusb_get_string_descriptor_ascii( self->handle, _interface->iInterface, 
					_string, sizeof( _string ));

			if( g_ascii_strcasecmp( _string, "mtp" ) == 0 )
			{
				libusb_claim_interface( self->handle, _interface->bInterfaceNumber );

				for( j = 0; j < _interface->bNumEndpoints; j ++ )
				{
					const struct libusb_endpoint_descriptor * _endpoint;

					_endpoint	=	_interface->endpoint + j;

					switch( _endpoint->bmAttributes )
					{
						case 0x02:
							if( _endpoint->bEndpointAddress & 0x80 )
							{
								self->bulkInEp	=	_endpoint->bEndpointAddress;
								self->maxPacketSize	=	_endpoint->wMaxPacketSize;
							}
							else
								self->bulkOutEp	=	_endpoint->bEndpointAddress;
							break;
						case 0x03:
							self->intEp	=	_endpoint->bEndpointAddress;
							break;
						default:
							g_assert_not_reached();
							break;
					}
				}

				break;
			}
		}

		_xfer	=	libusb_alloc_transfer( 0 );

		libusb_fill_interrupt_transfer( _xfer, mtpObj->handle, mtpObj->intEp, intBuff, sizeof( intBuff ),
				onDataArrived, NULL, 0 );

		libusb_submit_transfer( _xfer );

		mh_io_dispatch( MH_IO( self ), _source );

		g_source_unref( _source );

		openSession( MTP_DEFAULT_SESSION_ID );

		mtpObj->devInfo	=	getDeviceInfo();
		mtpObj->compatilibility	=	checkCompatibility( mtpObj->devInfo );
		mtpObj->storageIds	=	getStorageIDs();
	
		if( mtpObj->storageIds != NULL )
		{
			mtpObj->devInfo->storageInfos = ( MHMTPStorageInfo **)g_malloc0(sizeof( MHMTPPropInfos*) * (mtpObj->storageIds->count));
			
			for( i = 0; i < mtpObj->storageIds->count; i ++ )
			{
				mtpObj->devInfo->storageInfos[i]  = getStorageInfo( mtpObj->storageIds->ids[i]);	

				if(( mtpObj->storageIds->ids[i] & 0xFFFF0000 ) != 0 )
				{
					mtpObj->unlocked	=	TRUE;

				}
			}

			if( mtpObj->unlocked )
				mh_core_attach_dev( MH_DEV( mtpObj ));
			else
				g_message( "MTP device is locked, unlock it first." );
		}
	}
	self->first_music_flag	=	false;
	self->first_movie_flag	=	false;
	self->first_picture_flag=	false;
}       /* -----  end of static function mh_dev_mtp_init  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  _get_property
 *  Description:
 * =====================================================================================
 */
static void _get_property( GObject * object, guint property_id, GValue * value,
		        GParamSpec * spec)
{
	MHDevMtp * _self  =   MH_DEV_MTP( object );
	switch( property_id )
	{
	case PROP_DEV_MTP_ROOT:
		g_message("mtp:_get_property");	
		g_value_set_pointer( value, _self->root );
		
		break;
	default:
		break;
	}
}       /*  -----  end of static function _get_property  ----- */

/*
 * ===  FUNCTION  ======================================================================
 *         Name:  mh_dev_mtp_class_init
 *  Description:
 * =====================================================================================
 */
static void mh_dev_mtp_class_init( MHDevMtpClass * klass )
{
	MHDevClass * _parentClass	=	MH_DEV_CLASS( klass );
	GObjectClass * _gobjectClass	=	G_OBJECT_CLASS( klass );

	_gobjectClass->dispose	=	mh_dev_mtp_dispose;
	_gobjectClass->finalize	=	mh_dev_mtp_finalize;
	_gobjectClass->get_property =   _get_property;

	/* assemble ios of mh_dev_mtp class */

	/* assemble methods of mh_dev_mtp class */
	_parentClass->play_by_list	=	_play_by_list;
	_parentClass->stop	=	_stop;
	_parentClass->play	=	_play;
	_parentClass->pause	=	_pause;
	_parentClass->play_pause	=	_play_pause;
	_parentClass->resume	=	_resume;
	_parentClass->forward	=	_forward;
	_parentClass->forward_done	=	_forward_done;
	_parentClass->backward	=	_backward;
	_parentClass->backward_done	=	_backward_done;
	_parentClass->set_index	=	_set_index;
	_parentClass->set_speed	=	_set_speed;
	_parentClass->set_repeat	=	_set_repeat;
	_parentClass->set_shuffle	=	_set_shuffle;
	_parentClass->set_buffer_time	=	_set_buffer_time;
	_parentClass->start_scan	=	_start_scan;
	_parentClass->next	=	_next;
	_parentClass->previous	=	_previous;
	_parentClass->seek 	= 	_seek;	

	_parentClass->save_playlist	=	NULL;
	_parentClass->restore_playlist	=	_restore_playlist;
	_parentClass->attach_pb	=	_attach_pb;

	devMtpProperties[ PROP_DEV_MTP_ROOT] =
		g_param_spec_pointer( "base", "MHDevMtp's property", "Root folder of mtp",
				G_PARAM_READABLE );
	g_object_class_install_properties( _gobjectClass, MTP_N_PROPERTIES, devMtpProperties );
	/* Ios */
	/* Signals */
}       /* -----  end of static function mh_dev_mtp_class_init  ----- */

